{"version":3,"names":["cliOptions","babelOptions","buildResult","fileResults","mapSections","code","offset","hasRawMap","result","map","push","line","column","version","names","sources","mappings","countNewlines","AnyMap","file","sourceMapTarget","path","basename","outFile","sections","sourceRoot","sourceMaps","convertSourceMap","fromObject","encodedMap","toComment","count","index","indexOf","output","dirname","recursive","outputMap","undefined","util","hasDataSourcemap","mapLoc","addSourceMappingUrl","fs","writeFileSync","JSON","stringify","process","stdout","write","readStdin","Promise","resolve","reject","stdin","setEncoding","on","chunk","read","res","transformRepl","filename","sourceFileName","walk","filenames","_filenames","forEach","existsSync","stat","statSync","isDirectory","readdirForCompilable","includeDotfiles","extensions","join","results","all","sourceFilename","relative","slash","compile","err","watch","console","error","files","watcher","enable","enableGlobbing","skipInitialBuild","startWatcher","onFilesChange","changes","event","cause","actionableChange","some","isCompilableExtension","includes","verbose","log","catch","length"],"sources":["../../src/babel/file.ts"],"sourcesContent":["import convertSourceMap from \"convert-source-map\";\nimport { AnyMap, encodedMap } from \"@jridgewell/trace-mapping\";\nimport slash from \"slash\";\nimport path from \"path\";\nimport fs from \"fs\";\n\nimport * as util from \"./util\";\nimport type { CmdOptions } from \"./options\";\nimport * as watcher from \"./watcher\";\n\nimport type {\n  SectionedSourceMap,\n  SourceMapInput,\n  TraceMap,\n} from \"@jridgewell/trace-mapping\";\nimport type { FileResult } from \"@babel/core\";\n\ntype CompilationOutput = {\n  code: string;\n  map: SourceMapInput;\n  hasRawMap: boolean;\n};\n\nexport default async function ({\n  cliOptions,\n  babelOptions,\n}: CmdOptions): Promise<void> {\n  function buildResult(fileResults: Array<FileResult>): CompilationOutput {\n    const mapSections: SectionedSourceMap[\"sections\"] = [];\n\n    let code = \"\";\n    let offset = 0;\n\n    let hasRawMap = false;\n\n    for (const result of fileResults) {\n      if (!result) continue;\n\n      hasRawMap = !!result.map;\n\n      mapSections.push({\n        offset: { line: offset, column: 0 },\n        map: result.map || {\n          version: 3,\n          names: [],\n          sources: [],\n          mappings: [],\n        },\n      });\n\n      code += result.code + \"\\n\";\n      offset += countNewlines(result.code) + 1;\n    }\n\n    const map = new AnyMap({\n      version: 3,\n      file:\n        cliOptions.sourceMapTarget ||\n        path.basename(cliOptions.outFile || \"\") ||\n        \"stdout\",\n      sections: mapSections,\n    });\n    // For some reason, the spec doesn't allow sourceRoot when constructing a\n    // sectioned sourcemap. But AllMap returns a regular sourcemap, we can\n    // freely add to with a sourceRoot.\n    map.sourceRoot = babelOptions.sourceRoot;\n\n    // add the inline sourcemap comment if we've either explicitly asked for inline source\n    // maps, or we've requested them without any output file\n    if (\n      babelOptions.sourceMaps === \"inline\" ||\n      (!cliOptions.outFile && babelOptions.sourceMaps)\n    ) {\n      code += \"\\n\" + convertSourceMap.fromObject(encodedMap(map)).toComment();\n    }\n\n    return {\n      map: map,\n      code: code,\n      hasRawMap: hasRawMap,\n    };\n  }\n\n  function countNewlines(code: string): number {\n    let count = 0;\n    let index = -1;\n    while ((index = code.indexOf(\"\\n\", index + 1)) !== -1) {\n      count++;\n    }\n    return count;\n  }\n\n  function output(fileResults: Array<FileResult>): void {\n    const result = buildResult(fileResults);\n\n    if (cliOptions.outFile) {\n      fs.mkdirSync(path.dirname(cliOptions.outFile), { recursive: true });\n\n      let outputMap: \"both\" | \"external\" | false = false;\n      if (babelOptions.sourceMaps && babelOptions.sourceMaps !== \"inline\") {\n        outputMap = \"external\";\n      } else if (babelOptions.sourceMaps == undefined && result.hasRawMap) {\n        outputMap = util.hasDataSourcemap(result.code) ? \"external\" : \"both\";\n      }\n\n      if (outputMap) {\n        const mapLoc = cliOptions.outFile + \".map\";\n        if (outputMap === \"external\") {\n          result.code = util.addSourceMappingUrl(result.code, mapLoc);\n        }\n        fs.writeFileSync(\n          mapLoc,\n          JSON.stringify(encodedMap(result.map as TraceMap)),\n        );\n      }\n\n      fs.writeFileSync(cliOptions.outFile, result.code);\n    } else {\n      process.stdout.write(result.code + \"\\n\");\n    }\n  }\n\n  function readStdin(): Promise<string> {\n    return new Promise((resolve, reject): void => {\n      let code = \"\";\n\n      process.stdin.setEncoding(\"utf8\");\n\n      process.stdin.on(\"readable\", function () {\n        const chunk = process.stdin.read();\n        if (chunk !== null) code += chunk;\n      });\n\n      process.stdin.on(\"end\", function () {\n        resolve(code);\n      });\n      process.stdin.on(\"error\", reject);\n    });\n  }\n\n  async function stdin(): Promise<void> {\n    const code = await readStdin();\n\n    const res = await util.transformRepl(cliOptions.filename, code, {\n      ...babelOptions,\n      sourceFileName: \"stdin\",\n    });\n\n    output([res]);\n  }\n\n  async function walk(filenames: Array<string>): Promise<void> {\n    const _filenames: string[] = [];\n\n    filenames.forEach(function (filename) {\n      if (!fs.existsSync(filename)) return;\n\n      const stat = fs.statSync(filename);\n      if (stat.isDirectory()) {\n        const dirname = filename;\n\n        util\n          .readdirForCompilable(\n            filename,\n            cliOptions.includeDotfiles,\n            cliOptions.extensions,\n          )\n          .forEach(function (filename) {\n            _filenames.push(path.join(dirname, filename));\n          });\n      } else {\n        _filenames.push(filename);\n      }\n    });\n\n    const results = await Promise.all(\n      _filenames.map(async function (filename: string): Promise<any> {\n        let sourceFilename = filename;\n        if (cliOptions.outFile) {\n          sourceFilename = path.relative(\n            path.dirname(cliOptions.outFile),\n            sourceFilename,\n          );\n        }\n        sourceFilename = slash(sourceFilename);\n\n        try {\n          return await util.compile(filename, {\n            ...babelOptions,\n            sourceFileName: sourceFilename,\n            // Since we're compiling everything to be merged together,\n            // \"inline\" applies to the final output file, but not to the individual\n            // files being concatenated.\n            sourceMaps:\n              babelOptions.sourceMaps === \"inline\"\n                ? true\n                : babelOptions.sourceMaps,\n          });\n        } catch (err) {\n          if (!cliOptions.watch) {\n            throw err;\n          }\n\n          console.error(err);\n          return null;\n        }\n      }),\n    );\n\n    output(results);\n  }\n\n  async function files(filenames: Array<string>): Promise<void> {\n    if (cliOptions.watch) {\n      watcher.enable({ enableGlobbing: false });\n    }\n\n    if (!cliOptions.skipInitialBuild) {\n      await walk(filenames);\n    }\n\n    if (cliOptions.watch) {\n      filenames.forEach(watcher.watch);\n\n      watcher.startWatcher();\n\n      watcher.onFilesChange((changes, event, cause) => {\n        const actionableChange = changes.some(\n          filename =>\n            util.isCompilableExtension(filename, cliOptions.extensions) ||\n            filenames.includes(filename),\n        );\n        if (!actionableChange) return;\n\n        if (cliOptions.verbose) {\n          console.log(`${event} ${cause}`);\n        }\n\n        walk(filenames).catch(err => {\n          console.error(err);\n        });\n      });\n    }\n  }\n\n  if (cliOptions.filenames.length) {\n    await files(cliOptions.filenames);\n  } else {\n    await stdin();\n  }\n}\n"],"mappings":"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"}