"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _react = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _classnames = _interopRequireDefault(require("classnames"));
var _bind = _interopRequireDefault(require("classnames/bind"));
var _terraThemeContext = _interopRequireDefault(require("terra-theme-context"));
var _terraContentContainer = _interopRequireDefault(require("terra-content-container"));
var _ActionMenuHeader = _interopRequireDefault(require("./_ActionMenuHeader"));
var _ActionUtils = require("./_ActionUtils");
var _ActionMenuModule = _interopRequireDefault(require("./ActionMenu.module.scss"));
var _excluded = ["label", "children", "isHeightBounded", "isHeaderDisplayed", "isWidthBounded", "closeButtonRequired", "onRequestClose"];
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var cx = _bind.default.bind(_ActionMenuModule.default);
var propTypes = {
  /**
   * Label for the ActionMenu.
   */
  label: _propTypes.default.string.isRequired,
  /**
   * The child ActionMenu elements.
   */
  children: _propTypes.default.node,
  /**
   * Whether or not a header should be displayed using the label.
   */
  isHeaderDisplayed: _propTypes.default.bool,
  /**
   * Callback function for close button selection.
   * Returns the event e.g. onClose(event).
   */
  onRequestClose: _propTypes.default.func,
  /**
   * @private
   * Injected Popup prop indicating height bounding
   */
  isHeightBounded: _propTypes.default.bool,
  /**
   * @private
   * Injected Popup prop indicating width bounding
   */
  isWidthBounded: _propTypes.default.bool,
  /**
   * @private
   * Injected Popup prop indicating close button is required
   */
  closeButtonRequired: _propTypes.default.string
};
var ActionMenu = function ActionMenu(_ref) {
  var label = _ref.label,
    children = _ref.children,
    isHeightBounded = _ref.isHeightBounded,
    isHeaderDisplayed = _ref.isHeaderDisplayed,
    isWidthBounded = _ref.isWidthBounded,
    closeButtonRequired = _ref.closeButtonRequired,
    onRequestClose = _ref.onRequestClose,
    customProps = (0, _objectWithoutProperties2.default)(_ref, _excluded);
  var menuRef = (0, _react.useRef)();
  var _flattenActionItems = (0, _ActionUtils.flattenActionItems)(children),
    items = _flattenActionItems.items,
    indentChildren = _flattenActionItems.indentChildren;
  var focusItem = function focusItem(item) {
    if (!item || !menuRef.current) {
      return;
    }
    var element = menuRef.current.querySelector("[data-action-menu-key=\"".concat(item.actionKey, "\"]"));
    if (element) {
      element.focus();
    }
  };
  var onArrow = function onArrow(key, direction) {
    var item = (0, _ActionUtils.itemByDirection)(key, items, direction);
    if (item) {
      focusItem(item);
    }
  };
  var onChar = function onChar(key, char) {
    var item = (0, _ActionUtils.itemByChar)(key, items, char);
    if (item) {
      focusItem(item);
    }
  };
  var theme = _react.default.useContext(_terraThemeContext.default);
  var menuClassNames = (0, _classnames.default)(cx('action-menu', theme.className), customProps.className);
  var content = /*#__PURE__*/_react.default.createElement("ul", (0, _extends2.default)({}, customProps, {
    className: menuClassNames,
    role: "menu",
    tabIndex: "0",
    "aria-label": label,
    ref: menuRef,
    onKeyDown: (0, _ActionUtils.generateOnKeyDown)(null, null, onArrow, onChar)
  }), _react.default.Children.map(children, function (child) {
    if (!child) {
      return undefined;
    }
    return /*#__PURE__*/_react.default.cloneElement(child, {
      onArrow: onArrow,
      onChar: onChar,
      indentChildren: indentChildren
    });
  }));
  if (isHeaderDisplayed) {
    var onClose;
    if (isHeightBounded && isWidthBounded) {
      onClose = onRequestClose;
    }
    content = /*#__PURE__*/_react.default.createElement(_terraContentContainer.default, {
      "aria-label": label,
      tabIndex: "0",
      onKeyDown: (0, _ActionUtils.generateOnKeyDown)(null, null, onArrow, onChar),
      role: "dialog",
      className: cx('action-container'),
      header: /*#__PURE__*/_react.default.createElement(_ActionMenuHeader.default, {
        label: label,
        onClose: onClose
      }),
      fill: isHeightBounded
    }, content);
  }
  return content;
};
ActionMenu.propTypes = propTypes;
var _default = ActionMenu;
exports.default = _default;