"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.itemByDirection = exports.itemByChar = exports.generateOnKeyDown = exports.flattenActionItems = exports.enableFocusStyles = exports.disableFocusStyles = exports.default = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _react = _interopRequireDefault(require("react"));
var _keycodeJs = require("keycode-js");
/**
 * Enables focus styles for the target of the given event. Typically used as an onBlur callback on selectable elements.
 */
var enableFocusStyles = function enableFocusStyles(event) {
  event.currentTarget.setAttribute('data-focus-styles-enabled', 'true');
};

/**
 * Disables focus styles for the target of the given event. Typically used as an onMouseDown callback on selectable elements.
 */
exports.enableFocusStyles = enableFocusStyles;
var disableFocusStyles = function disableFocusStyles(event) {
  event.currentTarget.setAttribute('data-focus-styles-enabled', 'false');
};

/**
 * Validates whether or not the char is acceptable for use in a first char search,
 * @param {string} char The char to validate.
 */
exports.disableFocusStyles = disableFocusStyles;
var isValidChar = function isValidChar(char) {
  return char.length === 1 && char.match(/\S/);
};

/**
 * Returns a function that will execute the provided function upon detection of a KEY_RETURN or KEY_SPACE keydown event.
 * @param {string} key The uniquely identifiable key.
 * @param {Function} onAction The function to be executed after event detection.
 * @param {Function} onArrow The function to be executed after event detection.
 * @param {Function} onChar The function to be executed after event detection.
 */
var generateOnKeyDown = function generateOnKeyDown(key, onAction, onArrow, onChar) {
  return function (event) {
    if (event.altKey || event.ctrlKey || event.metaKey) {
      return;
    }
    var shouldPrevent = false;
    if (event.nativeEvent.keyCode === _keycodeJs.KEY_RETURN || event.nativeEvent.keyCode === _keycodeJs.KEY_SPACE) {
      shouldPrevent = true;
      onAction(key);
    } else if (event.nativeEvent.keyCode === _keycodeJs.KEY_UP || event.nativeEvent.keyCode === _keycodeJs.KEY_LEFT) {
      shouldPrevent = true;
      onArrow(key, 'previous');
    } else if (event.nativeEvent.keyCode === _keycodeJs.KEY_DOWN || event.nativeEvent.keyCode === _keycodeJs.KEY_RIGHT) {
      shouldPrevent = true;
      onArrow(key, 'next');
    } else if (event.nativeEvent.keyCode === _keycodeJs.KEY_HOME) {
      shouldPrevent = true;
      onArrow(key, 'first');
    } else if (event.nativeEvent.keyCode === _keycodeJs.KEY_END) {
      shouldPrevent = true;
      onArrow(key, 'last');
    } else {
      var char = event.key;
      if (isValidChar(char)) {
        shouldPrevent = true;
        onChar(key, char);
      }
    }
    if (shouldPrevent) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
};

/**
 * Returns the items with their first character matching the char parameter.
 * @param {string} char The char to search upon.
 * @param {array} items The flattened array of child items.
 */
exports.generateOnKeyDown = generateOnKeyDown;
var itemsByChar = function itemsByChar(char, items) {
  return items.filter(function (item) {
    return item.label.charAt(0).toLowerCase() === char.toLowerCase();
  });
};

/**
 * Disables focus styles for the target of the given event. Typically used as an onMouseDown callback on selectable elements.
 * @param {string} key The action key to search by.
 * @param {array} items The flattened array of child items.
 */
var indexOfKey = function indexOfKey(key, items) {
  return items.findIndex(function (item) {
    return item.actionKey === key;
  });
};

/**
 * Returns a flattened array of enabled items in the order they are visible.
 * @param {string} key The currently active item key.
 * @param {array} items The flattened array of child items.
 * @param {string} direction The child node to strip the items from.
 */
var itemByDirection = function itemByDirection(key, items, direction) {
  var currentIndex = indexOfKey(key, items);
  var maxIndex = items.length - 1;
  var newIndex;
  if (direction === 'first') {
    newIndex = 0;
  } else if (direction === 'last') {
    newIndex = maxIndex;
  } else if (direction === 'next') {
    if (currentIndex === maxIndex || currentIndex < 0) {
      newIndex = 0;
    } else {
      newIndex = currentIndex + 1;
    }
  } else if (direction === 'previous') {
    if (currentIndex <= 0) {
      newIndex = maxIndex;
    } else {
      newIndex = currentIndex - 1;
    }
  }
  return items[newIndex];
};

/**
 * Returns the next matching item for the char and currently active key.
 * @param {string} key The currently active item key.
 * @param {array} items The flattened array of child items.
 * @param {string} char The current char from keystroke.
 */
exports.itemByDirection = itemByDirection;
var itemByChar = function itemByChar(key, items, char) {
  var charMatches = itemsByChar(char, items);
  var matchCount = charMatches.length;
  if (!matchCount) {
    return undefined;
  }
  var newIndex = 0;
  var currentIndex = indexOfKey(key, charMatches);
  if (matchCount > 1 && currentIndex >= 0 && currentIndex < matchCount - 1) {
    newIndex = currentIndex + 1;
  }
  return charMatches[newIndex];
};

/**
 * Returns a flattened array of enabled items in the order they are visible.
 * @param {node} children The child node to strip the items from.
 * @param {bool} showSelection Flag indicating whether selection is shown for these action items.
 */
exports.itemByChar = itemByChar;
var flattenActionItems = function flattenActionItems(children) {
  var showSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var tempSelection = showSelection;
  var actionItems = [];
  _react.default.Children.forEach(children, function (child) {
    if (!child) {
      return;
    }
    if (child.props.actionKey) {
      if (child.type.interactiveType) {
        tempSelection = true;
      }
      if (!child.props.isDisabled) {
        actionItems.push({
          actionKey: child.props.actionKey,
          label: child.props.label
        });
      }
    } else if (child.props.children) {
      var _flattenActionItems = flattenActionItems(child.props.children, tempSelection),
        items = _flattenActionItems.items,
        indentChildren = _flattenActionItems.indentChildren;
      actionItems.push.apply(actionItems, (0, _toConsumableArray2.default)(items));
      tempSelection = indentChildren || tempSelection;
    }
  });
  return {
    items: actionItems,
    indentChildren: tempSelection
  };
};
exports.flattenActionItems = flattenActionItems;
var _default = {
  enableFocusStyles: enableFocusStyles,
  disableFocusStyles: disableFocusStyles,
  generateOnKeyDown: generateOnKeyDown,
  itemByDirection: itemByDirection,
  itemByChar: itemByChar,
  flattenActionItems: flattenActionItems
};
exports.default = _default;