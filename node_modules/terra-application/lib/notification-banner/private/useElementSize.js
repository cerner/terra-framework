"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.breakpointFilter = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireDefault(require("react"));
var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));
var _breakpoints = require("../../breakpoints");
/**
 * Takes the given rect value and translates it into the shape desired by the useElementSize hook.
 * @param {Object} rect - A rect object, like the one returned by getBoundingClientRect().
 * @returns {Object} A value containing height, width, and active breakpoint values.
 */
var processRect = function processRect(rect) {
  var width = rect.width,
    height = rect.height;
  var activeBreakpoint = (0, _breakpoints.activeBreakpointForSize)(width);
  return {
    activeBreakpoint: activeBreakpoint,
    width: width,
    height: height
  };
};

/**
 * A custom hook used to detect and report changes to the size of a desired element.
 * @param {Object} elementRef A React ref object bound to the element to test for size changes.
 * @param {Function} updateFilter An optional filter that can be used to limit the updates triggered by the hook.
 * This function must be static, as it is cached upon initial execution and not updated. This function is also
 * executed frequently, once every resize tick, so try to minimize complexity. Return true from the filter
 * if a state update is desired. Ex. filter(newRect, oldRect);
 */
var useElementSize = function useElementSize(elementRef, updateFilter) {
  // Filter is cached to limit rebinding of the resize observer.
  // The provided function should be static anyway.
  var cachedUpdateFilterRef = _react.default.useRef(updateFilter);

  // An active animation frame id is stored in this ref so it can be cancelled, if necessary.
  var animationFrameRef = _react.default.useRef();

  // The last-returned rect value is stored in this ref so that comparisons can be made against
  // it without reading the state value in the layout effect and re-binding the resize observer.
  var reportedRectRef = _react.default.useRef();

  // The rect stored in this state is returned to the consuming component.
  var _React$useState = _react.default.useState({}),
    _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
    elementRect = _React$useState2[0],
    setElementRect = _React$useState2[1];
  _react.default.useLayoutEffect(function () {
    var element = elementRef.current;
    var resizeObserver = new _resizeObserverPolyfill.default(function (entries) {
      animationFrameRef.current = window.requestAnimationFrame(function () {
        animationFrameRef.current = null;

        // We do not report size changes for elements that have been removed from the DOM.
        // The observer will execute again when the element is added back to the DOM, so we
        // do not have worry about replaying this value later.
        if (!document.contains(entries[0].target)) {
          return;
        }
        var newRect = processRect(entries[0].target.getBoundingClientRect());

        // If the consuming component provides a filter function, we execute it with the current and
        // previous sizes. The state (and thus the consuming component) is only updated if the filter
        // function indicates the update should occur by returning truthy.
        if (!cachedUpdateFilterRef.current || cachedUpdateFilterRef.current(newRect, reportedRectRef.current)) {
          reportedRectRef.current = newRect;
          setElementRect(newRect);
        }
      });
    });
    resizeObserver.observe(elementRef.current);

    // The initial size is kicked off prior to the ResizeObserver initialization.
    // This will get the elements laid out more quickly and correctly.
    var initialRect = processRect(elementRef.current.getBoundingClientRect());
    reportedRectRef.current = initialRect;
    setElementRect(initialRect);
    return function () {
      window.cancelAnimationFrame(animationFrameRef.current);
      resizeObserver.disconnect(element);
    };
  }, [elementRef, cachedUpdateFilterRef]);
  return elementRect;
};

/**
 * A filter function to be used in conjunction with useElementSize.
 * @param {Object} newRect rect object provided by useElementSize representing the most recent determined size.
 * @param {Object} oldRect rect object provided by useElementSize representing the last reported size.
 * @returns Truthy if the activeBreakpoint values in the given rects to not match.
 */
var breakpointFilter = function breakpointFilter(newRect, oldRect) {
  return newRect.activeBreakpoint !== oldRect.activeBreakpoint;
};
exports.breakpointFilter = breakpointFilter;
var _default = useElementSize;
exports.default = _default;