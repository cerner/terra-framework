"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _react = _interopRequireDefault(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _bind = _interopRequireDefault(require("classnames/bind"));
var _classnames = _interopRequireDefault(require("classnames"));
var _reactIntl = require("react-intl");
var _terraButton = _interopRequireDefault(require("terra-button"));
var _terraThemeContext = _interopRequireDefault(require("terra-theme-context"));
var _BannerRegistrationContext = _interopRequireDefault(require("./BannerRegistrationContext"));
var _organizeBannersByPriority = _interopRequireDefault(require("./organizeBannersByPriority"));
var _useForceUpdate = _interopRequireDefault(require("./useForceUpdate"));
var _NotificationBannerView = _interopRequireWildcard(require("./_NotificationBannerView"));
var _useNotificationBannersModule = _interopRequireDefault(require("./useNotificationBanners.module.scss"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var cx = _bind.default.bind(_useNotificationBannersModule.default);

/**
 * Given a NotificationBanner variant, translates the variant into the legacy support banner types.
 * @param {string} variant One of the supported NotificationBanner variants.
 * @returns {string} The legacy banner type corresponding to the variant, or the variant itself if supported.
 */
function getBannerTypeFromVariant(variant) {
  var bannerType;
  switch (variant) {
    case 'hazard-high':
      bannerType = 'alert';
      break;
    case 'hazard-medium':
      bannerType = 'warning';
      break;
    case 'hazard-low':
      bannerType = 'info';
      break;
    default:
      bannerType = variant;
  }
  return bannerType;
}

/**
 * Returns a comparison of two collections of banners, including banners that were added and removed.
 * @param {Array} newBanners An array of banner data representing the current state.
 * @param {Array} oldBanners An array of banner data representing the previous state.
 * @returns {Object} An object containing references to the banners that were added and removed.
 */
function comparedBannerSets(newBanners, oldBanners) {
  var additions = [];
  var deletions = (0, _toConsumableArray2.default)(oldBanners);
  var _loop = function _loop(i, count) {
    if (oldBanners.findIndex(function (oldBanner) {
      return oldBanner.key === newBanners[i].key;
    }) < 0) {
      additions.push(newBanners[i]);
    } else {
      deletions.splice(deletions.findIndex(function (banner) {
        return banner.key === newBanners[i].key;
      }), 1);
    }
  };
  for (var i = 0, count = newBanners.length; i < count; i += 1) {
    _loop(i, count);
  }
  return {
    additions: additions,
    deletions: deletions
  };
}

/**
 * The `useNotificationBanners` Hook manages registering and prioritizing Notification Banners
 * rendered within the Notification Banner Context.
 *
 * Returns:
 *   - NotificationBannerProvider - React Context Provider - Provides the Banner Registration Context to its children.
 *         This allows any NotificationBanner registered beneath it to be displayed in the NotificationBanner's list.
 *   - NotificationBanners - React Component - Renders a list of prioritized notification banners.
 *
 * @returns { NotificationBannerProvider, NotificationBanners }
 */
var useNotificationBanners = function useNotificationBanners() {
  // The registeredBanners ref maintains collection of banner ids and banner props registered to the  NotificationBannerProvider.
  var registeredBanners = _react.default.useRef({});

  // The updateBannerState ref stores the update state function used to manage the banners rendered in the NotificationBanners component.
  // This ties the state updates to the `useNotificationBanners` hook, while allowing the NotificationBanners to be rendered above or below
  // the NotificationBannerProvider.
  var updateBannerState = _react.default.useRef();
  var useNotificationBannerExports = _react.default.useMemo(function () {
    /**
     * Adds the banner ID and props to the collection of registered banners. Once registered,
     * it updates the NotificationBanner's state to render the new Banner.
     *
     * @param {UUID} bannerId - unique ID associated to the banner
     * @param {Object} bannerProps - react props associated to the banner. See ../NotificationBanner's propTypes.
     */
    var registerNotificationBanner = function registerNotificationBanner(bannerId, bannerProps) {
      if (!bannerId) {
        throw new Error('A banner cannot be registered without an identifier.');
      }
      var variant = bannerProps.variant;
      if (!registeredBanners.current[variant]) {
        registeredBanners.current[variant] = {};
      }
      registeredBanners.current[variant][bannerId] = _objectSpread(_objectSpread({}, bannerProps), {}, {
        key: bannerId
      });
      if (updateBannerState.current) {
        updateBannerState.current({
          banners: _objectSpread({}, registeredBanners.current)
        });
      }
    };

    /**
     * Removes the banner ID and props from the collection of registered banners. Once unregistered,
     * it updates the NotificationBanner's state to remove the Banner from the list.
     *
     * @param {UUID} bannerId - unique ID associated to the banner
     * @param {String} bannerVariant - the banner variant to remove banner from
     */
    var unregisterNotificationBanner = function unregisterNotificationBanner(bannerId, bannerVariant) {
      if (!bannerId || !bannerVariant) {
        throw new Error('A banner cannot be unregistered without an identifier or banner variant.');
      }
      if (!registeredBanners.current[bannerVariant] || !registeredBanners.current[bannerVariant][bannerId]) {
        return;
      }
      delete registeredBanners.current[bannerVariant][bannerId];
      if (!registeredBanners.current[bannerVariant].length) {
        delete registeredBanners.current[bannerVariant];
      }
      if (updateBannerState.current) {
        updateBannerState.current({
          banners: _objectSpread({}, registeredBanners.current)
        });
      }
    };

    /**
     * Provides the Banner Registration Context to its children.
     */
    var NotificationBannerProvider = function NotificationBannerProvider(_ref) {
      var children = _ref.children;
      return /*#__PURE__*/_react.default.createElement(_BannerRegistrationContext.default.Provider, {
        value: {
          registerNotificationBanner: registerNotificationBanner,
          unregisterNotificationBanner: unregisterNotificationBanner
        }
      }, children);
    };
    NotificationBannerProvider.propTypes = {
      /**
       * The elements to receive access to the BannerRegistrationContext value.
       */
      children: _propTypes.default.node
    };

    /**
     * Renders a list of prioritized notification banners.
     */
    var NotificationBanners = function NotificationBanners(_ref2) {
      var id = _ref2.id,
        label = _ref2.label,
        activeClassName = _ref2.activeClassName,
        bannerClassName = _ref2.bannerClassName,
        intl = _ref2.intl;
      var theme = _react.default.useContext(_terraThemeContext.default);
      var _React$useState = _react.default.useState({}),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        bannerState = _React$useState2[0],
        setBannerState = _React$useState2[1];

      // The container reference points to the notification region so we
      // can move focus there when necessary.
      var containerRef = _react.default.useRef();

      // We track the last rendered set of banners so that we can determine
      // when banners are added/removed at render time.
      var lastRenderedBannersRef = _react.default.useRef([]);

      // We track the last read removal message to ensure that duplicates are
      // known and updated to work around some VoiceOver issues.
      var lastReadAddedBanner = _react.default.useRef();

      // We track the last read removal message to ensure that duplicates are
      // known and updated to work around some VoiceOver issues.
      var lastReadRemovedBanner = _react.default.useRef();

      // We track identifiers for banners explicitly dismissed by the user
      // so that we can appropriately read the result.
      var dismissalRefs = _react.default.useRef({});
      var forceUpdate = (0, _useForceUpdate.default)();

      // Set the updateBannerState ref to the update state function. This ties the state updates to the `useNotificationBanners` hook,
      // while allowing the NotificationBanners to be rendered above or below the NotificationBannerProvider.
      updateBannerState.current = setBannerState;
      var prioritizedBanners = (0, _organizeBannersByPriority.default)(bannerState.banners, theme.name);
      var renderedBannerComparison = comparedBannerSets(prioritizedBanners, lastRenderedBannersRef.current);
      lastRenderedBannersRef.current = prioritizedBanners;
      _react.default.useEffect(function () {
        if (renderedBannerComparison.deletions.length || renderedBannerComparison.additions.length) {
          // An update is triggered in a few seconds to clear out the screen reader labels
          // for the additions/deletions. Those labels should not be found after the fact.
          var timeout = setTimeout(function () {
            forceUpdate();
          }, 3000);
          return function () {
            clearTimeout(timeout);
          };
        }
        return undefined;
      }, [renderedBannerComparison, forceUpdate]);
      var addedBannersLog;
      if (renderedBannerComparison.additions.length) {
        addedBannersLog = renderedBannerComparison.additions.map(function (addedBanner) {
          var _addedBanner$bannerAc;
          var translatedBannerType = (0, _NotificationBannerView.getTitleStringIdForType)(getBannerTypeFromVariant(addedBanner.variant));
          if (translatedBannerType) {
            translatedBannerType = intl.formatMessage({
              id: translatedBannerType
            });
          }
          return intl.formatMessage({
            id: 'terraApplication.notifications.newNotificationLabel'
          }, {
            label: label,
            bannerType: translatedBannerType,
            bannerDescription: addedBanner.description,
            bannerAction: addedBanner !== null && addedBanner !== void 0 && (_addedBanner$bannerAc = addedBanner.bannerAction) !== null && _addedBanner$bannerAc !== void 0 && _addedBanner$bannerAc.text ? addedBanner.bannerAction.text : '',
            bannerDismiss: addedBanner.onRequestClose ? intl.formatMessage({
              id: 'terraApplication.notificationBanner.dismiss'
            }) : ''
          });
        }).join(' ');
        if (addedBannersLog.length) {
          addedBannersLog += " ".concat(intl.formatMessage({
            id: 'terraApplication.notifications.totalCountLabel'
          }, {
            label: label,
            count: prioritizedBanners.length
          }));
        }

        // Certain screen readers will not read text in a live region if it has already been read. This can be a problem
        // if the same notification is presented, dismissed, and then presented again. We work around this by appending
        // an invisible, non-breaking space to the string if it is a duplicate in order to force the screen reader
        // to read the string.
        if (lastReadAddedBanner.current === addedBannersLog) {
          addedBannersLog += "\xA0";
        }
        lastReadAddedBanner.current = addedBannersLog;
      }
      var removedBannersLog;
      if (renderedBannerComparison.deletions.length) {
        removedBannersLog = renderedBannerComparison.deletions.map(function (removedBanner) {
          // Only read removed banners if the user explicitly triggered the removal.
          if (!dismissalRefs.current[removedBanner.key]) {
            return '';
          }
          delete dismissalRefs[removedBanner.key];
          var translatedBannerType = (0, _NotificationBannerView.getTitleStringIdForType)(getBannerTypeFromVariant(removedBanner.variant));
          if (translatedBannerType) {
            translatedBannerType = intl.formatMessage({
              id: translatedBannerType
            });
          }
          return intl.formatMessage({
            id: 'terraApplication.notifications.removedNotificationLabel'
          }, {
            label: label,
            bannerType: translatedBannerType,
            bannerDescription: removedBanner.description
          });
        }).join(' ');
        if (removedBannersLog.trim().length) {
          removedBannersLog += " ".concat(intl.formatMessage({
            id: 'terraApplication.notifications.totalCountLabel'
          }, {
            label: label,
            count: prioritizedBanners.length
          }));
        }

        // Certain screen readers will not read text in a live region if it has already been read. This can be a problem,
        // if the same notification is presented, dismissed, and then presented again. We work around this by appending
        // and invisible, non-breaking space to the string, if it is a duplicate, in order to force the screen reader
        // to read the string.
        if (lastReadRemovedBanner.current === removedBannersLog) {
          removedBannersLog += "\xA0";
        }
        lastReadRemovedBanner.current = removedBannersLog;
      }
      var appliedActiveClassName = prioritizedBanners.length && activeClassName ? activeClassName : undefined;
      return /*#__PURE__*/_react.default.createElement("div", {
        role: "region",
        "aria-label": intl.formatMessage({
          id: 'terraApplication.notifications.regionLabel'
        }, {
          label: label
        }),
        id: id,
        className: (0, _classnames.default)(cx('region'), appliedActiveClassName),
        tabIndex: "-1",
        ref: containerRef
      }, /*#__PURE__*/_react.default.createElement("span", {
        className: cx('hidden-log'),
        "aria-live": "polite",
        "aria-atomic": "true",
        "data-testid": "added-banner-log"
      }, /*#__PURE__*/_react.default.createElement("span", null, addedBannersLog)), /*#__PURE__*/_react.default.createElement("span", {
        className: cx('hidden-log'),
        "aria-live": "polite",
        "aria-atomic": "true",
        "data-testid": "removed-banner-log"
      }, /*#__PURE__*/_react.default.createElement("span", null, removedBannersLog)), /*#__PURE__*/_react.default.createElement("ul", {
        className: cx('banners-list'),
        "data-testid": "notification-banners-list"
      }, prioritizedBanners.map(function (bannerProps, index) {
        var bannerAction = bannerProps.bannerAction,
          custom = bannerProps.custom,
          description = bannerProps.description,
          key = bannerProps.key,
          onRequestClose = bannerProps.onRequestClose,
          variant = bannerProps.variant;
        var bannerType = getBannerTypeFromVariant(variant);
        var actionButton = null;
        if (bannerAction) {
          actionButton = /*#__PURE__*/_react.default.createElement(_terraButton.default, {
            text: bannerAction.text,
            variant: "ghost",
            onClick: bannerAction.onClick
          });
        }
        var customIcon;
        var customSignalWord;
        if (bannerType === 'custom' && custom) {
          customSignalWord = custom.signalWord;
          if (custom.customIconClass) {
            customIcon = /*#__PURE__*/_react.default.createElement("svg", {
              className: cx(['custom-icon', custom.customIconClass])
            });
          }
        }
        var translatedBannerLabel = (0, _NotificationBannerView.getTitleStringIdForType)(bannerType);
        if (translatedBannerLabel) {
          translatedBannerLabel = intl.formatMessage({
            id: (0, _NotificationBannerView.getTitleStringIdForType)(bannerType)
          });
        } else if (customSignalWord) {
          translatedBannerLabel = customSignalWord;
        }
        return /*#__PURE__*/_react.default.createElement("li", {
          className: (0, _classnames.default)(cx('banner-list-item', {
            'legacy-banner-style': !bannerClassName
          }), bannerClassName),
          "aria-label": translatedBannerLabel,
          "aria-setsize": prioritizedBanners.length,
          "aria-posinset": index + 1,
          tabIndex: "-1",
          key: key
        }, /*#__PURE__*/_react.default.createElement(_NotificationBannerView.default, {
          key: key,
          action: actionButton,
          onDismiss: onRequestClose ? function () {
            dismissalRefs.current[key] = true;
            containerRef.current.focus();
            onRequestClose();
          } : undefined,
          type: bannerType,
          customIcon: customIcon,
          title: customSignalWord,
          "data-terra-application-notification-banner": variant
        }, description));
      })));
    };
    NotificationBanners.propTypes = {
      /**
       * An identifier for the notifications region, applied as an `id` for the notification container element.
       * Must be globally unique.
       */
      id: _propTypes.default.string,
      /**
       * A description of what the notification banners are related to. Used to provide additional descriptive labeling
       * for screen readers.
       */
      label: _propTypes.default.string,
      /**
       * A className applied to the notifications container when the container is populated with at least one notification banner.
       * Can be used to provide styling only when notification content will be visible.
       */
      activeClassName: _propTypes.default.string,
      /**
       * A className applied to each rendered notification banner.
       */
      bannerClassName: _propTypes.default.string,
      /**
       * @private
       */
      intl: _propTypes.default.shape({
        formatMessage: _propTypes.default.func
      })
    };
    return {
      NotificationBannerProvider: NotificationBannerProvider,
      NotificationBanners: (0, _reactIntl.injectIntl)(NotificationBanners)
    };
  }, []);
  return useNotificationBannerExports;
};
var _default = useNotificationBanners;
exports.default = _default;