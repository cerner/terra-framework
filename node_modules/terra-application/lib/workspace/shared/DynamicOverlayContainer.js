"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireDefault(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _bind = _interopRequireDefault(require("classnames/bind"));
var _DynamicOverlayContainerModule = _interopRequireDefault(require("./DynamicOverlayContainer.module.scss"));
var cx = _bind.default.bind(_DynamicOverlayContainerModule.default);
var propTypes = {
  /**
   * Array of unique overlay objects to render over the child content.
   * Overlays are stacked in index order; the overlay with the highest index
   * will be rendered on top.
   */
  overlays: _propTypes.default.arrayOf(_propTypes.default.shape({
    key: _propTypes.default.string.isRequired,
    component: _propTypes.default.element.isRequired
  })),
  /**
   * The base content to render within the container. This content will
   * be overlaid by all provided overlays.
   */
  children: _propTypes.default.node
};
var defaultProps = {
  overlays: []
};

/* eslint-disable no-param-reassign */
function setLayerInert(inertElement, focusTriggers, focusTriggerKey, focusAnchorElement) {
  if (inertElement.inert) {
    return;
  }
  var _document = document,
    activeElement = _document.activeElement;

  // If the element to be inerted contains or is the current active element,
  // we cache it to be replayed if and when the element reactivates.
  if (inertElement.contains(activeElement) || inertElement === activeElement) {
    focusTriggers[focusTriggerKey] = activeElement;
    focusAnchorElement.focus();
  }
  inertElement.inert = true;
}
function removeLayerInert(inertElement, focusTriggers, focusTriggerKey, focusAnchorElement) {
  if (!inertElement.inert) {
    return;
  }
  var _document2 = document,
    activeElement = _document2.activeElement;
  inertElement.inert = false;

  // If a focus trigger has been cached for this element, and if the element still contains or
  // is the active element, and if the focus has not been placed outside of the container since it was rendered inert,
  // the focus is replayed onto the cached element.
  //
  // Consideration is also made for when focus is on the body element, which can occur if a focused element was rendered
  // within the last removed overlay.
  var cachedActiveElement = focusTriggers[focusTriggerKey];
  if (cachedActiveElement && (inertElement.contains(cachedActiveElement) || inertElement === cachedActiveElement) && (document.body === activeElement || focusAnchorElement === activeElement || focusAnchorElement.contains(activeElement))) {
    cachedActiveElement.focus();
    focusTriggers[focusTriggerKey] = undefined;
  }
}
/* eslint-enable no-param-reassign */

var DynamicOverlayContainer = function DynamicOverlayContainer(_ref) {
  var overlays = _ref.overlays,
    children = _ref.children;
  var contentRef = _react.default.useRef();
  var focusAnchorRef = _react.default.useRef();
  var focusTriggersRef = _react.default.useRef({});

  // The refs for each overlay are kept in a local variable to ensure
  // it expires after each render to ensure that removed overlays do not
  // persist in memory.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  var overlayRefs = [];

  // This effect ensures that the proper layers are rendered
  // as inert prior to painting to the DOM. This effect will execute
  // after every update of the DynamicOverlayContainer; however, the
  // inner inert logic will abort early if the element is already in
  // its assigned state.
  _react.default.useLayoutEffect(function () {
    if (overlays.length !== 0) {
      setLayerInert(contentRef.current, focusTriggersRef.current, '__dynamic-overlay-content__', focusAnchorRef.current);
    } else {
      removeLayerInert(contentRef.current, focusTriggersRef.current, '__dynamic-overlay-content__', focusAnchorRef.current);
    }
    for (var i = 0, count = overlays.length; i < count; i += 1) {
      if (i !== count - 1) {
        setLayerInert(overlayRefs[i].element, focusTriggersRef.current, overlayRefs[i].key, focusAnchorRef.current);
      } else {
        removeLayerInert(overlayRefs[i].element, focusTriggersRef.current, overlayRefs[i].key, focusAnchorRef.current);
      }
    }
  }, [overlayRefs, overlays]);
  return /*#__PURE__*/_react.default.createElement("div", {
    className: cx('outer-container'),
    ref: focusAnchorRef,
    tabIndex: "-1",
    "data-testid": "dynamic-overlay-container"
  }, /*#__PURE__*/_react.default.createElement("div", {
    ref: contentRef,
    className: cx('content-container')
  }, children), overlays.map(function (overlay, index) {
    return /*#__PURE__*/_react.default.createElement("div", {
      key: overlay.key,
      ref: function ref(overlayRef) {
        overlayRefs[index] = {
          key: overlay.key,
          element: overlayRef
        };
      },
      className: cx('overlay-container')
    }, overlay.component);
  }));
};
DynamicOverlayContainer.propTypes = propTypes;
DynamicOverlayContainer.defaultProps = defaultProps;
var _default = DynamicOverlayContainer;
exports.default = _default;