"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// libs/core/src/lib/collect-uncommitted.ts
function collectUncommitted({ cwd, log: log36 = import_npmlog.default }) {
  log36.silly("collect-uncommitted", "git status --porcelain (async)");
  return childProcess.exec("git", ["status", "--porcelain"], { cwd }).then(({ stdout }) => transformOutput(stdout));
}
var import_chalk, import_npmlog, childProcess, maybeColorize, cRed, cGreen, replaceStatus, colorizeStats, splitOnNewLine, filterEmpty, o, transformOutput;
var init_collect_uncommitted = __esm({
  "libs/core/src/lib/collect-uncommitted.ts"() {
    "use strict";
    import_chalk = __toESM(require("chalk"));
    import_npmlog = __toESM(require("npmlog"));
    childProcess = require("@lerna/child-process");
    maybeColorize = (colorize) => (s) => s !== " " ? colorize(s) : s;
    cRed = maybeColorize(import_chalk.default.red);
    cGreen = maybeColorize(import_chalk.default.green);
    replaceStatus = (_, maybeGreen, maybeRed) => `${cGreen(maybeGreen)}${cRed(maybeRed)}`;
    colorizeStats = (stats) => stats.replace(/^([^U]| )([A-Z]| )/gm, replaceStatus).replace(/^\?{2}|U{2}/gm, cRed("$&"));
    splitOnNewLine = (str) => str.split("\n");
    filterEmpty = (lines) => lines.filter((line) => line.length);
    o = (l, r) => (x) => l(r(x));
    transformOutput = o(filterEmpty, o(splitOnNewLine, colorizeStats));
  }
});

// libs/core/src/lib/describe-ref.ts
function getArgs(options, includeMergedTags = false) {
  let args = [
    "describe",
    "--always",
    "--long",
    "--dirty",
    "--first-parent"
  ];
  if (options.match) {
    args.push("--match", options.match);
  }
  if (includeMergedTags) {
    args = args.filter((arg) => arg !== "--first-parent");
  }
  return args;
}
function describeRef(options = {}, includeMergedTags) {
  const promise = childProcess2.exec("git", getArgs(options, includeMergedTags), options);
  return promise.then(({ stdout }) => {
    const result = parse(stdout, options.cwd);
    import_npmlog2.default.verbose("git-describe", "%j => %j", options && options.match, stdout);
    import_npmlog2.default.silly("git-describe", "parsed => %j", result);
    return result;
  });
}
function describeRefSync(options = {}, includeMergedTags) {
  const stdout = childProcess2.execSync("git", getArgs(options, includeMergedTags), options);
  const result = parse(stdout, options.cwd);
  import_npmlog2.default.silly("git-describe.sync", "%j => %j", stdout, result);
  return result;
}
function parse(stdout, cwd) {
  const minimalShaRegex = /^([0-9a-f]{7,40})(-dirty)?$/;
  if (minimalShaRegex.test(stdout)) {
    const [, sha2, isDirty2] = minimalShaRegex.exec(stdout);
    const refCount2 = childProcess2.execSync("git", ["rev-list", "--count", sha2], { cwd });
    return { refCount: refCount2, sha: sha2, isDirty: Boolean(isDirty2) };
  }
  const [, lastTagName, lastVersion, refCount, sha, isDirty] = /^((?:.*@)?(.*))-(\d+)-g([0-9a-f]+)(-dirty)?$/.exec(stdout) || [];
  return { lastTagName, lastVersion, refCount, sha, isDirty: Boolean(isDirty) };
}
var import_npmlog2, childProcess2;
var init_describe_ref = __esm({
  "libs/core/src/lib/describe-ref.ts"() {
    "use strict";
    import_npmlog2 = __toESM(require("npmlog"));
    childProcess2 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/validation-error.ts
var import_npmlog3, ValidationError;
var init_validation_error = __esm({
  "libs/core/src/lib/validation-error.ts"() {
    "use strict";
    import_npmlog3 = __toESM(require("npmlog"));
    ValidationError = class extends Error {
      prefix;
      constructor(prefix, message, ...rest) {
        super(message);
        this.name = "ValidationError";
        this.prefix = prefix;
        import_npmlog3.default.resume();
        import_npmlog3.default.error(prefix, message, ...rest);
      }
    };
  }
});

// libs/core/src/lib/check-working-tree.ts
function checkWorkingTree({ cwd } = {}) {
  let chain = Promise.resolve();
  chain = chain.then(() => describeRef({ cwd }));
  const tests = [
    chain.then(throwIfReleased),
    chain.then(mkThrowIfUncommitted({ cwd }))
  ];
  return chain.then((result) => Promise.all(tests).then(() => result));
}
function throwIfReleased({ refCount }) {
  if (refCount === "0") {
    throw new ValidationError(
      "ERELEASED",
      "The current commit has already been released. Please make new commits before continuing."
    );
  }
}
function mkThrowIfUncommitted(options = {}) {
  return function throwIfUncommitted2({ isDirty }) {
    if (isDirty) {
      return collectUncommitted(options).then((uncommitted) => {
        throw new ValidationError("EUNCOMMIT", `${EUNCOMMIT_MSG}${uncommitted.join("\n")}`);
      });
    }
  };
}
var EUNCOMMIT_MSG, throwIfUncommitted;
var init_check_working_tree = __esm({
  "libs/core/src/lib/check-working-tree.ts"() {
    "use strict";
    init_collect_uncommitted();
    init_describe_ref();
    init_validation_error();
    EUNCOMMIT_MSG = "Working tree has uncommitted changes, please commit or remove the following changes before continuing:\n";
    throwIfUncommitted = mkThrowIfUncommitted();
  }
});

// libs/core/src/lib/cli.ts
var import_dedent, import_npmlog4, import_yargs;
var init_cli = __esm({
  "libs/core/src/lib/cli.ts"() {
    "use strict";
    import_dedent = __toESM(require("dedent"));
    import_npmlog4 = __toESM(require("npmlog"));
    import_yargs = __toESM(require("yargs/yargs"));
  }
});

// libs/core/src/lib/collect-updates/collect-dependents.ts
function collectDependents(nodes) {
  const collected = /* @__PURE__ */ new Set();
  nodes.forEach((currentNode) => {
    if (currentNode.localDependents.size === 0) {
      return;
    }
    const queue2 = [currentNode];
    const seen = /* @__PURE__ */ new Set();
    const visit = (dependentNode, dependentName, siblingDependents) => {
      if (seen.has(dependentNode)) {
        return;
      }
      seen.add(dependentNode);
      if (dependentNode === currentNode || siblingDependents.has(currentNode.name)) {
        return;
      }
      collected.add(dependentNode);
      queue2.push(dependentNode);
    };
    while (queue2.length) {
      const node = queue2.shift();
      node.localDependents.forEach(visit);
    }
  });
  return collected;
}
var init_collect_dependents = __esm({
  "libs/core/src/lib/collect-updates/collect-dependents.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/collect-updates/collect-packages.ts
function collectPackages(packages, { isCandidate = () => true, onInclude, excludeDependents } = {}) {
  const candidates = /* @__PURE__ */ new Set();
  packages.forEach((node, name) => {
    if (isCandidate(node, name)) {
      candidates.add(node);
    }
  });
  if (!excludeDependents) {
    collectDependents(candidates).forEach((node) => candidates.add(node));
  }
  const updates = [];
  packages.forEach((node, name) => {
    if (candidates.has(node)) {
      if (onInclude) {
        onInclude(name);
      }
      updates.push(node);
    }
  });
  return updates;
}
var init_collect_packages = __esm({
  "libs/core/src/lib/collect-updates/collect-packages.ts"() {
    "use strict";
    init_collect_dependents();
  }
});

// libs/core/src/lib/collect-updates/get-packages-for-option.ts
function getPackagesForOption(option) {
  let inputs = null;
  if (option === true) {
    inputs = ["*"];
  } else if (typeof option === "string") {
    inputs = option.split(",");
  } else if (Array.isArray(option)) {
    inputs = [...option];
  }
  return new Set(inputs);
}
var init_get_packages_for_option = __esm({
  "libs/core/src/lib/collect-updates/get-packages-for-option.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/collect-updates/has-tags.ts
function hasTags(opts) {
  import_npmlog5.default.silly("hasTags");
  let result = false;
  try {
    result = !!childProcess3.execSync("git", ["tag"], opts);
  } catch (err) {
    import_npmlog5.default.warn("ENOTAGS", "No git tags were reachable from this branch!");
    import_npmlog5.default.verbose("hasTags error", err);
  }
  import_npmlog5.default.verbose("hasTags", result);
  return result;
}
var import_npmlog5, childProcess3;
var init_has_tags = __esm({
  "libs/core/src/lib/collect-updates/has-tags.ts"() {
    "use strict";
    import_npmlog5 = __toESM(require("npmlog"));
    childProcess3 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/collect-updates/make-diff-predicate.ts
function makeDiffPredicate(committish, execOpts, ignorePatterns = []) {
  const ignoreFilters = new Set(
    ignorePatterns.map(
      (p) => import_minimatch.default.filter(`!${p}`, {
        matchBase: true,
        dot: true
      })
    )
  );
  if (ignoreFilters.size) {
    import_npmlog6.default.info("ignoring diff in paths matching", ignorePatterns);
  }
  return function hasDiffSinceThatIsntIgnored(node) {
    const diff = diffSinceIn(committish, node.location, execOpts);
    if (diff === "") {
      import_npmlog6.default.silly("", "no diff found in %s", node.name);
      return false;
    }
    import_npmlog6.default.silly("found diff in", diff);
    let changedFiles = diff.split("\n");
    if (ignoreFilters.size) {
      for (const ignored of ignoreFilters) {
        changedFiles = changedFiles.filter(ignored);
      }
    }
    if (changedFiles.length) {
      import_npmlog6.default.verbose("filtered diff", changedFiles);
    } else {
      import_npmlog6.default.verbose("", "no diff found in %s (after filtering)", node.name);
    }
    return changedFiles.length > 0;
  };
}
function diffSinceIn(committish, location, opts) {
  const args = ["diff", "--name-only", committish];
  const formattedLocation = (0, import_slash.default)(import_path.default.relative(opts.cwd, location));
  if (formattedLocation) {
    args.push("--", formattedLocation);
  }
  import_npmlog6.default.silly("checking diff", formattedLocation);
  return childProcess4.execSync("git", args, opts);
}
var import_npmlog6, import_minimatch, import_path, import_slash, childProcess4;
var init_make_diff_predicate = __esm({
  "libs/core/src/lib/collect-updates/make-diff-predicate.ts"() {
    "use strict";
    import_npmlog6 = __toESM(require("npmlog"));
    import_minimatch = __toESM(require("minimatch"));
    import_path = __toESM(require("path"));
    import_slash = __toESM(require("slash"));
    childProcess4 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/collect-updates/index.ts
function collectUpdates(filteredPackages, packageGraph, execOpts, commandOptions) {
  const { forcePublish, conventionalCommits, conventionalGraduate, excludeDependents } = commandOptions;
  const useConventionalGraduate = conventionalCommits && conventionalGraduate;
  const forced = getPackagesForOption(useConventionalGraduate ? conventionalGraduate : forcePublish);
  const packages = filteredPackages.length === packageGraph.size ? packageGraph : new Map(filteredPackages.map(({ name }) => [name, packageGraph.get(name)]));
  let committish = commandOptions.since;
  if (hasTags(execOpts)) {
    const { sha, refCount, lastTagName } = describeRefSync(execOpts, commandOptions.includeMergedTags);
    if (refCount === "0" && forced.size === 0 && !committish) {
      import_npmlog7.default.notice("", "Current HEAD is already released, skipping change detection.");
      return [];
    }
    if (commandOptions.canary) {
      committish = `${sha}^..${sha}`;
    } else if (!committish) {
      committish = lastTagName;
    }
  }
  if (forced.size) {
    import_npmlog7.default.warn(
      useConventionalGraduate ? "conventional-graduate" : "force-publish",
      forced.has("*") ? "all packages" : Array.from(forced.values()).join("\n")
    );
  }
  if (useConventionalGraduate) {
    if (forced.has("*")) {
      import_npmlog7.default.info("", "Graduating all prereleased packages");
    } else {
      import_npmlog7.default.info("", "Graduating prereleased packages");
    }
  } else if (!committish || forced.has("*")) {
    import_npmlog7.default.info("", "Assuming all packages changed");
    return collectPackages(packages, {
      onInclude: (name) => import_npmlog7.default.verbose("updated", name),
      excludeDependents
    });
  }
  import_npmlog7.default.info("", `Looking for changed packages since ${committish}`);
  const hasDiff = makeDiffPredicate(committish, execOpts, commandOptions.ignoreChanges);
  const needsBump = !commandOptions.bump || commandOptions.bump.startsWith("pre") ? () => false : (node) => node.prereleaseId;
  const isForced = (node, name) => (forced.has("*") || forced.has(name)) && (useConventionalGraduate ? node.prereleaseId : true);
  return collectPackages(packages, {
    isCandidate: (node, name) => isForced(node, name) || needsBump(node) || hasDiff(node),
    onInclude: (name) => import_npmlog7.default.verbose("updated", name),
    excludeDependents
  });
}
var import_npmlog7;
var init_collect_updates = __esm({
  "libs/core/src/lib/collect-updates/index.ts"() {
    "use strict";
    import_npmlog7 = __toESM(require("npmlog"));
    init_describe_ref();
    init_collect_packages();
    init_get_packages_for_option();
    init_has_tags();
    init_make_diff_predicate();
  }
});

// libs/core/src/lib/package-graph/cyclic-package-graph-node.ts
var lastCollapsedNodeId, CyclicPackageGraphNode;
var init_cyclic_package_graph_node = __esm({
  "libs/core/src/lib/package-graph/cyclic-package-graph-node.ts"() {
    "use strict";
    lastCollapsedNodeId = 0;
    CyclicPackageGraphNode = class extends Map {
      name;
      localDependencies;
      localDependents;
      constructor() {
        super();
        this.name = `(cycle) ${lastCollapsedNodeId += 1}`;
        this.localDependencies = /* @__PURE__ */ new Map();
        this.localDependents = /* @__PURE__ */ new Map();
      }
      get isCycle() {
        return true;
      }
      toString() {
        const parts = Array.from(
          this,
          ([key, node]) => node.isCycle ? `(nested cycle: ${node.toString()})` : key
        );
        parts.push(parts[0]);
        return parts.reverse().join(" -> ");
      }
      flatten() {
        const result = [];
        for (const node of this.values()) {
          if (node.isCycle) {
            result.push(...node.flatten());
          } else {
            result.push(node);
          }
        }
        return result;
      }
      contains(name) {
        for (const [currentName, currentNode] of this) {
          if (currentNode.isCycle) {
            if (currentNode.contains(name)) {
              return true;
            }
          } else if (currentName === name) {
            return true;
          }
        }
        return false;
      }
      insert(node) {
        this.set(node.name, node);
        this.unlink(node);
        for (const [dependencyName, dependencyNode] of node.localDependencies) {
          if (!this.contains(dependencyName)) {
            this.localDependencies.set(dependencyName, dependencyNode);
          }
        }
        for (const [dependentName, dependentNode] of node.localDependents) {
          if (!this.contains(dependentName)) {
            this.localDependents.set(dependentName, dependentNode);
          }
        }
      }
      unlink(candidateNode) {
        this.localDependencies.delete(candidateNode.name);
        this.localDependents.delete(candidateNode.name);
      }
    };
  }
});

// libs/core/src/lib/prerelease-id-from-version.ts
function prereleaseIdFromVersion(version) {
  return (import_semver.default.prerelease(version) || []).shift();
}
var import_semver;
var init_prerelease_id_from_version = __esm({
  "libs/core/src/lib/prerelease-id-from-version.ts"() {
    "use strict";
    import_semver = __toESM(require("semver"));
  }
});

// libs/core/src/lib/package-graph/package-graph-node.ts
var import_semver2, PKG, PackageGraphNode;
var init_package_graph_node = __esm({
  "libs/core/src/lib/package-graph/package-graph-node.ts"() {
    "use strict";
    import_semver2 = __toESM(require("semver"));
    init_prerelease_id_from_version();
    PKG = Symbol("pkg");
    PackageGraphNode = class {
      name;
      externalDependencies;
      localDependencies;
      localDependents;
      [PKG];
      constructor(pkg) {
        this.name = pkg.name;
        this[PKG] = pkg;
        Object.defineProperty(this, PKG, { enumerable: false });
        this.externalDependencies = /* @__PURE__ */ new Map();
        this.localDependencies = /* @__PURE__ */ new Map();
        this.localDependents = /* @__PURE__ */ new Map();
      }
      get location() {
        return this[PKG].location;
      }
      get pkg() {
        return this[PKG];
      }
      get prereleaseId() {
        return prereleaseIdFromVersion(this.version);
      }
      get version() {
        return this[PKG].version;
      }
      satisfies({ gitCommittish, gitRange, fetchSpec }) {
        return import_semver2.default.satisfies(this.version, gitCommittish || gitRange || fetchSpec);
      }
      toString() {
        return this.name;
      }
    };
  }
});

// libs/core/src/lib/package-graph/report-cycles.ts
function reportCycles(paths, rejectCycles) {
  if (!paths.length) {
    return;
  }
  const cycleMessage = ["Dependency cycles detected, you should fix these!"].concat(paths).join("\n");
  if (rejectCycles) {
    throw new ValidationError("ECYCLE", cycleMessage);
  }
  import_npmlog8.default.warn("ECYCLE", cycleMessage);
}
var import_npmlog8;
var init_report_cycles = __esm({
  "libs/core/src/lib/package-graph/report-cycles.ts"() {
    "use strict";
    import_npmlog8 = __toESM(require("npmlog"));
    init_validation_error();
  }
});

// libs/core/src/lib/package-graph/index.ts
var import_npm_package_arg, PackageGraph;
var init_package_graph = __esm({
  "libs/core/src/lib/package-graph/index.ts"() {
    "use strict";
    import_npm_package_arg = __toESM(require("npm-package-arg"));
    init_validation_error();
    init_cyclic_package_graph_node();
    init_package_graph_node();
    init_report_cycles();
    PackageGraph = class extends Map {
      constructor(packages, graphType = "allDependencies", forceLocal) {
        super(packages.map((pkg) => [pkg.name, new PackageGraphNode(pkg)]));
        if (packages.length !== this.size) {
          const seen = /* @__PURE__ */ new Map();
          for (const { name, location } of packages) {
            if (seen.has(name)) {
              seen.get(name).push(location);
            } else {
              seen.set(name, [location]);
            }
          }
          for (const [name, locations] of seen) {
            if (locations.length > 1) {
              throw new ValidationError(
                "ENAME",
                [`Package name "${name}" used in multiple packages:`, ...locations].join("\n	")
              );
            }
          }
        }
        this.forEach((currentNode, currentName) => {
          const graphDependencies = graphType === "dependencies" ? Object.assign({}, currentNode.pkg.optionalDependencies, currentNode.pkg.dependencies) : Object.assign(
            {},
            currentNode.pkg.devDependencies,
            currentNode.pkg.optionalDependencies,
            currentNode.pkg.dependencies
          );
          Object.keys(graphDependencies).forEach((depName) => {
            const depNode = this.get(depName);
            let spec = graphDependencies[depName].replace(/^link:/, "file:");
            const isWorkspaceSpec = /^workspace:/.test(spec);
            let fullWorkspaceSpec;
            let workspaceAlias;
            if (isWorkspaceSpec) {
              fullWorkspaceSpec = spec;
              spec = spec.replace(/^workspace:/, "");
              if (spec === "*" || spec === "^" || spec === "~") {
                workspaceAlias = spec;
                if (depNode?.version) {
                  const prefix = spec === "*" ? "" : spec;
                  const version = depNode.version;
                  spec = `${prefix}${version}`;
                } else {
                  spec = "*";
                }
              }
            }
            const resolved = import_npm_package_arg.default.resolve(depName, spec, currentNode.location);
            resolved.workspaceSpec = fullWorkspaceSpec;
            resolved.workspaceAlias = workspaceAlias;
            if (!depNode) {
              return currentNode.externalDependencies.set(depName, resolved);
            }
            if (forceLocal || resolved.fetchSpec === depNode.location || depNode.satisfies(resolved)) {
              currentNode.localDependencies.set(depName, resolved);
              depNode.localDependents.set(currentName, currentNode);
            } else {
              if (isWorkspaceSpec) {
                throw new ValidationError(
                  "EWORKSPACE",
                  `Package specification "${depName}@${spec}" could not be resolved within the workspace. To reference a non-matching, remote version of a local dependency, remove the 'workspace:' prefix.`
                );
              }
              currentNode.externalDependencies.set(depName, resolved);
            }
          });
        });
      }
      get rawPackageList() {
        return Array.from(this.values()).map((node) => node.pkg);
      }
      addDependencies(filteredPackages) {
        return this.extendList(filteredPackages, "localDependencies");
      }
      addDependents(filteredPackages) {
        return this.extendList(filteredPackages, "localDependents");
      }
      extendList(packageList, nodeProp) {
        const search = new Set(packageList.map(({ name }) => this.get(name)));
        const result = [];
        search.forEach((currentNode) => {
          result.push(currentNode);
          currentNode[nodeProp].forEach((meta, depName) => {
            const depNode = this.get(depName);
            if (depNode !== currentNode && !search.has(depNode)) {
              search.add(depNode);
            }
          });
        });
        return result.map((node) => node.pkg);
      }
      partitionCycles(rejectCycles) {
        const cyclePaths = /* @__PURE__ */ new Set();
        const cycleNodes = /* @__PURE__ */ new Set();
        this.forEach((currentNode, currentName) => {
          const seen = /* @__PURE__ */ new Set();
          const visits = (walk) => (dependentNode, dependentName, siblingDependents) => {
            const step = walk.concat(dependentName);
            if (seen.has(dependentNode)) {
              return;
            }
            seen.add(dependentNode);
            if (dependentNode === currentNode) {
              cycleNodes.add(currentNode);
              cyclePaths.add(step);
              return;
            }
            if (siblingDependents.has(currentName)) {
              const cycleDependentName = Array.from(dependentNode.localDependencies.keys()).find(
                (key) => currentNode.localDependents.has(key)
              );
              const pathToCycle = step.slice().reverse().concat(cycleDependentName);
              cycleNodes.add(dependentNode);
              cyclePaths.add(pathToCycle);
            }
            dependentNode.localDependents.forEach(visits(step));
          };
          currentNode.localDependents.forEach(visits([currentName]));
        });
        reportCycles(
          Array.from(cyclePaths, (cycle) => cycle.join(" -> ")),
          rejectCycles
        );
        return [cyclePaths, cycleNodes];
      }
      collapseCycles(rejectCycles) {
        const cyclePaths = [];
        const nodeToCycle = /* @__PURE__ */ new Map();
        const cycles = /* @__PURE__ */ new Set();
        const walkStack = [];
        const alreadyVisited = /* @__PURE__ */ new Set();
        function visits(baseNode, dependentNode) {
          if (nodeToCycle.has(baseNode)) {
            return;
          }
          let topLevelDependent = dependentNode;
          while (nodeToCycle.has(topLevelDependent)) {
            topLevelDependent = nodeToCycle.get(topLevelDependent);
          }
          const identifier = `${baseNode.name}:${topLevelDependent.name}`;
          if (alreadyVisited.has(identifier)) {
            return;
          }
          alreadyVisited.add(identifier);
          if (topLevelDependent === baseNode || topLevelDependent.isCycle && topLevelDependent.has(baseNode.name)) {
            const cycle = new CyclicPackageGraphNode();
            walkStack.forEach((nodeInCycle) => {
              nodeToCycle.set(nodeInCycle, cycle);
              cycle.insert(nodeInCycle);
              cycles.delete(nodeInCycle);
            });
            cycles.add(cycle);
            cyclePaths.push(cycle.toString());
            return;
          }
          if (walkStack.indexOf(topLevelDependent) === -1) {
            visitWithStack(baseNode, topLevelDependent);
          }
        }
        function visitWithStack(baseNode, currentNode = baseNode) {
          walkStack.push(currentNode);
          currentNode.localDependents.forEach(visits.bind(null, baseNode));
          walkStack.pop();
        }
        this.forEach((currentNode) => visitWithStack(currentNode));
        cycles.forEach((collapsedNode) => visitWithStack(collapsedNode));
        reportCycles(cyclePaths, rejectCycles);
        return cycles;
      }
      pruneCycleNodes(cycleNodes) {
        return this.prune(...cycleNodes);
      }
      prune(...candidates) {
        if (candidates.length === this.size) {
          return this.clear();
        }
        candidates.forEach((node) => this.remove(node));
      }
      remove(candidateNode) {
        this.delete(candidateNode.name);
        this.forEach((node) => {
          node.localDependencies.delete(candidateNode.name);
          node.localDependents.delete(candidateNode.name);
        });
      }
    };
  }
});

// libs/core/src/lib/package.ts
function binSafeName({ name, scope }) {
  return scope ? name.substring(scope.length + 1) : name;
}
function shallowCopy(json) {
  return Object.keys(json).reduce((obj, key) => {
    const val = json[key];
    if (Array.isArray(val)) {
      obj[key] = val.slice();
    } else if (val && typeof val === "object") {
      obj[key] = Object.assign({}, val);
    } else {
      obj[key] = val;
    }
    return obj;
  }, {});
}
var import_load_json_file, import_npm_package_arg2, import_path2, import_write_pkg, PKG2, _location, _resolved, _rootPath, _scripts, _contents, Package;
var init_package = __esm({
  "libs/core/src/lib/package.ts"() {
    "use strict";
    import_load_json_file = __toESM(require("load-json-file"));
    import_npm_package_arg2 = __toESM(require("npm-package-arg"));
    import_path2 = __toESM(require("path"));
    import_write_pkg = __toESM(require("write-pkg"));
    PKG2 = Symbol("pkg");
    _location = Symbol("location");
    _resolved = Symbol("resolved");
    _rootPath = Symbol("rootPath");
    _scripts = Symbol("scripts");
    _contents = Symbol("contents");
    Package = class {
      name;
      [PKG2];
      [_location];
      [_resolved];
      [_rootPath];
      [_scripts];
      [_contents];
      static lazy(ref, dir = ".") {
        if (typeof ref === "string") {
          const location = import_path2.default.resolve(import_path2.default.basename(ref) === "package.json" ? import_path2.default.dirname(ref) : ref);
          const manifest = import_load_json_file.default.sync(import_path2.default.join(location, "package.json"));
          return new Package(manifest, location);
        }
        if ("__isLernaPackage" in ref) {
          return ref;
        }
        return new Package(ref, dir);
      }
      constructor(pkg, location, rootPath = location) {
        const resolved = import_npm_package_arg2.default.resolve(pkg.name, `file:${import_path2.default.relative(rootPath, location)}`, rootPath);
        this.name = pkg.name;
        this[PKG2] = pkg;
        Object.defineProperty(this, PKG2, { enumerable: false, writable: true });
        this[_location] = location;
        this[_resolved] = resolved;
        this[_rootPath] = rootPath;
        this[_scripts] = { ...pkg.scripts };
      }
      get location() {
        return this[_location];
      }
      get private() {
        return Boolean(this[PKG2].private);
      }
      set private(isPrivate) {
        this[PKG2].private = isPrivate;
      }
      get resolved() {
        return this[_resolved];
      }
      get rootPath() {
        return this[_rootPath];
      }
      get scripts() {
        return this[_scripts];
      }
      get bin() {
        const pkg = this[PKG2];
        return typeof pkg.bin === "string" ? {
          [binSafeName(this.resolved)]: pkg.bin
        } : Object.assign({}, pkg.bin);
      }
      get binLocation() {
        return import_path2.default.join(this.location, "node_modules", ".bin");
      }
      get manifestLocation() {
        return import_path2.default.join(this.location, "package.json");
      }
      get nodeModulesLocation() {
        return import_path2.default.join(this.location, "node_modules");
      }
      get __isLernaPackage() {
        return true;
      }
      get version() {
        return this[PKG2].version;
      }
      set version(version) {
        this[PKG2].version = version;
      }
      get contents() {
        if (this[_contents]) {
          return this[_contents];
        }
        if (this[PKG2].publishConfig && this[PKG2].publishConfig.directory) {
          return import_path2.default.join(this.location, this[PKG2].publishConfig.directory);
        }
        return this.location;
      }
      set contents(subDirectory) {
        this[_contents] = import_path2.default.join(this.location, subDirectory);
      }
      get dependencies() {
        return this[PKG2].dependencies;
      }
      get devDependencies() {
        return this[PKG2].devDependencies;
      }
      get optionalDependencies() {
        return this[PKG2].optionalDependencies;
      }
      get peerDependencies() {
        return this[PKG2].peerDependencies;
      }
      get(key) {
        return this[PKG2][key];
      }
      set(key, val) {
        this[PKG2][key] = val;
        return this;
      }
      toJSON() {
        return shallowCopy(this[PKG2]);
      }
      refresh() {
        return (0, import_load_json_file.default)(this.manifestLocation).then((pkg) => {
          this[PKG2] = pkg;
          return this;
        });
      }
      serialize() {
        return (0, import_write_pkg.default)(this.manifestLocation, this[PKG2]).then(() => this);
      }
      updateLocalDependency(resolved, depVersion, savePrefix, options = { retainWorkspacePrefix: true }) {
        const depName = resolved.name;
        let depCollection = this.dependencies;
        if (!depCollection || !depCollection[depName]) {
          depCollection = this.optionalDependencies;
        }
        if (!depCollection || !depCollection[depName]) {
          depCollection = this.devDependencies;
        }
        if (resolved.workspaceSpec && options.retainWorkspacePrefix) {
          if (!resolved.workspaceAlias) {
            const workspacePrefix = resolved.workspaceSpec.match(/^(workspace:[*~^]?)/)[0];
            depCollection[depName] = `${workspacePrefix}${depVersion}`;
          }
        } else if (resolved.registry || resolved.type === "directory") {
          depCollection[depName] = `${savePrefix}${depVersion}`;
        } else if (resolved.gitCommittish) {
          const [tagPrefix] = /^\D*/.exec(resolved.gitCommittish);
          const { hosted } = resolved;
          hosted.committish = `${tagPrefix}${depVersion}`;
          depCollection[depName] = hosted.toString({ noGitPlus: false, noCommittish: false });
        } else if (resolved.gitRange) {
          const { hosted } = resolved;
          hosted.committish = `semver:${savePrefix}${depVersion}`;
          depCollection[depName] = hosted.toString({ noGitPlus: false, noCommittish: false });
        }
      }
      removePrivate() {
        delete this[PKG2].private;
      }
    };
  }
});

// libs/core/src/lib/project/deprecate-config.ts
function remap(search, target, { alsoRoot, toValue } = {}) {
  const pathsToSearch = [search];
  if (alsoRoot) {
    pathsToSearch.unshift(search.split(".").pop());
  }
  return (obj) => {
    for (const searchPath of pathsToSearch) {
      if (import_dot_prop.default.has(obj.config, searchPath)) {
        const fromVal = import_dot_prop.default.get(obj.config, searchPath);
        const toVal = toValue ? toValue(fromVal) : fromVal;
        import_npmlog9.default.warn("project", deprecationMessage(obj, target, searchPath, fromVal, toVal));
        import_dot_prop.default.set(obj.config, target, toVal);
        import_dot_prop.default.delete(obj.config, searchPath);
      }
    }
    return obj;
  };
}
function deprecationMessage(obj, target, searchPath, fromVal, toVal) {
  const localPath = import_path3.default.relative(".", obj.filepath);
  let from;
  let to;
  if (toVal === fromVal) {
    from = `"${searchPath}"`;
    to = `"${target}"`;
  } else {
    from = stringify({ [searchPath]: fromVal });
    to = stringify({ [target]: toVal });
  }
  return `Deprecated key "${searchPath}" found in ${localPath}
Please update ${from} => ${to}`;
}
function stringify(obj) {
  return JSON.stringify(obj).slice(1, -1);
}
function compose(...funcs) {
  return funcs.reduce(
    (a, b) => (...args) => a(b(...args))
  );
}
var import_dot_prop, import_npmlog9, import_path3, deprecateConfig;
var init_deprecate_config = __esm({
  "libs/core/src/lib/project/deprecate-config.ts"() {
    "use strict";
    import_dot_prop = __toESM(require("dot-prop"));
    import_npmlog9 = __toESM(require("npmlog"));
    import_path3 = __toESM(require("path"));
    deprecateConfig = compose(
      remap("command.add.includeFilteredDependencies", "command.add.includeDependencies", { alsoRoot: true }),
      remap("command.add.includeFilteredDependents", "command.add.includeDependents", { alsoRoot: true }),
      remap("command.bootstrap.includeFilteredDependencies", "command.bootstrap.includeDependencies"),
      remap("command.bootstrap.includeFilteredDependents", "command.bootstrap.includeDependents"),
      remap("command.clean.includeFilteredDependencies", "command.clean.includeDependencies"),
      remap("command.clean.includeFilteredDependents", "command.clean.includeDependents"),
      remap("command.exec.includeFilteredDependencies", "command.exec.includeDependencies"),
      remap("command.exec.includeFilteredDependents", "command.exec.includeDependents"),
      remap("command.list.includeFilteredDependencies", "command.list.includeDependencies"),
      remap("command.list.includeFilteredDependents", "command.list.includeDependents"),
      remap("command.run.includeFilteredDependencies", "command.run.includeDependencies"),
      remap("command.run.includeFilteredDependents", "command.run.includeDependents"),
      remap("command.version.githubRelease", "command.version.createRelease", {
        toValue: (value) => value && "github"
      }),
      remap("command.publish.githubRelease", "command.version.createRelease", {
        alsoRoot: true,
        toValue: (value) => value && "github"
      }),
      remap("command.publish.npmTag", "command.publish.distTag", { alsoRoot: true }),
      remap("command.publish.cdVersion", "command.publish.bump", { alsoRoot: true }),
      remap("command.publish.ignore", "command.publish.ignoreChanges"),
      remap("commands", "command"),
      (config, filepath) => ({ config, filepath })
    );
  }
});

// libs/core/src/lib/project/shallow-extend.ts
function shallowExtend(json, defaults = {}) {
  return Object.keys(json).reduce((obj, key) => {
    const val = json[key];
    if (Array.isArray(val)) {
      obj[key] = val.slice();
    } else if (val && typeof val === "object") {
      obj[key] = shallowExtend(val, obj[key]);
    } else {
      obj[key] = val;
    }
    return obj;
  }, defaults);
}
var init_shallow_extend = __esm({
  "libs/core/src/lib/project/shallow-extend.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/project/apply-extends.ts
function applyExtends(config, cwd, seen = /* @__PURE__ */ new Set()) {
  let defaultConfig = {};
  if ("extends" in config) {
    let pathToDefault;
    try {
      pathToDefault = (0, import_resolve_from.default)(cwd, config.extends);
    } catch (err) {
      throw new ValidationError("ERESOLVED", "Config .extends must be locally-resolvable", err);
    }
    if (seen.has(pathToDefault)) {
      throw new ValidationError("ECIRCULAR", "Config .extends cannot be circular", seen);
    }
    seen.add(pathToDefault);
    defaultConfig = require(pathToDefault);
    delete config.extends;
    deprecateConfig(defaultConfig, pathToDefault);
    defaultConfig = applyExtends(defaultConfig, import_path4.default.dirname(pathToDefault), seen);
  }
  return shallowExtend(config, defaultConfig);
}
var import_path4, import_resolve_from;
var init_apply_extends = __esm({
  "libs/core/src/lib/project/apply-extends.ts"() {
    "use strict";
    import_path4 = __toESM(require("path"));
    import_resolve_from = __toESM(require("resolve-from"));
    init_validation_error();
    init_deprecate_config();
    init_shallow_extend();
  }
});

// libs/core/src/lib/project/make-file-finder.ts
function normalize(results) {
  return results.map((fp) => import_path5.default.normalize(fp));
}
function getGlobOpts(rootPath, packageConfigs) {
  const globOpts = {
    cwd: rootPath,
    absolute: true,
    expandDirectories: false,
    followSymbolicLinks: false
  };
  if (packageConfigs.some((cfg) => cfg.indexOf("**") > -1)) {
    if (packageConfigs.some((cfg) => cfg.indexOf("node_modules") > -1)) {
      throw new ValidationError(
        "EPKGCONFIG",
        "An explicit node_modules package path does not allow globstars (**)"
      );
    }
    globOpts.ignore = [
      "**/node_modules/**"
    ];
  }
  return globOpts;
}
function makeFileFinder(rootPath, packageConfigs) {
  const globOpts = getGlobOpts(rootPath, packageConfigs);
  return (fileName, fileMapper, customGlobOpts) => {
    const options = Object.assign({}, customGlobOpts, globOpts);
    const promise = (0, import_p_map.default)(
      Array.from(packageConfigs).sort(),
      (globPath) => {
        let chain = (0, import_globby.default)(import_path5.default.posix.join(globPath, fileName), options);
        chain = chain.then((results) => results.sort());
        chain = chain.then(normalize);
        if (fileMapper) {
          chain = chain.then(fileMapper);
        }
        return chain;
      },
      { concurrency: 4 }
    );
    return promise.then((results) => results.reduce((acc, result) => acc.concat(result), []));
  };
}
function makeSyncFileFinder(rootPath, packageConfigs) {
  const globOpts = getGlobOpts(rootPath, packageConfigs);
  return (fileName, fileMapper, customGlobOpts) => {
    const options = Object.assign({}, customGlobOpts, globOpts);
    const patterns = packageConfigs.map((globPath) => import_path5.default.posix.join(globPath, fileName)).sort();
    let results = import_globby.default.sync(patterns, options);
    results = normalize(results);
    if (fileMapper) {
      results = results.map(fileMapper);
    }
    return results;
  };
}
var import_globby, import_p_map, import_path5;
var init_make_file_finder = __esm({
  "libs/core/src/lib/project/make-file-finder.ts"() {
    "use strict";
    import_globby = __toESM(require("globby"));
    import_p_map = __toESM(require("p-map"));
    import_path5 = __toESM(require("path"));
    init_validation_error();
  }
});

// libs/core/src/lib/project/index.ts
var import_devkit, import_cosmiconfig, import_dedent2, import_fs, import_glob_parent, import_globby2, import_js_yaml, import_load_json_file2, import_npmlog10, import_p_map2, import_path6, _Project, Project, getPackages, getPackagesSync;
var init_project = __esm({
  "libs/core/src/lib/project/index.ts"() {
    "use strict";
    import_devkit = require("@nrwl/devkit");
    import_cosmiconfig = require("cosmiconfig");
    import_dedent2 = __toESM(require("dedent"));
    import_fs = __toESM(require("fs"));
    import_glob_parent = __toESM(require("glob-parent"));
    import_globby2 = __toESM(require("globby"));
    import_js_yaml = require("js-yaml");
    import_load_json_file2 = __toESM(require("load-json-file"));
    import_npmlog10 = __toESM(require("npmlog"));
    import_p_map2 = __toESM(require("p-map"));
    import_path6 = __toESM(require("path"));
    init_package();
    init_validation_error();
    init_apply_extends();
    init_deprecate_config();
    init_make_file_finder();
    _Project = class {
      static getPackages(cwd) {
        return new _Project(cwd).getPackages();
      }
      static getPackagesSync(cwd) {
        return new _Project(cwd).getPackagesSync();
      }
      config;
      configNotFound;
      rootConfigLocation;
      rootPath;
      constructor(cwd) {
        const explorer = (0, import_cosmiconfig.cosmiconfigSync)("lerna", {
          searchPlaces: ["lerna.json", "package.json"],
          transform(obj) {
            if (!obj) {
              return {
                config: {},
                configNotFound: true,
                filepath: import_path6.default.resolve(cwd || ".", "lerna.json")
              };
            }
            deprecateConfig(obj.config, obj.filepath);
            obj.config = applyExtends(obj.config, import_path6.default.dirname(obj.filepath));
            return obj;
          }
        });
        let loaded;
        try {
          loaded = explorer.search(cwd);
        } catch (err) {
          if (err.name === "JSONError") {
            throw new ValidationError(err.name, err.message);
          }
          throw err;
        }
        this.config = loaded.config;
        this.configNotFound = loaded.configNotFound;
        this.rootConfigLocation = loaded.filepath;
        this.rootPath = import_path6.default.dirname(loaded.filepath);
        import_npmlog10.default.verbose("rootPath", this.rootPath);
      }
      get version() {
        return this.config.version;
      }
      set version(val) {
        this.config.version = val;
      }
      get packageConfigs() {
        if (this.config.npmClient === "pnpm") {
          import_npmlog10.default.verbose(
            "packageConfigs",
            "Package manager 'pnpm' detected. Resolving packages using 'pnpm-workspace.yaml'."
          );
          const workspaces = this.pnpmWorkspaceConfig.packages;
          if (!workspaces) {
            throw new ValidationError(
              "EWORKSPACES",
              "No 'packages' property found in pnpm-workspace.yaml. See https://pnpm.io/workspaces for help configuring workspaces in pnpm."
            );
          }
          return workspaces;
        }
        if (this.config.useWorkspaces) {
          const workspaces = this.manifest.get("workspaces");
          if (!workspaces) {
            throw new ValidationError(
              "EWORKSPACES",
              import_dedent2.default`
            Workspaces need to be defined in the root package.json.
            See: https://github.com/lerna/lerna/blob/master/commands/bootstrap/README.md#--use-workspaces
          `
            );
          }
          return workspaces.packages || workspaces;
        }
        if (this.manifest.get("workspaces")) {
          import_npmlog10.default.warn(
            "EWORKSPACES",
            import_dedent2.default`
          Workspaces exist in the root package.json, but Lerna is not configured to use them.
          To fix this and have Lerna use workspaces to resolve packages, set \`useWorkspaces: true\` in lerna.json.
        `
          );
        }
        if (this.config.packages) {
          return this.config.packages;
        }
        import_npmlog10.default.warn(
          "EPACKAGES",
          `No packages defined in lerna.json. Defaulting to packages in ${_Project.PACKAGE_GLOB}`
        );
        return [_Project.PACKAGE_GLOB];
      }
      get packageParentDirs() {
        return this.packageConfigs.map(import_glob_parent.default).map((parentDir) => import_path6.default.resolve(this.rootPath, parentDir));
      }
      get manifest() {
        let manifest;
        try {
          const manifestLocation = import_path6.default.join(this.rootPath, "package.json");
          const packageJson = import_load_json_file2.default.sync(manifestLocation);
          if (!packageJson.name) {
            packageJson.name = import_path6.default.basename(import_path6.default.dirname(manifestLocation));
          }
          manifest = new Package(packageJson, this.rootPath);
          Object.defineProperty(this, "manifest", {
            value: manifest
          });
        } catch (err) {
          if (err.name === "JSONError") {
            throw new ValidationError(err.name, err.message);
          }
        }
        return manifest;
      }
      get pnpmWorkspaceConfig() {
        let config;
        try {
          const configLocation = import_path6.default.join(this.rootPath, "pnpm-workspace.yaml");
          const configContent = import_fs.default.readFileSync(configLocation);
          config = (0, import_js_yaml.load)(configContent);
          Object.defineProperty(this, "pnpmWorkspaceConfig", {
            value: config
          });
        } catch (err) {
          if (err.message.includes("ENOENT: no such file or directory")) {
            throw new ValidationError(
              "ENOENT",
              "No pnpm-workspace.yaml found. See https://pnpm.io/workspaces for help configuring workspaces in pnpm."
            );
          }
          throw new ValidationError(err.name, err.message);
        }
        return config;
      }
      get licensePath() {
        let licensePath;
        try {
          const search = import_globby2.default.sync(_Project.LICENSE_GLOB, {
            cwd: this.rootPath,
            absolute: true,
            caseSensitiveMatch: false,
            deep: 0
          });
          licensePath = search.shift();
          if (licensePath) {
            licensePath = import_path6.default.normalize(licensePath);
            Object.defineProperty(this, "licensePath", {
              value: licensePath
            });
          }
        } catch (err) {
          throw new ValidationError(err.name, err.message);
        }
        return licensePath;
      }
      get fileFinder() {
        const finder = makeFileFinder(this.rootPath, this.packageConfigs);
        Object.defineProperty(this, "fileFinder", {
          value: finder
        });
        return finder;
      }
      getPackages() {
        const mapper = (packageConfigPath) => (0, import_load_json_file2.default)(packageConfigPath).then(
          (packageJson) => new Package(packageJson, import_path6.default.dirname(packageConfigPath), this.rootPath)
        );
        return this.fileFinder("package.json", (filePaths) => (0, import_p_map2.default)(filePaths, mapper, { concurrency: 50 }));
      }
      getPackagesSync() {
        return makeSyncFileFinder(this.rootPath, this.packageConfigs)("package.json", (packageConfigPath) => {
          return new Package(
            import_load_json_file2.default.sync(packageConfigPath),
            import_path6.default.dirname(packageConfigPath),
            this.rootPath
          );
        });
      }
      getPackageLicensePaths() {
        return this.fileFinder(_Project.LICENSE_GLOB, null, { caseSensitiveMatch: false });
      }
      isIndependent() {
        return this.version === "independent";
      }
      serializeConfig() {
        (0, import_devkit.writeJsonFile)(this.rootConfigLocation, this.config, { spaces: 2 });
        return this.rootConfigLocation;
      }
    };
    Project = _Project;
    __publicField(Project, "PACKAGE_GLOB", "packages/*");
    __publicField(Project, "LICENSE_GLOB", "LICEN{S,C}E{,.*}");
    getPackages = Project.getPackages;
    getPackagesSync = Project.getPackagesSync;
  }
});

// libs/core/src/lib/write-log-file.ts
function writeLogFile(cwd) {
  let logOutput = "";
  import_npmlog11.default.record.forEach((m) => {
    let pref = [m.id, m.level];
    if (m.prefix) {
      pref.push(m.prefix);
    }
    pref = pref.join(" ");
    m.message.trim().split(/\r?\n/).map((line) => `${pref} ${line}`.trim()).forEach((line) => {
      logOutput += line + import_os.default.EOL;
    });
  });
  import_write_file_atomic.default.sync(import_path7.default.join(cwd, "lerna-debug.log"), logOutput);
  import_npmlog11.default.record.length = 0;
}
var import_npmlog11, import_os, import_path7, import_write_file_atomic;
var init_write_log_file = __esm({
  "libs/core/src/lib/write-log-file.ts"() {
    "use strict";
    import_npmlog11 = __toESM(require("npmlog"));
    import_os = __toESM(require("os"));
    import_path7 = __toESM(require("path"));
    import_write_file_atomic = __toESM(require("write-file-atomic"));
  }
});

// libs/core/src/lib/command/clean-stack.ts
function cleanStack(err, className) {
  const lines = err.stack ? err.stack.split("\n") : String(err).split("\n");
  const cutoff = new RegExp(`^    at ${className}.runCommand .*$`);
  const relevantIndex = lines.findIndex((line) => cutoff.test(line));
  if (relevantIndex) {
    return lines.slice(0, relevantIndex).join("\n");
  }
  return err;
}
var init_clean_stack = __esm({
  "libs/core/src/lib/command/clean-stack.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/command/default-options.ts
function defaultOptions(...sources) {
  const options = {};
  for (const source of sources) {
    if (source != null) {
      for (const key of Object.keys(source)) {
        if (options[key] === void 0) {
          options[key] = source[key];
        }
      }
    }
  }
  return options;
}
var init_default_options = __esm({
  "libs/core/src/lib/command/default-options.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/command/log-package-error.ts
function logPackageError(err, stream = false) {
  import_npmlog12.default.error(err.command, `exited ${err.exitCode} in '${err.pkg.name}'`);
  if (stream) {
    return;
  }
  if (err.stdout) {
    import_npmlog12.default.error(err.command, "stdout:");
    directLog(err.stdout);
  }
  if (err.stderr) {
    import_npmlog12.default.error(err.command, "stderr:");
    directLog(err.stderr);
  }
  import_npmlog12.default.error(err.command, `exited ${err.exitCode} in '${err.pkg.name}'`);
}
function directLog(message) {
  import_npmlog12.default.pause();
  console.error(message);
  import_npmlog12.default.resume();
}
var import_npmlog12;
var init_log_package_error = __esm({
  "libs/core/src/lib/command/log-package-error.ts"() {
    "use strict";
    import_npmlog12 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/command/warn-if-hanging.ts
function warnIfHanging() {
  const childProcessCount = childProcess5.getChildProcessCount();
  if (childProcessCount > 0) {
    import_npmlog13.default.warn(
      "complete",
      `Waiting for ${childProcessCount} child process${childProcessCount === 1 ? "" : "es"} to exit. CTRL-C to exit immediately.`
    );
  }
}
var import_npmlog13, childProcess5;
var init_warn_if_hanging = __esm({
  "libs/core/src/lib/command/warn-if-hanging.ts"() {
    "use strict";
    import_npmlog13 = __toESM(require("npmlog"));
    childProcess5 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/command/index.ts
var import_clone_deep, import_dedent3, import_execa, import_npmlog14, import_os2, DEFAULT_CONCURRENCY, Command;
var init_command = __esm({
  "libs/core/src/lib/command/index.ts"() {
    "use strict";
    import_clone_deep = __toESM(require("clone-deep"));
    import_dedent3 = __toESM(require("dedent"));
    import_execa = __toESM(require("execa"));
    import_npmlog14 = __toESM(require("npmlog"));
    import_os2 = __toESM(require("os"));
    init_package_graph();
    init_project();
    init_validation_error();
    init_write_log_file();
    init_clean_stack();
    init_default_options();
    init_log_package_error();
    init_warn_if_hanging();
    DEFAULT_CONCURRENCY = import_os2.default.cpus().length;
    Command = class {
      name;
      composed;
      project;
      options;
      runner;
      concurrency;
      toposort;
      execOpts;
      packageGraph;
      logger;
      constructor(_argv, { skipValidations } = { skipValidations: false }) {
        import_npmlog14.default.pause();
        import_npmlog14.default.heading = "lerna";
        const argv = (0, import_clone_deep.default)(_argv);
        import_npmlog14.default.silly("argv", argv);
        this.name = this.constructor.name.replace(/Command$/, "").toLowerCase();
        this.composed = typeof argv.composed === "string" && argv.composed !== this.name;
        if (!this.composed) {
          import_npmlog14.default.notice("cli", `v${argv.lernaVersion}`);
        }
        let runner = new Promise((resolve, reject) => {
          let chain = Promise.resolve();
          chain = chain.then(() => {
            this.project = new Project(argv.cwd);
          });
          chain = chain.then(() => this.configureEnvironment());
          chain = chain.then(() => this.configureOptions());
          chain = chain.then(() => this.configureProperties());
          chain = chain.then(() => this.configureLogging());
          if (!skipValidations) {
            chain = chain.then(() => this.runValidations());
          }
          chain = chain.then(() => this.runPreparations());
          chain = chain.then(() => this.runCommand());
          chain.then(
            (result) => {
              warnIfHanging();
              resolve(result);
            },
            (err) => {
              if (err.pkg) {
                logPackageError(err, this.options.stream);
              } else if (err.name !== "ValidationError") {
                import_npmlog14.default.error("", cleanStack(err, this.constructor.name));
              }
              if (err.name !== "ValidationError" && !err.pkg) {
                writeLogFile(this.project.rootPath);
              }
              warnIfHanging();
              reject(err);
            }
          );
        });
        if (argv.onResolved || argv.onRejected) {
          runner = runner.then(argv.onResolved, argv.onRejected);
          delete argv.onResolved;
          delete argv.onRejected;
        }
        for (const key of ["cwd", "$0"]) {
          Object.defineProperty(argv, key, { enumerable: false });
        }
        Object.defineProperty(this, "argv", {
          value: Object.freeze(argv)
        });
        Object.defineProperty(this, "runner", {
          value: runner
        });
      }
      then(onResolved, onRejected) {
        return this.runner.then(onResolved, onRejected);
      }
      catch(onRejected) {
        return this.runner.catch(onRejected);
      }
      get requiresGit() {
        return true;
      }
      get otherCommandConfigs() {
        return [];
      }
      configureEnvironment() {
        const ci = require("is-ci");
        let loglevel;
        let progress;
        if (ci || !process.stderr.isTTY) {
          import_npmlog14.default.disableColor();
          progress = false;
        } else if (!process.stdout.isTTY) {
          progress = false;
          loglevel = "error";
        } else if (process.stderr.isTTY) {
          import_npmlog14.default.enableColor();
          import_npmlog14.default.enableUnicode();
        }
        Object.defineProperty(this, "envDefaults", {
          value: {
            ci,
            progress,
            loglevel
          }
        });
      }
      configureOptions() {
        const commandConfig = this.project.config.command || {};
        const overrides = [this.name, ...this.otherCommandConfigs].map((key) => commandConfig[key]);
        this.options = defaultOptions(
          this.argv,
          ...overrides,
          this.project.config,
          this.envDefaults
        );
        if (this.options.verbose && this.options.loglevel !== "silly") {
          this.options.loglevel = "verbose";
        }
      }
      argv(argv, arg1, config, envDefaults) {
        throw new Error("Method not implemented.");
      }
      envDefaults(argv, arg1, config, envDefaults) {
        throw new Error("Method not implemented.");
      }
      configureProperties() {
        const { concurrency, sort, maxBuffer } = this.options;
        this.concurrency = Math.max(1, +concurrency || DEFAULT_CONCURRENCY);
        this.toposort = sort === void 0 || sort;
        this.execOpts = {
          cwd: this.project.rootPath,
          maxBuffer
        };
      }
      configureLogging() {
        const { loglevel } = this.options;
        if (loglevel) {
          import_npmlog14.default.level = loglevel;
        }
        import_npmlog14.default.addLevel("success", 3001, { fg: "green", bold: true });
        Object.defineProperty(this, "logger", {
          value: import_npmlog14.default["newGroup"](this.name)
        });
        import_npmlog14.default.resume();
      }
      enableProgressBar() {
        if (this.options.progress !== false) {
          import_npmlog14.default.enableProgress();
        }
      }
      gitInitialized() {
        const opts = {
          cwd: this.project.rootPath,
          reject: false,
          stdio: "ignore"
        };
        return import_execa.default.sync("git", ["rev-parse"], opts).exitCode === 0;
      }
      runValidations() {
        if ((this.options.since !== void 0 || this.requiresGit) && !this.gitInitialized()) {
          throw new ValidationError("ENOGIT", "The git binary was not found, or this is not a git repository.");
        }
        if (!this.project.manifest) {
          throw new ValidationError("ENOPKG", "`package.json` does not exist, have you run `lerna init`?");
        }
        if (this.project.configNotFound) {
          throw new ValidationError("ENOLERNA", "`lerna.json` does not exist, have you run `lerna init`?");
        }
        if (!this.project.version) {
          throw new ValidationError("ENOVERSION", "Required property version does not exist in `lerna.json`");
        }
        if (this.options.independent && !this.project.isIndependent()) {
          throw new ValidationError(
            "EVERSIONMODE",
            import_dedent3.default`
          You ran lerna with --independent or -i, but the repository is not set to independent mode.
          To use independent mode you need to set lerna.json's "version" property to "independent".
          Then you won't need to pass the --independent or -i flags.
        `
          );
        }
        if (this.options.npmClient === "pnpm" && !this.options.useWorkspaces) {
          throw new ValidationError(
            "ENOWORKSPACES",
            "Usage of pnpm without workspaces is not supported. To use pnpm with lerna, set useWorkspaces to true in lerna.json and configure pnpm to use workspaces: https://pnpm.io/workspaces."
          );
        }
      }
      runPreparations() {
        if (!this.composed && this.project.isIndependent()) {
          import_npmlog14.default.info("versioning", "independent");
        }
        if (!this.composed && this.options.ci) {
          import_npmlog14.default.info("ci", "enabled");
        }
        let chain = Promise.resolve();
        chain = chain.then(() => this.project.getPackages());
        chain = chain.then((packages) => {
          this.packageGraph = new PackageGraph(packages);
        });
        return chain;
      }
      runCommand() {
        return Promise.resolve().then(() => this.initialize()).then((proceed) => {
          if (proceed !== false) {
            return this.execute();
          }
        });
      }
      initialize() {
        throw new ValidationError(this.name, "initialize() needs to be implemented.");
      }
      execute() {
        throw new ValidationError(this.name, "execute() needs to be implemented.");
      }
    };
  }
});

// libs/core/src/lib/conventional-commits/get-changelog-config.ts
function isFunction(config) {
  return Object.prototype.toString.call(config) === "[object Function]";
}
function resolveConfigPromise(presetPackageName, presetConfig) {
  import_npmlog15.default.verbose("getChangelogConfig", "Attempting to resolve preset %j", presetPackageName);
  let config = require(presetPackageName);
  import_npmlog15.default.info("getChangelogConfig", "Successfully resolved preset %j", presetPackageName);
  if (isFunction(config)) {
    try {
      config = config(presetConfig);
    } catch (_) {
      config = (0, import_pify.default)(config)();
    }
  }
  return config;
}
function getChangelogConfig(changelogPreset = "conventional-changelog-angular", rootPath) {
  const presetName = typeof changelogPreset === "string" ? changelogPreset : changelogPreset.name;
  const presetConfig = typeof changelogPreset === "object" ? changelogPreset : {};
  const cacheKey = `${presetName}${presetConfig ? JSON.stringify(presetConfig) : ""}`;
  let config = cfgCache.get(cacheKey);
  if (!config) {
    let presetPackageName = presetName;
    const parsed = (0, import_npm_package_arg3.default)(presetPackageName, rootPath);
    import_npmlog15.default.verbose("getChangelogConfig", "using preset %j", presetPackageName);
    import_npmlog15.default.silly("npa", parsed);
    if (parsed.type === "directory") {
      if (parsed.raw[0] === "@") {
        parsed.name = parsed.raw;
        parsed.scope = parsed.raw.substring(0, parsed.raw.indexOf("/"));
      } else {
        presetPackageName = parsed.fetchSpec;
      }
    } else if (parsed.type === "git" && parsed.hosted && parsed.hosted.default === "shortcut") {
      parsed.name = parsed.raw;
    }
    try {
      config = resolveConfigPromise(presetPackageName, presetConfig);
      cfgCache.set(cacheKey, config);
      return Promise.resolve(config);
    } catch (err) {
      import_npmlog15.default.verbose("getChangelogConfig", err.message);
      import_npmlog15.default.info("getChangelogConfig", "Auto-prefixing conventional-changelog preset %j", presetName);
      parsed.name = parsed.raw;
    }
    if (parsed.name.indexOf("conventional-changelog-") < 0) {
      const parts = parsed.name.split("/");
      const start = parsed.scope ? 1 : 0;
      parts.splice(start, 1, `conventional-changelog-${parts[start]}`);
      presetPackageName = parts.join("/");
    }
    try {
      config = resolveConfigPromise(presetPackageName, presetConfig);
      cfgCache.set(cacheKey, config);
    } catch (err) {
      import_npmlog15.default.warn("getChangelogConfig", err.message);
      throw new ValidationError(
        "EPRESET",
        `Unable to load conventional-changelog preset '${presetName}'${presetName !== presetPackageName ? ` (${presetPackageName})` : ""}`
      );
    }
  }
  return Promise.resolve(config);
}
var import_npm_package_arg3, import_npmlog15, import_pify, cfgCache;
var init_get_changelog_config = __esm({
  "libs/core/src/lib/conventional-commits/get-changelog-config.ts"() {
    "use strict";
    import_npm_package_arg3 = __toESM(require("npm-package-arg"));
    import_npmlog15 = __toESM(require("npmlog"));
    import_pify = __toESM(require("pify"));
    init_validation_error();
    cfgCache = /* @__PURE__ */ new Map();
  }
});

// libs/core/src/lib/conventional-commits/recommend-version.ts
function recommendVersion(pkg, type, {
  changelogPreset,
  rootPath,
  tagPrefix,
  prereleaseId,
  conventionalBumpPrerelease
}) {
  import_npmlog16.default.silly(type, "for %s at %s", pkg.name, pkg.location);
  const options = {
    path: pkg.location
  };
  if (type === "independent") {
    options.lernaPackage = pkg.name;
  } else {
    options.tagPrefix = tagPrefix;
  }
  const shouldBumpPrerelease = (releaseType, version) => {
    if (!import_semver3.default.prerelease(version)) {
      return true;
    }
    switch (releaseType) {
      case "major":
        return import_semver3.default.minor(version) !== 0 || import_semver3.default.patch(version) !== 0;
      case "minor":
        return import_semver3.default.patch(version) !== 0;
      default:
        return false;
    }
  };
  let chain = Promise.resolve();
  chain = chain.then(() => getChangelogConfig(changelogPreset, rootPath));
  chain = chain.then((config) => {
    options.config = config;
    return new Promise((resolve, reject) => {
      (0, import_conventional_recommended_bump.default)(options, (err, data) => {
        if (err) {
          return reject(err);
        }
        let releaseType = data.releaseType || "patch";
        if (prereleaseId) {
          const shouldBump = conventionalBumpPrerelease || shouldBumpPrerelease(releaseType, pkg.version);
          const prereleaseType = shouldBump ? `pre${releaseType}` : "prerelease";
          import_npmlog16.default.verbose(type, "increment %s by %s", pkg.version, prereleaseType);
          resolve(import_semver3.default.inc(pkg.version, prereleaseType, prereleaseId));
        } else {
          if (import_semver3.default.major(pkg.version) === 0) {
            if (releaseType === "major") {
              releaseType = "minor";
            }
          }
          import_npmlog16.default.verbose(type, "increment %s by %s", pkg.version, releaseType);
          resolve(import_semver3.default.inc(pkg.version, releaseType));
        }
      });
    });
  });
  return chain;
}
var import_conventional_recommended_bump, import_npmlog16, import_semver3;
var init_recommend_version = __esm({
  "libs/core/src/lib/conventional-commits/recommend-version.ts"() {
    "use strict";
    import_conventional_recommended_bump = __toESM(require("conventional-recommended-bump"));
    import_npmlog16 = __toESM(require("npmlog"));
    import_semver3 = __toESM(require("semver"));
    init_get_changelog_config();
  }
});

// libs/core/src/lib/conventional-commits/constants.ts
var EOL, BLANK_LINE, COMMIT_GUIDELINE, CHANGELOG_HEADER;
var init_constants = __esm({
  "libs/core/src/lib/conventional-commits/constants.ts"() {
    "use strict";
    EOL = "\n";
    BLANK_LINE = EOL + EOL;
    COMMIT_GUIDELINE = "See [Conventional Commits](https://conventionalcommits.org) for commit guidelines.";
    CHANGELOG_HEADER = [
      "# Change Log",
      "",
      "All notable changes to this project will be documented in this file.",
      COMMIT_GUIDELINE
    ].join(EOL);
  }
});

// libs/core/src/lib/conventional-commits/make-bump-only-filter.ts
function makeBumpOnlyFilter(pkg) {
  return (newEntry) => {
    if (!newEntry.split("\n").some((line) => line.startsWith("*"))) {
      const message = `**Note:** Version bump only for package ${pkg.name}`;
      return [newEntry.trim(), message, BLANK_LINE].join(BLANK_LINE);
    }
    return newEntry;
  };
}
var init_make_bump_only_filter = __esm({
  "libs/core/src/lib/conventional-commits/make-bump-only-filter.ts"() {
    "use strict";
    init_constants();
  }
});

// libs/core/src/lib/conventional-commits/read-existing-changelog.ts
function readExistingChangelog(pkg) {
  const changelogFileLoc = import_path8.default.join(pkg.location, "CHANGELOG.md");
  let chain = Promise.resolve();
  chain = chain.then(() => import_fs_extra.default.readFile(changelogFileLoc, "utf8").catch(() => ""));
  chain = chain.then((changelogContents) => {
    const headerIndex = changelogContents.indexOf(COMMIT_GUIDELINE);
    if (headerIndex !== -1) {
      return changelogContents.substring(headerIndex + COMMIT_GUIDELINE.length + BLANK_LINE.length);
    }
    return changelogContents;
  });
  chain = chain.then((changelogContents) => [changelogFileLoc, changelogContents]);
  return chain;
}
var import_fs_extra, import_path8;
var init_read_existing_changelog = __esm({
  "libs/core/src/lib/conventional-commits/read-existing-changelog.ts"() {
    "use strict";
    import_fs_extra = __toESM(require("fs-extra"));
    import_path8 = __toESM(require("path"));
    init_constants();
  }
});

// libs/core/src/lib/conventional-commits/update-changelog.ts
function updateChangelog(pkg, type, { changelogPreset, rootPath, tagPrefix = "v", version }) {
  import_npmlog17.default.silly(type, "for %s at %s", pkg.name, pkg.location);
  return getChangelogConfig(changelogPreset, rootPath).then((config) => {
    const options = {};
    const context = {};
    if (config.conventionalChangelog) {
      options.config = Object.assign({}, config.conventionalChangelog);
    } else {
      options.config = Object.assign({}, config);
    }
    const gitRawCommitsOpts = Object.assign({}, options.config.gitRawCommitsOpts);
    if (type === "root") {
      context.version = version;
      context.currentTag = `${tagPrefix}${version}`;
      options.tagPrefix = tagPrefix;
    } else {
      gitRawCommitsOpts.path = pkg.location;
      options.pkg = { path: pkg.manifestLocation };
      if (type === "independent") {
        options.lernaPackage = pkg.name;
      } else {
        options.tagPrefix = tagPrefix;
        context.currentTag = `${tagPrefix}${pkg.version}`;
      }
    }
    const changelogStream = (0, import_conventional_changelog_core.default)(options, context, gitRawCommitsOpts);
    return Promise.all([
      (0, import_get_stream.default)(changelogStream).then(makeBumpOnlyFilter(pkg)),
      readExistingChangelog(pkg)
    ]).then(([newEntry, [changelogFileLoc, changelogContents]]) => {
      import_npmlog17.default.silly(type, "writing new entry: %j", newEntry);
      const content = [CHANGELOG_HEADER, newEntry, changelogContents].join(BLANK_LINE);
      return import_fs_extra2.default.writeFile(changelogFileLoc, content.trim() + EOL).then(() => {
        import_npmlog17.default.verbose(type, "wrote", changelogFileLoc);
        return {
          logPath: changelogFileLoc,
          newEntry
        };
      });
    });
  });
}
var import_conventional_changelog_core, import_fs_extra2, import_get_stream, import_npmlog17;
var init_update_changelog = __esm({
  "libs/core/src/lib/conventional-commits/update-changelog.ts"() {
    "use strict";
    import_conventional_changelog_core = __toESM(require("conventional-changelog-core"));
    import_fs_extra2 = __toESM(require("fs-extra"));
    import_get_stream = __toESM(require("get-stream"));
    import_npmlog17 = __toESM(require("npmlog"));
    init_constants();
    init_get_changelog_config();
    init_make_bump_only_filter();
    init_read_existing_changelog();
  }
});

// libs/core/src/lib/conventional-commits/index.ts
var init_conventional_commits = __esm({
  "libs/core/src/lib/conventional-commits/index.ts"() {
    "use strict";
    init_recommend_version();
    init_update_changelog();
  }
});

// libs/core/src/lib/create-symlink.ts
var import_cmd_shim, import_fs_extra3, import_npmlog18;
var init_create_symlink = __esm({
  "libs/core/src/lib/create-symlink.ts"() {
    "use strict";
    import_cmd_shim = __toESM(require("cmd-shim"));
    import_fs_extra3 = __toESM(require("fs-extra"));
    import_npmlog18 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/filter-packages.ts
var import_multimatch, import_npmlog19;
var init_filter_packages = __esm({
  "libs/core/src/lib/filter-packages.ts"() {
    "use strict";
    import_multimatch = __toESM(require("multimatch"));
    import_npmlog19 = __toESM(require("npmlog"));
    init_validation_error();
  }
});

// libs/core/src/lib/filter-options.ts
var import_dedent4, import_npmlog20;
var init_filter_options = __esm({
  "libs/core/src/lib/filter-options.ts"() {
    "use strict";
    import_dedent4 = __toESM(require("dedent"));
    import_npmlog20 = __toESM(require("npmlog"));
    init_collect_updates();
    init_filter_packages();
  }
});

// libs/core/src/lib/has-npm-version.ts
var import_semver4, childProcess6;
var init_has_npm_version = __esm({
  "libs/core/src/lib/has-npm-version.ts"() {
    "use strict";
    import_semver4 = __toESM(require("semver"));
    childProcess6 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/query-graph.ts
var QueryGraph, toposort;
var init_query_graph = __esm({
  "libs/core/src/lib/query-graph.ts"() {
    "use strict";
    init_package_graph();
    QueryGraph = class {
      graph;
      cycles;
      static toposort(packages, options) {
        const graph = new QueryGraph(packages, options);
        const result = [];
        let batch = graph.getAvailablePackages();
        while (batch.length) {
          for (const node of batch) {
            result.push(node.pkg);
            graph.markAsDone(node);
          }
          batch = graph.getAvailablePackages();
        }
        return result;
      }
      constructor(packages, { graphType = "allDependencies", rejectCycles } = {}) {
        this.graph = new PackageGraph(packages, graphType);
        this.cycles = this.graph.collapseCycles(rejectCycles);
      }
      _getNextLeaf() {
        return Array.from(this.graph.values()).filter((node) => node.localDependencies.size === 0);
      }
      _getNextCycle() {
        const cycle = Array.from(this.cycles).find((cycleNode) => cycleNode.localDependencies.size === 0);
        if (!cycle) {
          return [];
        }
        this.cycles.delete(cycle);
        return cycle.flatten();
      }
      getAvailablePackages() {
        const availablePackages = this._getNextLeaf();
        if (availablePackages.length > 0) {
          return availablePackages;
        }
        return this._getNextCycle();
      }
      markAsTaken(name) {
        this.graph.delete(name);
      }
      markAsDone(candidateNode) {
        this.graph.remove(candidateNode);
        for (const cycle of this.cycles) {
          cycle.unlink(candidateNode);
        }
      }
    };
    toposort = QueryGraph.toposort;
  }
});

// libs/core/src/lib/listable/listable-format.ts
var import_chalk2, import_columnify;
var init_listable_format = __esm({
  "libs/core/src/lib/listable/listable-format.ts"() {
    "use strict";
    import_chalk2 = __toESM(require("chalk"));
    import_columnify = __toESM(require("columnify"));
    init_query_graph();
  }
});

// libs/core/src/lib/listable/listable-options.ts
var init_listable_options = __esm({
  "libs/core/src/lib/listable/listable-options.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/log-packed.ts
function logPacked(tarball) {
  import_npmlog21.default.notice("");
  import_npmlog21.default.notice("", `${hasUnicode ? "\u{1F4E6} " : "package:"} ${tarball.name}@${tarball.version}`);
  if (tarball.files && tarball.files.length) {
    import_npmlog21.default.notice("=== Tarball Contents ===");
    import_npmlog21.default.notice(
      "",
      (0, import_columnify2.default)(
        tarball.files.map((f) => {
          const bytes = (0, import_byte_size.default)(f.size);
          return {
            path: f.path,
            size: `${bytes.value}${bytes.unit}`
          };
        }),
        {
          include: ["size", "path"],
          showHeaders: false
        }
      )
    );
  }
  if (tarball.bundled && tarball.bundled.length) {
    import_npmlog21.default.notice("=== Bundled Dependencies ===");
    tarball.bundled.forEach((name) => import_npmlog21.default.notice("", name));
  }
  import_npmlog21.default.notice("=== Tarball Details ===");
  import_npmlog21.default.notice(
    "",
    (0, import_columnify2.default)(
      [
        { name: "name:", value: tarball.name },
        { name: "version:", value: tarball.version },
        tarball.filename && { name: "filename:", value: tarball.filename },
        tarball.size && { name: "package size:", value: (0, import_byte_size.default)(tarball.size) },
        tarball.unpackedSize && { name: "unpacked size:", value: (0, import_byte_size.default)(tarball.unpackedSize) },
        tarball.shasum && { name: "shasum:", value: tarball.shasum },
        tarball.integrity && { name: "integrity:", value: elideIntegrity(tarball.integrity) },
        tarball.bundled && tarball.bundled.length && {
          name: "bundled deps:",
          value: tarball.bundled.length
        },
        tarball.bundled && tarball.bundled.length && {
          name: "bundled files:",
          value: tarball.entryCount - tarball.files.length
        },
        tarball.bundled && tarball.bundled.length && {
          name: "own files:",
          value: tarball.files.length
        },
        tarball.entryCount && { name: "total files:", value: tarball.entryCount }
      ].filter((x) => x),
      {
        include: ["name", "value"],
        showHeaders: false
      }
    )
  );
  import_npmlog21.default.notice("", "");
}
function elideIntegrity(integrity) {
  const str = integrity.toString();
  return `${str.substr(0, 20)}[...]${str.substr(80)}`;
}
var import_byte_size, import_columnify2, import_npmlog21, import_has_unicode, hasUnicode;
var init_log_packed = __esm({
  "libs/core/src/lib/log-packed.ts"() {
    "use strict";
    import_byte_size = __toESM(require("byte-size"));
    import_columnify2 = __toESM(require("columnify"));
    import_npmlog21 = __toESM(require("npmlog"));
    import_has_unicode = __toESM(require("has-unicode"));
    hasUnicode = (0, import_has_unicode.default)();
  }
});

// libs/core/src/lib/get-npm-exec-opts.ts
function getNpmExecOpts(pkg, registry) {
  const env = {
    LERNA_PACKAGE_NAME: pkg.name
  };
  if (registry) {
    env.npm_config_registry = registry;
  }
  import_npmlog22.default.silly("getNpmExecOpts", pkg.location, registry);
  return {
    cwd: pkg.location,
    env,
    pkg
  };
}
var import_npmlog22;
var init_get_npm_exec_opts = __esm({
  "libs/core/src/lib/get-npm-exec-opts.ts"() {
    "use strict";
    import_npmlog22 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/npm-install.ts
function npmInstall(pkg, { registry, npmClient, npmClientArgs, npmGlobalStyle, mutex, stdio = "pipe", subCommand = "install" }) {
  const opts = getNpmExecOpts(pkg, registry);
  const args = [subCommand];
  let cmd = npmClient || "npm";
  if (npmGlobalStyle) {
    cmd = "npm";
    args.push("--global-style");
  }
  if (cmd === "yarn" && mutex) {
    args.push("--mutex", mutex);
  }
  if (cmd === "yarn") {
    args.push("--non-interactive");
  }
  if (npmClientArgs && npmClientArgs.length) {
    args.push(...npmClientArgs);
  }
  opts.stdio = stdio;
  opts.env.LERNA_EXEC_PATH = pkg.location;
  opts.env.LERNA_ROOT_PATH = pkg.rootPath;
  import_npmlog23.default.silly("npmInstall", [cmd, args]);
  return childProcess7.exec(cmd, args, opts);
}
function npmInstallDependencies(pkg, dependencies, config) {
  import_npmlog23.default.silly("npmInstallDependencies", pkg.name, dependencies);
  if (!(dependencies && dependencies.length)) {
    import_npmlog23.default.verbose("npmInstallDependencies", "no dependencies to install");
    return Promise.resolve();
  }
  const packageJsonBkp = `${pkg.manifestLocation}.lerna_backup`;
  import_npmlog23.default.silly("npmInstallDependencies", "backup", pkg.manifestLocation);
  return import_fs_extra4.default.copy(pkg.manifestLocation, packageJsonBkp).then(() => {
    const cleanup = () => {
      import_npmlog23.default.silly("npmInstallDependencies", "cleanup", pkg.manifestLocation);
      import_fs_extra4.default.renameSync(packageJsonBkp, pkg.manifestLocation);
    };
    const unregister = (0, import_signal_exit.default)(cleanup);
    const done = (finalError) => {
      cleanup();
      unregister();
      if (finalError) {
        throw finalError;
      }
    };
    const tempJson = transformManifest(pkg, dependencies);
    import_npmlog23.default.silly("npmInstallDependencies", "writing tempJson", tempJson);
    return (0, import_write_pkg2.default)(pkg.manifestLocation, tempJson).then(() => npmInstall(pkg, config)).then(() => done(), done);
  });
}
function transformManifest(pkg, dependencies) {
  const json = pkg.toJSON();
  const depMap = new Map(
    dependencies.map((dep) => {
      const { name, rawSpec } = (0, import_npm_package_arg4.default)(dep, pkg.location);
      return [name, rawSpec || "*"];
    })
  );
  delete json.scripts;
  ["dependencies", "devDependencies", "optionalDependencies"].forEach((depType) => {
    const collection = json[depType];
    if (collection) {
      Object.keys(collection).forEach((depName) => {
        if (depMap.has(depName)) {
          collection[depName] = depMap.get(depName);
          depMap.delete(depName);
        } else {
          delete collection[depName];
        }
      });
    }
  });
  ["bundledDependencies", "bundleDependencies"].forEach((depType) => {
    const collection = json[depType];
    if (Array.isArray(collection)) {
      const newCollection = [];
      for (const depName of collection) {
        if (depMap.has(depName)) {
          newCollection.push(depName);
          depMap.delete(depName);
        }
      }
      json[depType] = newCollection;
    }
  });
  if (depMap.size) {
    if (!json.dependencies) {
      json.dependencies = {};
    }
    depMap.forEach((depVersion, depName) => {
      json.dependencies[depName] = depVersion;
    });
  }
  return json;
}
var import_fs_extra4, import_npm_package_arg4, import_npmlog23, import_signal_exit, import_write_pkg2, childProcess7;
var init_npm_install = __esm({
  "libs/core/src/lib/npm-install.ts"() {
    "use strict";
    import_fs_extra4 = __toESM(require("fs-extra"));
    import_npm_package_arg4 = __toESM(require("npm-package-arg"));
    import_npmlog23 = __toESM(require("npmlog"));
    import_signal_exit = __toESM(require("signal-exit"));
    import_write_pkg2 = __toESM(require("write-pkg"));
    init_get_npm_exec_opts();
    childProcess7 = require("@lerna/child-process");
    module.exports.npmInstallDependencies = npmInstallDependencies;
  }
});

// libs/core/src/lib/prompt.ts
function promptConfirmation(message) {
  import_npmlog24.default.pause();
  return import_inquirer.default.prompt([
    {
      type: "expand",
      name: "confirm",
      message,
      default: 2,
      choices: [
        { key: "y", name: "Yes", value: true },
        { key: "n", name: "No", value: false }
      ]
    }
  ]).then((answers) => {
    import_npmlog24.default.resume();
    return answers.confirm;
  });
}
function promptSelectOne(message, { choices, filter, validate } = {}) {
  import_npmlog24.default.pause();
  return import_inquirer.default.prompt([
    {
      type: "list",
      name: "prompt",
      message,
      choices,
      pageSize: choices?.length,
      filter,
      validate
    }
  ]).then((answers) => {
    import_npmlog24.default.resume();
    return answers["prompt"];
  });
}
function promptTextInput(message, { filter, validate } = {}) {
  import_npmlog24.default.pause();
  return import_inquirer.default.prompt([
    {
      type: "input",
      name: "input",
      message,
      filter,
      validate
    }
  ]).then((answers) => {
    import_npmlog24.default.resume();
    return answers.input;
  });
}
var import_inquirer, import_npmlog24;
var init_prompt = __esm({
  "libs/core/src/lib/prompt.ts"() {
    "use strict";
    import_inquirer = __toESM(require("inquirer"));
    import_npmlog24 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/otplease.ts
function otplease(fn, _opts, otpCache) {
  const opts = { ...otpCache, ..._opts };
  return attempt(fn, opts, otpCache);
}
function attempt(fn, opts, otpCache) {
  return new Promise((resolve) => {
    resolve(fn(opts));
  }).catch((err) => {
    if (err.code !== "EOTP" && !(err.code === "E401" && /one-time pass/.test(err.body))) {
      throw err;
    } else if (!process.stdin.isTTY || !process.stdout.isTTY) {
      throw err;
    } else {
      if (otpCache != null && otpCache.otp != null && otpCache.otp !== opts["otp"]) {
        return attempt(fn, { ...opts, ...otpCache }, otpCache);
      }
      return semaphore.wait().then(() => {
        if (otpCache != null && otpCache.otp != null && otpCache.otp !== opts["otp"]) {
          semaphore.release();
          return attempt(fn, { ...opts, ...otpCache }, otpCache);
        }
        return getOneTimePassword().then(
          (otp) => {
            if (otpCache != null) {
              otpCache.otp = otp;
            }
            semaphore.release();
            return otp;
          },
          (promptError) => {
            semaphore.release();
            return Promise.reject(promptError);
          }
        ).then((otp) => {
          return fn({ ...opts, otp });
        });
      });
    }
  });
}
function getOneTimePassword(message = "This operation requires a one-time password:") {
  return promptTextInput(message, {
    filter: (otp) => otp.replace(/\s+/g, ""),
    validate: (otp) => otp && /^[\d ]+$|^[A-Fa-f0-9]{64,64}$/.test(otp) || "Must be a valid one-time-password. See https://docs.npmjs.com/getting-started/using-two-factor-authentication"
  });
}
var semaphore;
var init_otplease = __esm({
  "libs/core/src/lib/otplease.ts"() {
    "use strict";
    init_prompt();
    semaphore = {
      _promise: void 0,
      _resolve: void 0,
      wait() {
        return new Promise((resolve) => {
          if (!this._promise) {
            this._promise = new Promise((release) => {
              this._resolve = release;
            });
            resolve(void 0);
          } else {
            resolve(this._promise.then(() => this.wait()));
          }
        });
      },
      release() {
        const resolve = this._resolve;
        if (resolve) {
          this._resolve = void 0;
          this._promise = void 0;
          resolve();
        }
      }
    };
  }
});

// libs/core/src/lib/npm-conf/env-replace.ts
function envReplace(str) {
  if (typeof str !== "string" || !str) {
    return str;
  }
  const regex = /(\\*)\$\{([^}]+)\}/g;
  return str.replace(regex, (orig, esc, name) => {
    esc = esc.length > 0 && esc.length % 2;
    if (esc) {
      return orig;
    }
    if (process.env[name] === void 0) {
      throw new Error(`Failed to replace env in config: ${orig}`);
    }
    return process.env[name];
  });
}
var init_env_replace = __esm({
  "libs/core/src/lib/npm-conf/env-replace.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/npm-conf/find-prefix.ts
function findPrefix(start) {
  let dir = import_path9.default.resolve(start);
  let walkedUp = false;
  while (import_path9.default.basename(dir) === "node_modules") {
    dir = import_path9.default.dirname(dir);
    walkedUp = true;
  }
  if (walkedUp) {
    return dir;
  }
  return find(dir, dir);
}
function find(name, original) {
  if (name === "/" || process.platform === "win32" && /^[a-zA-Z]:(\\|\/)?$/.test(name)) {
    return original;
  }
  try {
    const files = import_fs2.default.readdirSync(name);
    if (files.indexOf("node_modules") !== -1 || files.indexOf("package.json") !== -1) {
      return name;
    }
    const dirname = import_path9.default.dirname(name);
    if (dirname === name) {
      return original;
    }
    return find(dirname, original);
  } catch (err) {
    if (name === original) {
      if (err.code === "ENOENT") {
        return original;
      }
      throw err;
    }
    return original;
  }
}
var import_fs2, import_path9;
var init_find_prefix = __esm({
  "libs/core/src/lib/npm-conf/find-prefix.ts"() {
    "use strict";
    import_fs2 = __toESM(require("fs"));
    import_path9 = __toESM(require("path"));
  }
});

// libs/core/src/lib/npm-conf/types.ts
var require_types = __commonJS({
  "libs/core/src/lib/npm-conf/types.ts"(exports2) {
    "use strict";
    var import_path17 = __toESM(require("path"));
    var import_stream = require("stream");
    var import_url2 = __toESM(require("url"));
    var Umask = () => {
    };
    var getLocalAddresses = () => [];
    var semver5 = () => {
    };
    exports2.types = {
      access: [null, "restricted", "public"],
      "allow-same-version": Boolean,
      "always-auth": Boolean,
      also: [null, "dev", "development"],
      audit: Boolean,
      "audit-level": ["low", "moderate", "high", "critical"],
      "auth-type": ["legacy", "sso", "saml", "oauth"],
      "bin-links": Boolean,
      browser: [null, String],
      ca: [null, String, Array],
      cafile: import_path17.default,
      cache: import_path17.default,
      "cache-lock-stale": Number,
      "cache-lock-retries": Number,
      "cache-lock-wait": Number,
      "cache-max": Number,
      "cache-min": Number,
      cert: [null, String],
      cidr: [null, String, Array],
      color: ["always", Boolean],
      depth: Number,
      description: Boolean,
      dev: Boolean,
      "dry-run": Boolean,
      editor: String,
      "engine-strict": Boolean,
      force: Boolean,
      "fetch-retries": Number,
      "fetch-retry-factor": Number,
      "fetch-retry-mintimeout": Number,
      "fetch-retry-maxtimeout": Number,
      git: String,
      "git-tag-version": Boolean,
      "commit-hooks": Boolean,
      global: Boolean,
      globalconfig: import_path17.default,
      "global-style": Boolean,
      group: [Number, String],
      "https-proxy": [null, import_url2.default],
      "user-agent": String,
      "ham-it-up": Boolean,
      heading: String,
      "if-present": Boolean,
      "ignore-prepublish": Boolean,
      "ignore-scripts": Boolean,
      "init-module": import_path17.default,
      "init-author-name": String,
      "init-author-email": String,
      "init-author-url": ["", import_url2.default],
      "init-license": String,
      "init-version": semver5,
      json: Boolean,
      key: [null, String],
      "legacy-bundling": Boolean,
      link: Boolean,
      "local-address": getLocalAddresses(),
      loglevel: ["silent", "error", "warn", "notice", "http", "timing", "info", "verbose", "silly"],
      logstream: import_stream.Stream,
      "logs-max": Number,
      long: Boolean,
      maxsockets: Number,
      message: String,
      "metrics-registry": [null, String],
      "node-options": [null, String],
      "node-version": [null, semver5],
      noproxy: [null, String, Array],
      offline: Boolean,
      "onload-script": [null, String],
      only: [null, "dev", "development", "prod", "production"],
      optional: Boolean,
      "package-lock": Boolean,
      otp: [null, String],
      "package-lock-only": Boolean,
      parseable: Boolean,
      "prefer-offline": Boolean,
      "prefer-online": Boolean,
      prefix: import_path17.default,
      preid: String,
      production: Boolean,
      progress: Boolean,
      proxy: [null, false, import_url2.default],
      "read-only": Boolean,
      "rebuild-bundle": Boolean,
      registry: [null, import_url2.default],
      rollback: Boolean,
      save: Boolean,
      "save-bundle": Boolean,
      "save-dev": Boolean,
      "save-exact": Boolean,
      "save-optional": Boolean,
      "save-prefix": String,
      "save-prod": Boolean,
      scope: String,
      "script-shell": [null, String],
      "scripts-prepend-node-path": [false, true, "auto", "warn-only"],
      searchopts: String,
      searchexclude: [null, String],
      searchlimit: Number,
      searchstaleness: Number,
      "send-metrics": Boolean,
      shell: String,
      shrinkwrap: Boolean,
      "sign-git-commit": Boolean,
      "sign-git-tag": Boolean,
      "sso-poll-frequency": Number,
      "sso-type": [null, "oauth", "saml"],
      "strict-ssl": Boolean,
      tag: String,
      timing: Boolean,
      tmp: import_path17.default,
      unicode: Boolean,
      "unsafe-perm": Boolean,
      "update-notifier": Boolean,
      usage: Boolean,
      user: [Number, String],
      userconfig: import_path17.default,
      umask: Umask,
      version: Boolean,
      "tag-version-prefix": String,
      versions: Boolean,
      viewer: String,
      _exit: Boolean
    };
  }
});

// libs/core/src/lib/npm-conf/parse-field.ts
function parseField(input, key) {
  if (typeof input !== "string") {
    return input;
  }
  const typeList = [].concat(types[key]);
  const isPath = typeList.indexOf(import_path10.default) !== -1;
  const isBool = typeList.indexOf(Boolean) !== -1;
  const isString = typeList.indexOf(String) !== -1;
  const isNumber = typeList.indexOf(Number) !== -1;
  let field = `${input}`.trim();
  if (/^".*"$/.test(field)) {
    try {
      field = JSON.parse(field);
    } catch (err) {
      throw new Error(`Failed parsing JSON config key ${key}: ${field}`);
    }
  }
  if (isBool && !isString && field === "") {
    return true;
  }
  switch (field) {
    case "true": {
      return true;
    }
    case "false": {
      return false;
    }
    case "null": {
      return null;
    }
    case "undefined": {
      return void 0;
    }
  }
  field = envReplace(field);
  if (isPath) {
    const regex = process.platform === "win32" ? /^~(\/|\\)/ : /^~\//;
    if (regex.test(field) && process.env["HOME"]) {
      field = import_path10.default.resolve(process.env["HOME"], field.substr(2));
    }
    field = import_path10.default.resolve(field);
  }
  if (isNumber && !Number.isNaN(field)) {
    field = Number(field);
  }
  return field;
}
var import_path10, types;
var init_parse_field = __esm({
  "libs/core/src/lib/npm-conf/parse-field.ts"() {
    "use strict";
    import_path10 = __toESM(require("path"));
    init_env_replace();
    ({ types } = require_types());
  }
});

// libs/core/src/lib/npm-conf/nerf-dart.ts
function toNerfDart(uri) {
  const parsed = import_url.default.parse(uri);
  delete parsed.protocol;
  delete parsed.auth;
  delete parsed.query;
  delete parsed.search;
  delete parsed.hash;
  return import_url.default.resolve(import_url.default.format(parsed), ".");
}
var import_url;
var init_nerf_dart = __esm({
  "libs/core/src/lib/npm-conf/nerf-dart.ts"() {
    "use strict";
    import_url = __toESM(require("url"));
  }
});

// libs/core/src/lib/npm-conf/conf.ts
var import_assert, import_fs3, import_path11, ConfigChain, Conf;
var init_conf = __esm({
  "libs/core/src/lib/npm-conf/conf.ts"() {
    "use strict";
    import_assert = __toESM(require("assert"));
    import_fs3 = __toESM(require("fs"));
    import_path11 = __toESM(require("path"));
    init_env_replace();
    init_find_prefix();
    init_parse_field();
    init_nerf_dart();
    ({ ConfigChain } = require("config-chain"));
    Conf = class extends ConfigChain {
      root;
      constructor(base) {
        super(base);
        this.root = base;
      }
      add(data, marker) {
        try {
          for (const x of Object.keys(data)) {
            const newKey = envReplace(x);
            const newField = parseField(data[x], newKey);
            delete data[x];
            data[newKey] = newField;
          }
        } catch (err) {
          throw err;
        }
        return super.add(data, marker);
      }
      addFile(file, name = file) {
        const marker = { __source__: name };
        this["sources"][name] = { path: file, type: "ini" };
        this["push"](marker);
        this["_await"]();
        try {
          const contents = import_fs3.default.readFileSync(file, "utf8");
          this["addString"](contents, file, "ini", marker);
        } catch (err) {
          this["add"]({}, marker);
        }
        return this;
      }
      addEnv(env = process.env) {
        const conf = {};
        Object.keys(env).filter((x) => /^npm_config_/i.test(x)).forEach((x) => {
          if (!env[x]) {
            return;
          }
          const p = x.toLowerCase().replace(/^npm_config_/, "").replace(/(?!^)_/g, "-");
          conf[p] = env[x];
        });
        return super.addEnv("", conf, "env");
      }
      loadPrefix() {
        const cli = this["list"][0];
        Object.defineProperty(this, "prefix", {
          enumerable: true,
          set: (prefix) => {
            const g = this["get"]("global");
            this[g ? "globalPrefix" : "localPrefix"] = prefix;
          },
          get: () => {
            const g = this["get"]("global");
            return g ? this["globalPrefix"] : this["localPrefix"];
          }
        });
        Object.defineProperty(this, "globalPrefix", {
          enumerable: true,
          set: (prefix) => {
            this["set"]("prefix", prefix);
          },
          get: () => import_path11.default.resolve(this["get"]("prefix"))
        });
        let p;
        Object.defineProperty(this, "localPrefix", {
          enumerable: true,
          set: (prefix) => {
            p = prefix;
          },
          get: () => p
        });
        if (Object.prototype.hasOwnProperty.call(cli, "prefix")) {
          p = import_path11.default.resolve(cli.prefix);
        } else {
          try {
            p = findPrefix(process.cwd());
          } catch (err) {
            throw err;
          }
        }
        return p;
      }
      loadCAFile(file) {
        if (!file) {
          return;
        }
        try {
          const contents = import_fs3.default.readFileSync(file, "utf8");
          const delim = "-----END CERTIFICATE-----";
          const output2 = contents.split(delim).filter((x) => Boolean(x.trim())).map((x) => x.trimLeft() + delim);
          this["set"]("ca", output2);
        } catch (err) {
          if (err.code === "ENOENT") {
            return;
          }
          throw err;
        }
      }
      loadUser() {
        const defConf = this.root;
        if (this["get"]("global")) {
          return;
        }
        if (process.env["SUDO_UID"]) {
          defConf.user = Number(process.env["SUDO_UID"]);
          return;
        }
        const prefix = import_path11.default.resolve(this["get"]("prefix"));
        try {
          const stats = import_fs3.default.statSync(prefix);
          defConf.user = stats.uid;
        } catch (err) {
          if (err.code === "ENOENT") {
            return;
          }
          throw err;
        }
      }
      getCredentialsByURI(uri) {
        (0, import_assert.default)(uri && typeof uri === "string", "registry URL is required");
        const nerfed = toNerfDart(uri);
        const defnerf = toNerfDart(this["get"]("registry"));
        const c = {
          scope: nerfed,
          token: void 0,
          password: void 0,
          username: void 0,
          email: void 0,
          auth: void 0,
          alwaysAuth: void 0
        };
        if (this["get"](`${nerfed}:always-auth`) !== void 0) {
          const val = this["get"](`${nerfed}:always-auth`);
          c.alwaysAuth = val === "false" ? false : !!val;
        } else if (this["get"]("always-auth") !== void 0) {
          c.alwaysAuth = this["get"]("always-auth");
        }
        if (this["get"](`${nerfed}:_authToken`)) {
          c.token = this["get"](`${nerfed}:_authToken`);
          return c;
        }
        let authDef = this["get"]("_auth");
        let userDef = this["get"]("username");
        let passDef = this["get"]("_password");
        if (authDef && !(userDef && passDef)) {
          authDef = Buffer.from(authDef, "base64").toString();
          authDef = authDef.split(":");
          userDef = authDef.shift();
          passDef = authDef.join(":");
        }
        if (this["get"](`${nerfed}:_password`)) {
          c.password = Buffer.from(this["get"](`${nerfed}:_password`), "base64").toString("utf8");
        } else if (nerfed === defnerf && passDef) {
          c.password = passDef;
        }
        if (this["get"](`${nerfed}:username`)) {
          c.username = this["get"](`${nerfed}:username`);
        } else if (nerfed === defnerf && userDef) {
          c.username = userDef;
        }
        if (this["get"](`${nerfed}:email`)) {
          c.email = this["get"](`${nerfed}:email`);
        } else if (this["get"]("email")) {
          c.email = this["get"]("email");
        }
        if (c.username && c.password) {
          c.auth = Buffer.from(`${c.username}:${c.password}`).toString("base64");
        }
        return c;
      }
      setCredentialsByURI(uri, c) {
        (0, import_assert.default)(uri && typeof uri === "string", "registry URL is required");
        (0, import_assert.default)(c && typeof c === "object", "credentials are required");
        const nerfed = toNerfDart(uri);
        if (c.token) {
          this["set"](`${nerfed}:_authToken`, c.token, "user");
          this["del"](`${nerfed}:_password`, "user");
          this["del"](`${nerfed}:username`, "user");
          this["del"](`${nerfed}:email`, "user");
          this["del"](`${nerfed}:always-auth`, "user");
        } else if (c.username || c.password || c.email) {
          (0, import_assert.default)(c.username, "must include username");
          (0, import_assert.default)(c.password, "must include password");
          (0, import_assert.default)(c.email, "must include email address");
          this["del"](`${nerfed}:_authToken`, "user");
          const encoded = Buffer.from(c.password, "utf8").toString("base64");
          this["set"](`${nerfed}:_password`, encoded, "user");
          this["set"](`${nerfed}:username`, c.username, "user");
          this["set"](`${nerfed}:email`, c.email, "user");
          if (c.alwaysAuth !== void 0) {
            this["set"](`${nerfed}:always-auth`, c.alwaysAuth, "user");
          } else {
            this["del"](`${nerfed}:always-auth`, "user");
          }
        } else {
          throw new Error("No credentials to set.");
        }
      }
    };
  }
});

// libs/core/src/lib/npm-conf/defaults.ts
var require_defaults = __commonJS({
  "libs/core/src/lib/npm-conf/defaults.ts"(exports2) {
    "use strict";
    var import_os3 = __toESM(require("os"));
    var import_path17 = __toESM(require("path"));
    var temp = import_os3.default.tmpdir();
    var uidOrPid = process.getuid ? process.getuid() : process.pid;
    var hasUnicode2 = () => true;
    var isWindows = process.platform === "win32";
    var osenv = {
      editor: () => process.env["EDITOR"] || process.env["VISUAL"] || (isWindows ? "notepad.exe" : "vi"),
      shell: () => isWindows ? process.env["COMSPEC"] || "cmd.exe" : process.env["SHELL"] || "/bin/bash"
    };
    var umask = {
      fromString: () => process.umask()
    };
    var home = import_os3.default.homedir();
    if (home) {
      process.env["HOME"] = home;
    } else {
      home = import_path17.default.resolve(temp, `npm-${uidOrPid}`);
    }
    var cacheExtra = process.platform === "win32" ? "npm-cache" : ".npm";
    var cacheRoot = process.platform === "win32" && process.env["APPDATA"] || home;
    var cache = import_path17.default.resolve(cacheRoot, cacheExtra);
    var defaults;
    var globalPrefix;
    Object.defineProperty(exports2, "defaults", {
      get() {
        if (defaults) {
          return defaults;
        }
        if (process.env["PREFIX"]) {
          globalPrefix = process.env["PREFIX"];
        } else if (process.platform === "win32") {
          globalPrefix = import_path17.default.dirname(process.execPath);
        } else {
          globalPrefix = import_path17.default.dirname(import_path17.default.dirname(process.execPath));
          if (process.env["DESTDIR"]) {
            globalPrefix = import_path17.default.join(process.env["DESTDIR"], globalPrefix);
          }
        }
        defaults = {
          access: null,
          "allow-same-version": false,
          "always-auth": false,
          also: null,
          audit: true,
          "audit-level": "low",
          "auth-type": "legacy",
          "bin-links": true,
          browser: null,
          ca: null,
          cafile: null,
          cache,
          "cache-lock-stale": 6e4,
          "cache-lock-retries": 10,
          "cache-lock-wait": 1e4,
          "cache-max": Infinity,
          "cache-min": 10,
          cert: null,
          cidr: null,
          color: process.env["NO_COLOR"] == null,
          depth: Infinity,
          description: true,
          dev: false,
          "dry-run": false,
          editor: osenv.editor(),
          "engine-strict": false,
          force: false,
          "fetch-retries": 2,
          "fetch-retry-factor": 10,
          "fetch-retry-mintimeout": 1e4,
          "fetch-retry-maxtimeout": 6e4,
          git: "git",
          "git-tag-version": true,
          "commit-hooks": true,
          global: false,
          globalconfig: import_path17.default.resolve(globalPrefix, "etc", "npmrc"),
          "global-style": false,
          group: process.platform === "win32" ? 0 : process.env["SUDO_GID"] || process.getgid && process.getgid(),
          "ham-it-up": false,
          heading: "npm",
          "if-present": false,
          "ignore-prepublish": false,
          "ignore-scripts": false,
          "init-module": import_path17.default.resolve(home, ".npm-init.js"),
          "init-author-name": "",
          "init-author-email": "",
          "init-author-url": "",
          "init-version": "1.0.0",
          "init-license": "ISC",
          json: false,
          key: null,
          "legacy-bundling": false,
          link: false,
          "local-address": void 0,
          loglevel: "notice",
          logstream: process.stderr,
          "logs-max": 10,
          long: false,
          maxsockets: 50,
          message: "%s",
          "metrics-registry": null,
          "node-options": null,
          "node-version": process.version,
          offline: false,
          "onload-script": false,
          only: null,
          optional: true,
          otp: void 0,
          "package-lock": true,
          "package-lock-only": false,
          parseable: false,
          "prefer-offline": false,
          "prefer-online": false,
          prefix: globalPrefix,
          preid: "",
          production: process.env["NODE_ENV"] === "production",
          progress: !process.env["TRAVIS"] && !process.env["CI"],
          proxy: null,
          "https-proxy": null,
          noproxy: null,
          "user-agent": "npm/{npm-version} node/{node-version} {platform} {arch}",
          "read-only": false,
          "rebuild-bundle": true,
          registry: "https://registry.npmjs.org/",
          rollback: true,
          save: true,
          "save-bundle": false,
          "save-dev": false,
          "save-exact": false,
          "save-optional": false,
          "save-prefix": "^",
          "save-prod": false,
          scope: "",
          "script-shell": void 0,
          "scripts-prepend-node-path": "warn-only",
          searchopts: "",
          searchexclude: null,
          searchlimit: 20,
          searchstaleness: 15 * 60,
          "send-metrics": false,
          shell: osenv.shell(),
          shrinkwrap: true,
          "sign-git-commit": false,
          "sign-git-tag": false,
          "sso-poll-frequency": 500,
          "sso-type": "oauth",
          "strict-ssl": true,
          tag: "latest",
          "tag-version-prefix": "v",
          timing: false,
          tmp: temp,
          unicode: hasUnicode2(),
          "unsafe-perm": process.platform === "win32" || process.platform === "cygwin" || !(process.getuid && process.setuid && process.getgid && process.setgid) || process.getuid() !== 0,
          "update-notifier": true,
          usage: false,
          user: process.platform === "win32" || import_os3.default.type() === "OS400" ? 0 : "nobody",
          userconfig: import_path17.default.resolve(home, ".npmrc"),
          umask: process.umask ? process.umask() : umask.fromString("022"),
          version: false,
          versions: false,
          viewer: process.platform === "win32" ? "browser" : "man",
          _exit: true
        };
        return defaults;
      }
    });
  }
});

// libs/core/src/lib/npm-conf/index.ts
var require_npm_conf = __commonJS({
  "libs/core/src/lib/npm-conf/index.ts"(exports2, module2) {
    "use strict";
    var import_path17 = __toESM(require("path"));
    init_conf();
    init_nerf_dart();
    var { defaults } = require_defaults();
    module2.exports = npmConf3;
    module2.exports.Conf = Conf;
    module2.exports.defaults = Object.assign({}, defaults);
    module2.exports.toNerfDart = toNerfDart;
    function npmConf3(opts) {
      const conf = new Conf(Object.assign({}, defaults));
      const cleanOpts = opts ? Object.keys(opts).reduce((acc, key) => {
        if (opts[key] !== void 0) {
          acc[key] = opts[key];
        }
        return acc;
      }, {}) : {};
      conf.add(cleanOpts, "cli");
      conf.addEnv();
      conf.loadPrefix();
      const projectConf = import_path17.default.resolve(conf["localPrefix"], ".npmrc");
      const userConf = conf["get"]("userconfig");
      if (!conf["get"]("global") && projectConf !== userConf) {
        conf.addFile(projectConf, "project");
      } else {
        conf.add({}, "project");
      }
      conf.addFile(conf["get"]("userconfig"), "user");
      if (conf["get"]("prefix")) {
        const etc = import_path17.default.resolve(conf["get"]("prefix"), "etc");
        conf.root.globalconfig = import_path17.default.resolve(etc, "npmrc");
        conf.root.globalignorefile = import_path17.default.resolve(etc, "npmignore");
      }
      conf.addFile(conf["get"]("globalconfig"), "global");
      conf.loadUser();
      const caFile = conf["get"]("cafile");
      if (caFile) {
        conf.loadCAFile(caFile);
      }
      return conf;
    }
  }
});

// libs/core/src/lib/run-lifecycle.ts
function flattenOptions(obj) {
  return {
    ignorePrepublish: obj["ignore-prepublish"],
    ignoreScripts: obj["ignore-scripts"],
    nodeOptions: obj["node-options"],
    scriptShell: obj["script-shell"],
    scriptsPrependNodePath: obj["scripts-prepend-node-path"],
    unsafePerm: obj["unsafe-perm"],
    ...obj
  };
}
function printCommandBanner(id, event, cmd, path17) {
  return console.log(`
> ${id ? `${id} ` : ""}${event} ${path17}
> ${cmd.trim().replace(/\n/g, "\n> ")}
`);
}
function runLifecycle(pkg, stage, options) {
  if ("root" in options) {
    options = options.snapshot;
  }
  const opts = {
    log: import_npmlog25.default,
    unsafePerm: true,
    ...flattenOptions(options)
  };
  const dir = pkg.location;
  const id = `${pkg.name}@${pkg.version}`;
  const config = {};
  if (opts.ignoreScripts) {
    opts.log.verbose("lifecycle", "%j ignored in %j", stage, pkg.name);
    return Promise.resolve();
  }
  if (!pkg.scripts || !pkg.scripts[stage]) {
    opts.log.silly("lifecycle", "No script for %j in %j, continuing", stage, pkg.name);
    return Promise.resolve();
  }
  if (stage === "prepublish" && opts.ignorePrepublish) {
    opts.log.verbose("lifecycle", "%j ignored in %j", stage, pkg.name);
    return Promise.resolve();
  }
  for (const [key, val] of Object.entries(opts)) {
    if (val != null && key !== "log" && key !== "logstream") {
      config[key] = val;
    }
  }
  if (pkg.__isLernaPackage) {
    pkg = pkg.toJSON();
  }
  pkg._id = id;
  opts.log.silly("lifecycle", "%j starting in %j", stage, pkg.name);
  opts.log.info("lifecycle", `${id}~${stage}: ${id}`);
  const stdio = opts.stdio || "pipe";
  if (import_npmlog25.default.level !== "silent") {
    printCommandBanner(id, stage, pkg.scripts[stage], dir);
  }
  return queue.add(
    async () => runScript({
      event: stage,
      path: dir,
      pkg,
      args: [],
      stdio,
      banner: false,
      scriptShell: config.scriptShell
    }).then(
      ({ stdout }) => {
        if (stdout) {
          console.log(stdout.toString().trimEnd());
        }
        opts.log.silly("lifecycle", "%j finished in %j", stage, pkg.name);
      },
      (err) => {
        const exitCode = err.code || 1;
        import_npmlog25.default.error("lifecycle", "%j errored in %j, exiting %d", stage, pkg.name, exitCode);
        err.name = "ValidationError";
        err.exitCode = exitCode;
        process.exitCode = exitCode;
        throw err;
      }
    )
  );
}
function createRunner(commandOptions) {
  const cfg = npmConf(commandOptions).snapshot;
  return (pkg, stage) => runLifecycle(pkg, stage, cfg);
}
var import_npmlog25, import_p_queue, runScript, npmConf, queue;
var init_run_lifecycle = __esm({
  "libs/core/src/lib/run-lifecycle.ts"() {
    "use strict";
    import_npmlog25 = __toESM(require("npmlog"));
    import_p_queue = __toESM(require("p-queue"));
    runScript = require("@npmcli/run-script");
    npmConf = require_npm_conf();
    queue = new import_p_queue.default({ concurrency: 1 });
  }
});

// libs/core/src/lib/npm-publish.ts
function flattenOptions2(obj) {
  return {
    defaultTag: obj["tag"] || "latest",
    dryRun: obj["dry-run"],
    strictSSL: obj["strict-ssl"],
    ...obj
  };
}
function npmPublish(pkg, tarFilePath, options = {}, otpCache) {
  const { dryRun, ...remainingOptions } = flattenOptions2(options);
  const { scope } = (0, import_npm_package_arg5.default)(pkg.name);
  const opts = {
    log: import_npmlog26.default,
    ...remainingOptions,
    projectScope: scope
  };
  opts.log.verbose("publish", pkg.name);
  let chain = Promise.resolve();
  if (!dryRun) {
    chain = chain.then(() => {
      let { manifestLocation } = pkg;
      if (pkg.contents !== pkg.location) {
        manifestLocation = import_path12.default.join(pkg.contents, "package.json");
      }
      return Promise.all([import_fs_extra5.default.readFile(tarFilePath), readJSONAsync(manifestLocation)]);
    });
    chain = chain.then(([tarData, manifest]) => {
      if (opts.defaultTag !== "latest" && manifest.publishConfig && manifest.publishConfig.tag && manifest.publishConfig.tag !== opts.defaultTag) {
        manifest.publishConfig.tag = opts.defaultTag;
      }
      if (manifest.publishConfig) {
        Object.assign(opts, publishConfigToOpts(manifest.publishConfig));
      }
      return otplease((innerOpts) => (0, import_libnpmpublish.publish)(manifest, tarData, innerOpts), opts, otpCache);
    });
  }
  chain = chain.then(() => runLifecycle(pkg, "publish", opts));
  chain = chain.then(() => runLifecycle(pkg, "postpublish", opts));
  return chain;
}
function publishConfigToOpts(publishConfig) {
  const opts = { ...publishConfig };
  if (publishConfig.tag) {
    opts.defaultTag = publishConfig.tag;
    delete opts.tag;
  }
  return opts;
}
var import_fs_extra5, import_libnpmpublish, import_npm_package_arg5, import_npmlog26, import_path12, import_pify2, readJSON, readJSONAsync;
var init_npm_publish = __esm({
  "libs/core/src/lib/npm-publish.ts"() {
    "use strict";
    import_fs_extra5 = __toESM(require("fs-extra"));
    import_libnpmpublish = require("libnpmpublish");
    import_npm_package_arg5 = __toESM(require("npm-package-arg"));
    import_npmlog26 = __toESM(require("npmlog"));
    import_path12 = __toESM(require("path"));
    import_pify2 = __toESM(require("pify"));
    init_otplease();
    init_run_lifecycle();
    readJSON = require("read-package-json");
    readJSONAsync = (0, import_pify2.default)(readJSON);
  }
});

// libs/core/src/lib/npm-run-script.ts
var import_npmlog27, childProcess8;
var init_npm_run_script = __esm({
  "libs/core/src/lib/npm-run-script.ts"() {
    "use strict";
    import_npmlog27 = __toESM(require("npmlog"));
    init_get_npm_exec_opts();
    childProcess8 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/output.ts
function output(...args) {
  import_npmlog28.default["clearProgress"]();
  console.log(...args);
  import_npmlog28.default["showProgress"]();
}
var import_npmlog28;
var init_output = __esm({
  "libs/core/src/lib/output.ts"() {
    "use strict";
    import_npmlog28 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/temp-write.ts
async function tempWrite(fileContent, filePath) {
  const tempPath = tempfile(filePath);
  const write = (0, import_is_stream.default)(fileContent) ? writeStream : writeFileP;
  await (0, import_make_dir.default)(import_path13.default.dirname(tempPath));
  await write(tempPath, fileContent);
  return tempPath;
}
var import_graceful_fs, import_is_stream, import_make_dir, import_path13, import_temp_dir, import_util, uuid, writeFileP, tempfile, writeStream, temp_write_default;
var init_temp_write = __esm({
  "libs/core/src/lib/temp-write.ts"() {
    "use strict";
    import_graceful_fs = __toESM(require("graceful-fs"));
    import_is_stream = __toESM(require("is-stream"));
    import_make_dir = __toESM(require("make-dir"));
    import_path13 = __toESM(require("path"));
    import_temp_dir = __toESM(require("temp-dir"));
    import_util = require("util");
    uuid = __toESM(require("uuid"));
    writeFileP = (0, import_util.promisify)(import_graceful_fs.default.writeFile);
    tempfile = (filePath) => import_path13.default.join(import_temp_dir.default, uuid.v4(), filePath || "");
    writeStream = async (filePath, fileContent) => new Promise((resolve, reject) => {
      const writable = import_graceful_fs.default.createWriteStream(filePath);
      fileContent.on("error", (error) => {
        reject(error);
        fileContent.unpipe(writable);
        writable.end();
      }).pipe(writable).on("error", reject).on("finish", resolve);
    });
    tempWrite.sync = (fileContent, filePath) => {
      const tempPath = tempfile(filePath);
      import_make_dir.default.sync(import_path13.default.dirname(tempPath));
      import_graceful_fs.default.writeFileSync(tempPath, fileContent);
      return tempPath;
    };
    temp_write_default = tempWrite;
  }
});

// libs/core/src/lib/get-packed.ts
function getPacked(pkg, tarFilePath) {
  const bundledWanted = new Set(pkg.bundleDependencies || pkg.bundledDependencies || []);
  const bundled = /* @__PURE__ */ new Set();
  const files = [];
  let totalEntries = 0;
  let totalEntrySize = 0;
  return import_tar.default.list({
    file: tarFilePath,
    onentry(entry) {
      totalEntries += 1;
      totalEntrySize += entry.size;
      const p = entry.path;
      if (p.startsWith("package/node_modules/")) {
        const name = p.match(/^package\/node_modules\/((?:@[^/]+\/)?[^/]+)/)[1];
        if (bundledWanted.has(name)) {
          bundled.add(name);
        }
      } else {
        files.push({
          path: entry.path.replace(/^package\//, ""),
          size: entry.size,
          mode: entry.mode
        });
      }
    },
    strip: 1
  }).then(
    () => Promise.all([
      import_fs_extra6.default.stat(tarFilePath),
      import_ssri.default.fromStream(import_fs_extra6.default.createReadStream(tarFilePath), {
        algorithms: ["sha1", "sha512"]
      })
    ])
  ).then(([{ size }, { sha1, sha512 }]) => {
    const shasum = sha1[0].hexDigest();
    return {
      id: `${pkg.name}@${pkg.version}`,
      name: pkg.name,
      version: pkg.version,
      size,
      unpackedSize: totalEntrySize,
      shasum,
      integrity: import_ssri.default.parse(sha512[0]),
      filename: import_path14.default.basename(tarFilePath),
      files,
      entryCount: totalEntries,
      bundled: Array.from(bundled),
      tarFilePath
    };
  });
}
var import_fs_extra6, import_path14, import_ssri, import_tar;
var init_get_packed = __esm({
  "libs/core/src/lib/get-packed.ts"() {
    "use strict";
    import_fs_extra6 = __toESM(require("fs-extra"));
    import_path14 = __toESM(require("path"));
    import_ssri = __toESM(require("ssri"));
    import_tar = __toESM(require("tar"));
  }
});

// libs/core/src/lib/pack-directory.ts
function packDirectory(_pkg, dir, options) {
  const pkg = Package.lazy(_pkg, dir);
  const opts = {
    log: import_npmlog29.default,
    ...options
  };
  opts.log.verbose("pack-directory", import_path15.default.relative(".", pkg.contents));
  let chain = Promise.resolve();
  if (opts.ignorePrepublish !== true) {
    chain = chain.then(() => runLifecycle(pkg, "prepublish", opts));
  }
  chain = chain.then(() => runLifecycle(pkg, "prepare", opts));
  if (opts.lernaCommand === "publish") {
    opts.stdio = "inherit";
    chain = chain.then(() => pkg.refresh());
    chain = chain.then(() => runLifecycle(pkg, "prepublishOnly", opts));
    chain = chain.then(() => pkg.refresh());
  }
  chain = chain.then(() => runLifecycle(pkg, "prepack", opts));
  chain = chain.then(() => pkg.refresh());
  chain = chain.then(() => (0, import_npm_packlist.default)({ path: pkg.contents }));
  chain = chain.then(
    (files) => import_tar2.default.create(
      {
        cwd: pkg.contents,
        prefix: "package/",
        portable: true,
        mtime: new Date("1985-10-26T08:15:00.000Z"),
        gzip: true
      },
      files.map((f) => `./${f}`)
    )
  );
  chain = chain.then((stream) => temp_write_default(stream, getTarballName(pkg)));
  chain = chain.then(
    (tarFilePath) => getPacked(pkg, tarFilePath).then(
      (packed) => Promise.resolve().then(() => runLifecycle(pkg, "postpack", opts)).then(() => packed)
    )
  );
  return chain;
}
function getTarballName(pkg) {
  const name = pkg.name[0] === "@" ? pkg.name.substr(1).replace(/\//g, "-") : pkg.name;
  return `${name}-${pkg.version}.tgz`;
}
var import_path15, import_npm_packlist, import_npmlog29, import_tar2;
var init_pack_directory = __esm({
  "libs/core/src/lib/pack-directory.ts"() {
    "use strict";
    import_path15 = __toESM(require("path"));
    import_npm_packlist = __toESM(require("npm-packlist"));
    import_npmlog29 = __toESM(require("npmlog"));
    import_tar2 = __toESM(require("tar"));
    init_temp_write();
    init_get_packed();
    init_package();
    init_run_lifecycle();
  }
});

// libs/core/src/lib/profiler.ts
var import_fs_extra7, import_npmlog30, import_upath;
var init_profiler = __esm({
  "libs/core/src/lib/profiler.ts"() {
    "use strict";
    import_fs_extra7 = __toESM(require("fs-extra"));
    import_npmlog30 = __toESM(require("npmlog"));
    import_upath = __toESM(require("upath"));
  }
});

// libs/core/src/lib/pulse-till-done.ts
function pulseStart(prefix) {
  pulsers += 1;
  if (pulsers > 1) {
    return;
  }
  pulse = setInterval(() => import_npmlog31.default["gauge"].pulse(prefix), 150);
}
function pulseStop() {
  pulsers -= 1;
  if (pulsers > 0) {
    return;
  }
  clearInterval(pulse);
}
function pulseTillDone(prefix, promise) {
  if (!promise) {
    promise = prefix;
    prefix = "";
  }
  pulseStart(prefix);
  return Promise.resolve(promise).then(
    (val) => {
      pulseStop();
      return val;
    },
    (err) => {
      pulseStop();
      throw err;
    }
  );
}
var import_npmlog31, pulsers, pulse;
var init_pulse_till_done = __esm({
  "libs/core/src/lib/pulse-till-done.ts"() {
    "use strict";
    import_npmlog31 = __toESM(require("npmlog"));
    pulsers = 0;
  }
});

// libs/core/src/lib/rimraf-dir.ts
var import_npmlog32, import_path_exists, childProcess9, RIMRAF_CLI;
var init_rimraf_dir = __esm({
  "libs/core/src/lib/rimraf-dir.ts"() {
    "use strict";
    import_npmlog32 = __toESM(require("npmlog"));
    import_path_exists = __toESM(require("path-exists"));
    childProcess9 = require("@lerna/child-process");
    RIMRAF_CLI = require.resolve("rimraf/bin");
  }
});

// libs/core/src/lib/run-topologically.ts
function runTopologically(packages, runner, { concurrency, graphType, rejectCycles } = {}) {
  const queue2 = new import_p_queue2.default({ concurrency });
  const graph = new QueryGraph(packages, { graphType, rejectCycles });
  return new Promise((resolve, reject) => {
    const returnValues = [];
    const queueNextAvailablePackages = () => graph.getAvailablePackages().forEach(({ pkg, name }) => {
      graph.markAsTaken(name);
      queue2.add(
        () => runner(pkg).then((value) => returnValues.push(value)).then(() => graph.markAsDone(pkg)).then(() => queueNextAvailablePackages())
      ).catch(reject);
    });
    queueNextAvailablePackages();
    queue2.onIdle().then(() => resolve(returnValues));
  });
}
var import_p_queue2;
var init_run_topologically = __esm({
  "libs/core/src/lib/run-topologically.ts"() {
    "use strict";
    import_p_queue2 = __toESM(require("p-queue"));
    init_query_graph();
  }
});

// libs/core/src/lib/scm-clients/github/create-github-client.ts
function createGitHubClient() {
  import_npmlog33.default.silly("createGitHubClient");
  const { GH_TOKEN, GHE_API_URL, GHE_VERSION } = process.env;
  if (!GH_TOKEN) {
    throw new Error("A GH_TOKEN environment variable is required.");
  }
  if (GHE_VERSION) {
    import_rest.Octokit.plugin(require(`@octokit/plugin-enterprise-rest/ghe-${GHE_VERSION}`));
  }
  const options = {
    auth: `token ${GH_TOKEN}`
  };
  if (GHE_API_URL) {
    options.baseUrl = GHE_API_URL;
  }
  return new import_rest.Octokit(options);
}
function parseGitRepo(remote = "origin", opts) {
  import_npmlog33.default.silly("parseGitRepo");
  const args = ["config", "--get", `remote.${remote}.url`];
  import_npmlog33.default.verbose("git", args);
  const url2 = childProcess10.execSync("git", args, opts);
  if (!url2) {
    throw new Error(`Git remote URL could not be found using "${remote}".`);
  }
  return (0, import_git_url_parse.default)(url2);
}
var import_npmlog33, import_rest, import_git_url_parse, childProcess10;
var init_create_github_client = __esm({
  "libs/core/src/lib/scm-clients/github/create-github-client.ts"() {
    "use strict";
    import_npmlog33 = __toESM(require("npmlog"));
    import_rest = require("@octokit/rest");
    import_git_url_parse = __toESM(require("git-url-parse"));
    childProcess10 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/scm-clients/gitlab/gitlab-client.ts
var import_node_fetch, import_npmlog34, import_path16, GitLabClient;
var init_gitlab_client = __esm({
  "libs/core/src/lib/scm-clients/gitlab/gitlab-client.ts"() {
    "use strict";
    import_node_fetch = __toESM(require("node-fetch"));
    import_npmlog34 = __toESM(require("npmlog"));
    import_path16 = __toESM(require("path"));
    GitLabClient = class {
      constructor(token, baseUrl = "https://gitlab.com/api/v4") {
        this.token = token;
        this.baseUrl = baseUrl;
      }
      createRelease({ owner, repo, name, tag_name: tagName, body }) {
        const releasesUrl = this.releasesUrl(owner, repo, "releases");
        import_npmlog34.default.silly("Requesting GitLab releases", releasesUrl);
        return (0, import_node_fetch.default)(releasesUrl, {
          method: "post",
          body: JSON.stringify({ name, tag_name: tagName, description: body }),
          headers: {
            "PRIVATE-TOKEN": this.token,
            "Content-Type": "application/json"
          }
        }).then(({ ok, status, statusText }) => {
          if (!ok) {
            import_npmlog34.default.error("gitlab", `Failed to create release
Request returned ${status} ${statusText}`);
          } else {
            import_npmlog34.default.silly("gitlab", "Created release successfully.");
          }
        });
      }
      releasesUrl(namespace, project) {
        return new URL(
          `${this.baseUrl}/${import_path16.default.join("projects", encodeURIComponent(`${namespace}/${project}`), "releases")}`
        ).toString();
      }
    };
  }
});

// libs/core/src/lib/scm-clients/gitlab/create-gitlab-client.ts
function OcktokitAdapter(client) {
  return { repos: { createRelease: client.createRelease.bind(client) } };
}
function createGitLabClient() {
  const { GL_API_URL, GL_TOKEN } = process.env;
  import_npmlog35.default.silly("Creating a GitLab client...");
  if (!GL_TOKEN) {
    throw new Error("A GL_TOKEN environment variable is required.");
  }
  const client = new GitLabClient(GL_TOKEN, GL_API_URL);
  return OcktokitAdapter(client);
}
var import_npmlog35;
var init_create_gitlab_client = __esm({
  "libs/core/src/lib/scm-clients/gitlab/create-gitlab-client.ts"() {
    "use strict";
    import_npmlog35 = __toESM(require("npmlog"));
    init_gitlab_client();
  }
});

// libs/core/src/lib/scm-clients/index.ts
var init_scm_clients = __esm({
  "libs/core/src/lib/scm-clients/index.ts"() {
    "use strict";
    init_create_github_client();
    init_create_gitlab_client();
  }
});

// libs/core/src/lib/symlink-binary/index.ts
var import_fs_extra8, import_p_map3;
var init_symlink_binary = __esm({
  "libs/core/src/lib/symlink-binary/index.ts"() {
    "use strict";
    import_fs_extra8 = __toESM(require("fs-extra"));
    import_p_map3 = __toESM(require("p-map"));
    init_create_symlink();
    init_package();
  }
});

// libs/core/src/lib/resolve-symlink.ts
var import_fs_extra9, import_npmlog36, readCmdShim;
var init_resolve_symlink = __esm({
  "libs/core/src/lib/resolve-symlink.ts"() {
    "use strict";
    import_fs_extra9 = __toESM(require("fs-extra"));
    import_npmlog36 = __toESM(require("npmlog"));
    readCmdShim = require("read-cmd-shim");
  }
});

// libs/core/src/lib/symlink-dependencies.ts
var import_fs_extra10, import_p_map4, import_p_map_series;
var init_symlink_dependencies = __esm({
  "libs/core/src/lib/symlink-dependencies.ts"() {
    "use strict";
    import_fs_extra10 = __toESM(require("fs-extra"));
    import_p_map4 = __toESM(require("p-map"));
    import_p_map_series = __toESM(require("p-map-series"));
    init_create_symlink();
    init_resolve_symlink();
    init_symlink_binary();
  }
});

// libs/core/src/lib/timer.ts
var init_timer = __esm({
  "libs/core/src/lib/timer.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/npm-dist-tag.ts
var npm_dist_tag_exports = {};
__export(npm_dist_tag_exports, {
  add: () => add,
  list: () => list,
  remove: () => remove
});
function add(spec, tag, options, otpCache) {
  const opts = {
    log: import_npmlog37.default,
    ...options,
    spec: (0, import_npm_package_arg6.default)(spec)
  };
  const cleanTag = (tag || opts.defaultTag || opts.tag).trim();
  const { name, rawSpec: version } = opts.spec;
  opts.log.verbose("dist-tag", `adding "${cleanTag}" to ${name}@${version}`);
  if (opts.dryRun) {
    opts.log.silly("dist-tag", "dry-run configured, bailing now");
    return Promise.resolve();
  }
  return fetchTags(opts).then((tags) => {
    if (tags[cleanTag] === version) {
      opts.log.warn("dist-tag", `${name}@${cleanTag} already set to ${version}`);
      return tags;
    }
    const uri = `/-/package/${opts.spec.escapedName}/dist-tags/${encodeURIComponent(cleanTag)}`;
    const payload = {
      ...opts,
      method: "PUT",
      body: JSON.stringify(version),
      headers: {
        "content-type": "application/json"
      },
      spec: opts.spec
    };
    return otplease((wrappedPayload) => (0, import_npm_registry_fetch.default)(uri, wrappedPayload), payload, otpCache).then(() => {
      opts.log.verbose("dist-tag", `added "${cleanTag}" to ${name}@${version}`);
      tags[cleanTag] = version;
      return tags;
    });
  });
}
function remove(spec, tag, options, otpCache) {
  const opts = {
    log: import_npmlog37.default,
    ...options,
    spec: (0, import_npm_package_arg6.default)(spec)
  };
  opts.log.verbose("dist-tag", `removing "${tag}" from ${opts.spec.name}`);
  if (opts.dryRun) {
    opts.log.silly("dist-tag", "dry-run configured, bailing now");
    return Promise.resolve();
  }
  return fetchTags(opts).then((tags) => {
    const version = tags[tag];
    if (!version) {
      opts.log.info("dist-tag", `"${tag}" is not a dist-tag on ${opts.spec.name}`);
      return tags;
    }
    const uri = `/-/package/${opts.spec.escapedName}/dist-tags/${encodeURIComponent(tag)}`;
    const payload = {
      ...opts,
      method: "DELETE",
      spec: opts.spec
    };
    return otplease((wrappedPayload) => (0, import_npm_registry_fetch.default)(uri, wrappedPayload), payload, otpCache).then(() => {
      opts.log.verbose("dist-tag", `removed "${tag}" from ${opts.spec.name}@${version}`);
      delete tags[tag];
      return tags;
    });
  });
}
function list(spec, options) {
  const opts = {
    log: import_npmlog37.default,
    ...options,
    spec: (0, import_npm_package_arg6.default)(spec)
  };
  if (opts.dryRun) {
    opts.log.silly("dist-tag", "dry-run configured, bailing now");
    return Promise.resolve();
  }
  return fetchTags(opts);
}
function fetchTags(opts) {
  return import_npm_registry_fetch.default.json(`/-/package/${opts.spec.escapedName}/dist-tags`, {
    ...opts,
    preferOnline: true,
    spec: opts.spec
  }).then((data) => {
    if (data && typeof data === "object") {
      delete data["_etag"];
    }
    return data || {};
  });
}
var import_npm_package_arg6, import_npm_registry_fetch, import_npmlog37;
var init_npm_dist_tag = __esm({
  "libs/core/src/lib/npm-dist-tag.ts"() {
    "use strict";
    import_npm_package_arg6 = __toESM(require("npm-package-arg"));
    import_npm_registry_fetch = __toESM(require("npm-registry-fetch"));
    import_npmlog37 = __toESM(require("npmlog"));
    init_otplease();
  }
});

// libs/core/src/index.ts
var npmConf2, npmDistTag;
var init_src = __esm({
  "libs/core/src/index.ts"() {
    "use strict";
    init_check_working_tree();
    init_cli();
    init_collect_updates();
    init_command();
    init_conventional_commits();
    init_create_symlink();
    init_describe_ref();
    init_filter_options();
    init_has_npm_version();
    init_listable_format();
    init_listable_options();
    init_log_packed();
    init_npm_install();
    init_npm_publish();
    init_npm_run_script();
    init_otplease();
    init_output();
    init_pack_directory();
    init_package();
    init_package_graph();
    init_prerelease_id_from_version();
    init_profiler();
    init_project();
    init_prompt();
    init_pulse_till_done();
    init_rimraf_dir();
    init_run_lifecycle();
    init_run_topologically();
    init_scm_clients();
    init_symlink_binary();
    init_symlink_dependencies();
    init_temp_write();
    init_timer();
    init_validation_error();
    npmConf2 = require_npm_conf();
    npmDistTag = (init_npm_dist_tag(), __toCommonJS(npm_dist_tag_exports));
  }
});

// libs/commands/version/src/lib/get-current-branch.ts
var require_get_current_branch = __commonJS({
  "libs/commands/version/src/lib/get-current-branch.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var childProcess11 = require("@lerna/child-process");
    module2.exports.getCurrentBranch = getCurrentBranch;
    function getCurrentBranch(opts) {
      import_npmlog38.default.silly("getCurrentBranch");
      const branch = childProcess11.execSync("git", ["rev-parse", "--abbrev-ref", "HEAD"], opts);
      import_npmlog38.default.verbose("currentBranch", branch);
      return branch;
    }
  }
});

// libs/commands/version/src/lib/git-add.ts
var require_git_add = __commonJS({
  "libs/commands/version/src/lib/git-add.ts"(exports2, module2) {
    "use strict";
    var import_devkit2 = require("@nrwl/devkit");
    var import_fs4 = __toESM(require("fs"));
    var import_npmlog38 = __toESM(require("npmlog"));
    var import_path17 = __toESM(require("path"));
    var import_slash2 = __toESM(require("slash"));
    var childProcess11 = require("@lerna/child-process");
    module2.exports.gitAdd = gitAdd;
    var resolvedPrettier;
    function resolvePrettier() {
      if (!resolvedPrettier) {
        try {
          const packageJson = (0, import_devkit2.readJsonFile)(import_path17.default.join(import_devkit2.workspaceRoot, "package.json"));
          const hasPrettier = packageJson.devDependencies?.prettier || packageJson.dependencies?.prettier;
          if (!hasPrettier) {
            return;
          }
          const prettierPath = import_path17.default.join(import_devkit2.workspaceRoot, "node_modules", "prettier");
          resolvedPrettier = require(prettierPath);
        } catch {
          return;
        }
      }
      return resolvedPrettier;
    }
    function maybeFormatFile(filePath) {
      const prettier = resolvePrettier();
      if (!prettier) {
        return;
      }
      const config = resolvedPrettier.resolveConfig.sync(filePath);
      const ignorePath = import_path17.default.join(import_devkit2.workspaceRoot, ".prettierignore");
      const fullFilePath = import_path17.default.join(import_devkit2.workspaceRoot, filePath);
      if (resolvedPrettier.getFileInfo.sync(fullFilePath, { ignorePath }).ignored) {
        import_npmlog38.default.silly("version", `Skipped applying prettier to ignored file: ${filePath}`);
        return;
      }
      try {
        const input = import_fs4.default.readFileSync(fullFilePath, "utf8");
        import_fs4.default.writeFileSync(
          fullFilePath,
          resolvedPrettier.format(input, { ...config, filepath: fullFilePath }),
          "utf8"
        );
        import_npmlog38.default.silly("version", `Successfully applied prettier to updated file: ${filePath}`);
      } catch {
        import_npmlog38.default.silly("version", `Failed to apply prettier to updated file: ${filePath}`);
      }
    }
    function gitAdd(changedFiles, gitOpts, execOpts) {
      let files = [];
      for (const file of changedFiles) {
        const filePath = (0, import_slash2.default)(import_path17.default.relative(execOpts.cwd, import_path17.default.resolve(execOpts.cwd, file)));
        maybeFormatFile(filePath);
        if (gitOpts.granularPathspec) {
          files.push(filePath);
        }
      }
      if (!gitOpts.granularPathspec) {
        files = ".";
      }
      import_npmlog38.default.silly("gitAdd", files);
      return childProcess11.exec("git", ["add", "--", ...files], execOpts);
    }
  }
});

// libs/commands/version/src/lib/git-commit.ts
var require_git_commit = __commonJS({
  "libs/commands/version/src/lib/git-commit.ts"(exports2, module2) {
    "use strict";
    init_src();
    var import_npmlog38 = __toESM(require("npmlog"));
    var import_os3 = require("os");
    var childProcess11 = require("@lerna/child-process");
    module2.exports.gitCommit = gitCommit;
    function gitCommit(message, { amend, commitHooks, signGitCommit, signoffGitCommit }, opts) {
      import_npmlog38.default.silly("gitCommit", message);
      const args = ["commit"];
      if (commitHooks === false) {
        args.push("--no-verify");
      }
      if (signGitCommit) {
        args.push("--gpg-sign");
      }
      if (signoffGitCommit) {
        args.push("--signoff");
      }
      if (amend) {
        args.push("--amend", "--no-edit");
      } else if (message.indexOf(import_os3.EOL) > -1) {
        args.push("-F", temp_write_default.sync(message, "lerna-commit.txt"));
      } else {
        args.push("-m", message);
      }
      import_npmlog38.default.verbose("git", args);
      return childProcess11.exec("git", args, opts);
    }
  }
});

// libs/commands/version/src/lib/git-push.ts
var require_git_push = __commonJS({
  "libs/commands/version/src/lib/git-push.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var childProcess11 = require("@lerna/child-process");
    module2.exports.gitPush = gitPush;
    function gitPush(remote, branch, opts) {
      import_npmlog38.default.silly("gitPush", remote, branch);
      return childProcess11.exec("git", ["push", "--follow-tags", "--no-verify", "--atomic", remote, branch], opts).catch((error) => {
        if (/atomic/.test(error.stderr) || process.env.GIT_REDIRECT_STDERR === "2>&1" && /atomic/.test(error.stdout)) {
          import_npmlog38.default.warn("gitPush", error.stderr);
          import_npmlog38.default.info("gitPush", "--atomic failed, attempting non-atomic push");
          return childProcess11.exec("git", ["push", "--follow-tags", "--no-verify", remote, branch], opts);
        }
        throw error;
      });
    }
  }
});

// libs/commands/version/src/lib/git-tag.ts
var require_git_tag = __commonJS({
  "libs/commands/version/src/lib/git-tag.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var childProcess11 = require("@lerna/child-process");
    module2.exports.gitTag = gitTag;
    function gitTag(tag, { forceGitTag, signGitTag }, opts, command = "git tag %s -m %s") {
      import_npmlog38.default.silly("gitTag", tag, command);
      const [cmd, ...args] = command.split(" ");
      const interpolatedArgs = args.map((arg) => arg.replace(/%s/, tag));
      if (forceGitTag) {
        interpolatedArgs.push("--force");
      }
      if (signGitTag) {
        interpolatedArgs.push("--sign");
      }
      import_npmlog38.default.verbose(cmd, interpolatedArgs);
      return childProcess11.exec(cmd, interpolatedArgs, opts);
    }
  }
});

// libs/commands/version/src/lib/is-behind-upstream.ts
var require_is_behind_upstream = __commonJS({
  "libs/commands/version/src/lib/is-behind-upstream.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var childProcess11 = require("@lerna/child-process");
    module2.exports.isBehindUpstream = isBehindUpstream;
    function isBehindUpstream(gitRemote, branch, opts) {
      import_npmlog38.default.silly("isBehindUpstream");
      updateRemote(opts);
      const remoteBranch = `${gitRemote}/${branch}`;
      const [behind, ahead] = countLeftRight(`${remoteBranch}...${branch}`, opts);
      import_npmlog38.default.silly(
        "isBehindUpstream",
        `${branch} is behind ${remoteBranch} by ${behind} commit(s) and ahead by ${ahead}`
      );
      return Boolean(behind);
    }
    function updateRemote(opts) {
      childProcess11.execSync("git", ["remote", "update"], opts);
    }
    function countLeftRight(symmetricDifference, opts) {
      const stdout = childProcess11.execSync(
        "git",
        ["rev-list", "--left-right", "--count", symmetricDifference],
        opts
      );
      return stdout.split("	").map((val) => parseInt(val, 10));
    }
  }
});

// libs/commands/version/src/lib/remote-branch-exists.ts
var require_remote_branch_exists = __commonJS({
  "libs/commands/version/src/lib/remote-branch-exists.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var childProcess11 = require("@lerna/child-process");
    module2.exports.remoteBranchExists = remoteBranchExists;
    function remoteBranchExists(gitRemote, branch, opts) {
      import_npmlog38.default.silly("remoteBranchExists");
      const remoteBranch = `${gitRemote}/${branch}`;
      try {
        childProcess11.execSync("git", ["show-ref", "--verify", `refs/remotes/${remoteBranch}`], opts);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// libs/commands/version/src/lib/is-breaking-change.ts
var require_is_breaking_change = __commonJS({
  "libs/commands/version/src/lib/is-breaking-change.ts"(exports2, module2) {
    "use strict";
    var import_semver5 = __toESM(require("semver"));
    module2.exports.isBreakingChange = isBreakingChange;
    function isBreakingChange(currentVersion, nextVersion) {
      const releaseType = import_semver5.default.diff(currentVersion, nextVersion);
      let breaking;
      if (releaseType === "major") {
        breaking = true;
      } else if (releaseType === "minor") {
        breaking = import_semver5.default.lt(currentVersion, "1.0.0");
      } else if (releaseType === "patch") {
        breaking = import_semver5.default.lt(currentVersion, "0.1.0");
      } else {
        breaking = false;
      }
      return breaking;
    }
  }
});

// libs/commands/version/src/lib/is-anything-committed.ts
var require_is_anything_committed = __commonJS({
  "libs/commands/version/src/lib/is-anything-committed.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var childProcess11 = require("@lerna/child-process");
    module2.exports.isAnythingCommitted = isAnythingCommitted;
    function isAnythingCommitted(opts) {
      import_npmlog38.default.silly("isAnythingCommitted");
      const anyCommits = childProcess11.execSync("git", ["rev-list", "--count", "--all", "--max-count=1"], opts);
      import_npmlog38.default.verbose("isAnythingCommitted", anyCommits);
      return Boolean(parseInt(anyCommits, 10));
    }
  }
});

// libs/commands/version/src/lib/prompt-version.ts
var require_prompt_version = __commonJS({
  "libs/commands/version/src/lib/prompt-version.ts"(exports2, module2) {
    "use strict";
    init_src();
    var import_semver5 = __toESM(require("semver"));
    module2.exports.makePromptVersion = makePromptVersion;
    function makePromptVersion(resolvePrereleaseId) {
      return (node) => promptVersion(node.version, node.name, resolvePrereleaseId(node.prereleaseId));
    }
    function promptVersion(currentVersion, name, prereleaseId) {
      const patch = import_semver5.default.inc(currentVersion, "patch");
      const minor = import_semver5.default.inc(currentVersion, "minor");
      const major = import_semver5.default.inc(currentVersion, "major");
      const prepatch = import_semver5.default.inc(currentVersion, "prepatch", prereleaseId);
      const preminor = import_semver5.default.inc(currentVersion, "preminor", prereleaseId);
      const premajor = import_semver5.default.inc(currentVersion, "premajor", prereleaseId);
      const message = `Select a new version ${name ? `for ${name} ` : ""}(currently ${currentVersion})`;
      return promptSelectOne(message, {
        choices: [
          { value: patch, name: `Patch (${patch})` },
          { value: minor, name: `Minor (${minor})` },
          { value: major, name: `Major (${major})` },
          { value: prepatch, name: `Prepatch (${prepatch})` },
          { value: preminor, name: `Preminor (${preminor})` },
          { value: premajor, name: `Premajor (${premajor})` },
          { value: "PRERELEASE", name: "Custom Prerelease" },
          { value: "CUSTOM", name: "Custom Version" }
        ]
      }).then((choice) => {
        if (choice === "CUSTOM") {
          return promptTextInput("Enter a custom version", {
            filter: import_semver5.default.valid,
            validate: (v) => v !== null || "Must be a valid semver version"
          });
        }
        if (choice === "PRERELEASE") {
          const defaultVersion = import_semver5.default.inc(currentVersion, "prerelease", prereleaseId);
          const prompt = `(default: "${prereleaseId}", yielding ${defaultVersion})`;
          return promptTextInput(`Enter a prerelease identifier ${prompt}`, {
            filter: (v) => import_semver5.default.inc(currentVersion, "prerelease", v || prereleaseId)
          });
        }
        return choice;
      });
    }
  }
});

// libs/commands/version/src/lib/create-release.ts
var require_create_release = __commonJS({
  "libs/commands/version/src/lib/create-release.ts"(exports2, module2) {
    "use strict";
    init_src();
    var import_semver5 = __toESM(require("semver"));
    module2.exports.createRelease = createRelease;
    module2.exports.createReleaseClient = createReleaseClient;
    function createReleaseClient(type) {
      switch (type) {
        case "gitlab":
          return createGitLabClient();
        case "github":
          return createGitHubClient();
        default:
          throw new ValidationError("ERELEASE", "Invalid release client type");
      }
    }
    function createRelease(client, { tags, releaseNotes }, { gitRemote, execOpts }) {
      const repo = parseGitRepo(gitRemote, execOpts);
      return Promise.all(
        releaseNotes.map(({ notes, name }) => {
          const tag = name === "fixed" ? tags[0] : tags.find((t) => t.startsWith(`${name}@`));
          if (!tag) {
            return Promise.resolve();
          }
          const prereleaseParts = import_semver5.default.prerelease(tag.replace(`${name}@`, "")) || [];
          return client.repos.createRelease({
            owner: repo.owner,
            repo: repo.name,
            tag_name: tag,
            name: tag,
            body: notes,
            draft: false,
            prerelease: prereleaseParts.length > 0
          });
        })
      );
    }
  }
});

// libs/commands/version/src/lib/update-lockfile-version.ts
var require_update_lockfile_version = __commonJS({
  "libs/commands/version/src/lib/update-lockfile-version.ts"(exports2, module2) {
    "use strict";
    var import_devkit2 = require("@nrwl/devkit");
    var import_load_json_file3 = __toESM(require("load-json-file"));
    var import_npmlog38 = __toESM(require("npmlog"));
    var import_path17 = __toESM(require("path"));
    module2.exports.updateLockfileVersion = updateLockfileVersion;
    function updateLockfileVersion(pkg) {
      const lockfilePath = import_path17.default.join(pkg.location, "package-lock.json");
      let chain = Promise.resolve();
      chain = chain.then(
        () => (0, import_load_json_file3.default)(lockfilePath).catch(() => {
          import_npmlog38.default.verbose("version", `${pkg.name} has no lockfile. Skipping lockfile update.`);
        })
      );
      chain = chain.then((obj) => {
        if (obj) {
          obj.version = pkg.version;
          if (obj.packages && obj.packages[""]) {
            obj.packages[""].version = pkg.version;
            if (obj.packages[""].dependencies) {
              const updatedPkgDependencies = Object.keys(obj.packages[""].dependencies).reduce(
                (prev, next) => ({ ...prev, [next]: pkg.dependencies[next] }),
                {}
              );
              obj.packages[""].dependencies = updatedPkgDependencies;
            }
            if (obj.packages[""].devDependencies) {
              const updatedPkgDevDependencies = Object.keys(obj.packages[""].devDependencies).reduce(
                (prev, next) => ({ ...prev, [next]: pkg.devDependencies[next] }),
                {}
              );
              obj.packages[""].devDependencies = updatedPkgDevDependencies;
            }
          }
          (0, import_devkit2.writeJsonFile)(lockfilePath, obj, {
            spaces: 2
          });
          return lockfilePath;
        }
      });
      return chain;
    }
  }
});

// libs/commands/version/src/index.ts
var require_src = __commonJS({
  "libs/commands/version/src/index.ts"(exports2, module2) {
    "use strict";
    init_src();
    var import_chalk3 = __toESM(require("chalk"));
    var import_dedent5 = __toESM(require("dedent"));
    var import_fs4 = __toESM(require("fs"));
    var import_minimatch2 = __toESM(require("minimatch"));
    var import_os3 = __toESM(require("os"));
    var import_p_map5 = __toESM(require("p-map"));
    var import_p_pipe = __toESM(require("p-pipe"));
    var import_p_reduce = __toESM(require("p-reduce"));
    var import_p_waterfall = __toESM(require("p-waterfall"));
    var import_path17 = __toESM(require("path"));
    var import_semver5 = __toESM(require("semver"));
    var childProcess11 = require("@lerna/child-process");
    var { getCurrentBranch } = require_get_current_branch();
    var { gitAdd } = require_git_add();
    var { gitCommit } = require_git_commit();
    var { gitPush } = require_git_push();
    var { gitTag } = require_git_tag();
    var { isBehindUpstream } = require_is_behind_upstream();
    var { remoteBranchExists } = require_remote_branch_exists();
    var { isBreakingChange } = require_is_breaking_change();
    var { isAnythingCommitted } = require_is_anything_committed();
    var { makePromptVersion } = require_prompt_version();
    var { createRelease, createReleaseClient } = require_create_release();
    var { updateLockfileVersion } = require_update_lockfile_version();
    module2.exports = function factory(argv) {
      return new VersionCommand(argv);
    };
    var VersionCommand = class extends Command {
      get otherCommandConfigs() {
        return ["publish"];
      }
      get requiresGit() {
        return this.commitAndTag || this.pushToRemote || this.options.allowBranch || this.options.conventionalCommits;
      }
      configureProperties() {
        super.configureProperties();
        const {
          amend,
          commitHooks = true,
          gitRemote = "origin",
          gitTagVersion = true,
          granularPathspec = true,
          push = true,
          signGitCommit,
          signoffGitCommit,
          signGitTag,
          forceGitTag,
          tagVersionPrefix = "v"
        } = this.options;
        this.gitRemote = gitRemote;
        this.tagPrefix = tagVersionPrefix;
        this.commitAndTag = gitTagVersion;
        this.pushToRemote = gitTagVersion && amend !== true && push;
        this.releaseClient = this.pushToRemote && this.options.createRelease && createReleaseClient(this.options.createRelease);
        this.releaseNotes = [];
        if (this.releaseClient && this.options.conventionalCommits !== true) {
          throw new ValidationError("ERELEASE", "To create a release, you must enable --conventional-commits");
        }
        if (this.releaseClient && this.options.changelog === false) {
          throw new ValidationError("ERELEASE", "To create a release, you cannot pass --no-changelog");
        }
        this.gitOpts = {
          amend,
          commitHooks,
          granularPathspec,
          signGitCommit,
          signoffGitCommit,
          signGitTag,
          forceGitTag
        };
        this.savePrefix = this.options.exact ? "" : "^";
      }
      initialize() {
        if (!this.project.isIndependent()) {
          this.logger.info("current version", this.project.version);
        }
        if (this.requiresGit) {
          if (!isAnythingCommitted(this.execOpts)) {
            throw new ValidationError(
              "ENOCOMMIT",
              "No commits in this repository. Please commit something before using version."
            );
          }
          this.currentBranch = getCurrentBranch(this.execOpts);
          if (this.currentBranch === "HEAD") {
            throw new ValidationError(
              "ENOGIT",
              "Detached git HEAD, please checkout a branch to choose versions."
            );
          }
          if (this.pushToRemote && !remoteBranchExists(this.gitRemote, this.currentBranch, this.execOpts)) {
            throw new ValidationError(
              "ENOREMOTEBRANCH",
              import_dedent5.default`
            Branch '${this.currentBranch}' doesn't exist in remote '${this.gitRemote}'.
            If this is a new branch, please make sure you push it to the remote first.
          `
            );
          }
          if (this.options.allowBranch && ![].concat(this.options.allowBranch).some((x) => (0, import_minimatch2.default)(this.currentBranch, x))) {
            throw new ValidationError(
              "ENOTALLOWED",
              import_dedent5.default`
            Branch '${this.currentBranch}' is restricted from versioning due to allowBranch config.
            Please consider the reasons for this restriction before overriding the option.
          `
            );
          }
          if (this.commitAndTag && this.pushToRemote && isBehindUpstream(this.gitRemote, this.currentBranch, this.execOpts)) {
            const message = `Local branch '${this.currentBranch}' is behind remote upstream ${this.gitRemote}/${this.currentBranch}`;
            if (!this.options.ci) {
              throw new ValidationError(
                "EBEHIND",
                import_dedent5.default`
              ${message}
              Please merge remote changes into '${this.currentBranch}' with 'git pull'
            `
              );
            }
            this.logger.warn("EBEHIND", `${message}, exiting`);
            return false;
          }
        } else {
          this.logger.notice(
            "FYI",
            "git repository validation has been skipped, please ensure your version bumps are correct"
          );
        }
        if (this.options.conventionalPrerelease && this.options.conventionalGraduate) {
          throw new ValidationError(
            "ENOTALLOWED",
            import_dedent5.default`
          --conventional-prerelease cannot be combined with --conventional-graduate.
        `
          );
        }
        this.updates = collectUpdates(
          this.packageGraph.rawPackageList,
          this.packageGraph,
          this.execOpts,
          this.options
        ).filter((node) => {
          if (node.pkg.private && this.options.private === false) {
            return false;
          }
          if (!node.version) {
            if (node.pkg.private) {
              this.logger.info("version", "Skipping unversioned private package %j", node.name);
            } else {
              throw new ValidationError(
                "ENOVERSION",
                import_dedent5.default`
              A version field is required in ${node.name}'s package.json file.
              If you wish to keep the package unversioned, it must be made private.
            `
              );
            }
          }
          return !!node.version;
        });
        if (!this.updates.length) {
          this.logger.success(`No changed packages to ${this.composed ? "publish" : "version"}`);
          return false;
        }
        this.hasRootedLeaf = this.packageGraph.has(this.project.manifest.name);
        if (this.hasRootedLeaf && !this.composed) {
          this.logger.info("version", "rooted leaf detected, skipping synthetic root lifecycles");
        }
        this.runPackageLifecycle = createRunner({ ...this.options, stdio: "inherit" });
        this.runRootLifecycle = /^(pre|post)?version$/.test(process.env.npm_lifecycle_event) ? (stage) => {
          this.logger.warn("lifecycle", "Skipping root %j because it has already been called", stage);
        } : (stage) => this.runPackageLifecycle(this.project.manifest, stage);
        const tasks = [
          () => this.getVersionsForUpdates(),
          (versions) => this.setUpdatesForVersions(versions),
          () => this.confirmVersions()
        ];
        if (this.commitAndTag && this.gitOpts.amend !== true) {
          const { forcePublish, conventionalCommits, conventionalGraduate } = this.options;
          const checkUncommittedOnly = forcePublish || conventionalCommits && conventionalGraduate;
          const check = checkUncommittedOnly ? throwIfUncommitted : checkWorkingTree;
          tasks.unshift(() => check(this.execOpts));
        } else {
          this.logger.warn("version", "Skipping working tree validation, proceed at your own risk");
        }
        return (0, import_p_waterfall.default)(tasks);
      }
      execute() {
        const tasks = [() => this.updatePackageVersions()];
        if (this.commitAndTag) {
          tasks.push(() => this.commitAndTagUpdates());
        } else {
          this.logger.info("execute", "Skipping git tag/commit");
        }
        if (this.pushToRemote) {
          tasks.push(() => this.gitPushToRemote());
        } else {
          this.logger.info("execute", "Skipping git push");
        }
        if (this.releaseClient) {
          this.logger.info("execute", "Creating releases...");
          tasks.push(
            () => createRelease(
              this.releaseClient,
              { tags: this.tags, releaseNotes: this.releaseNotes },
              { gitRemote: this.options.gitRemote, execOpts: this.execOpts }
            )
          );
        } else {
          this.logger.info("execute", "Skipping releases");
        }
        return (0, import_p_waterfall.default)(tasks).then(() => {
          if (!this.composed) {
            this.logger.success("version", "finished");
          }
          return {
            updates: this.updates,
            updatesVersions: this.updatesVersions
          };
        });
      }
      getVersionsForUpdates() {
        const independentVersions = this.project.isIndependent();
        const { bump, conventionalCommits, preid } = this.options;
        const repoVersion = bump ? import_semver5.default.clean(bump) : "";
        const increment = bump && !import_semver5.default.valid(bump) ? bump : "";
        const resolvePrereleaseId = (existingPreid) => preid || existingPreid || "alpha";
        const makeGlobalVersionPredicate = (nextVersion) => {
          this.globalVersion = nextVersion;
          return () => nextVersion;
        };
        let predicate;
        if (repoVersion) {
          predicate = makeGlobalVersionPredicate(repoVersion);
        } else if (increment && independentVersions) {
          predicate = (node) => import_semver5.default.inc(node.version, increment, resolvePrereleaseId(node.prereleaseId));
        } else if (increment) {
          const prereleaseId = prereleaseIdFromVersion(this.project.version);
          const nextVersion = import_semver5.default.inc(this.project.version, increment, resolvePrereleaseId(prereleaseId));
          predicate = makeGlobalVersionPredicate(nextVersion);
        } else if (conventionalCommits) {
          return this.recommendVersions(resolvePrereleaseId);
        } else if (independentVersions) {
          predicate = makePromptVersion(resolvePrereleaseId);
        } else {
          const prereleaseId = prereleaseIdFromVersion(this.project.version);
          const node = { version: this.project.version, prereleaseId };
          predicate = makePromptVersion(resolvePrereleaseId);
          predicate = predicate(node).then(makeGlobalVersionPredicate);
        }
        return Promise.resolve(predicate).then((getVersion) => this.reduceVersions(getVersion));
      }
      reduceVersions(getVersion) {
        const iterator = (versionMap, node) => Promise.resolve(getVersion(node)).then((version) => versionMap.set(node.name, version));
        return (0, import_p_reduce.default)(this.updates, iterator, /* @__PURE__ */ new Map());
      }
      getPrereleasePackageNames() {
        const prereleasePackageNames = getPackagesForOption(this.options.conventionalPrerelease);
        const isCandidate = prereleasePackageNames.has("*") ? () => true : (node, name) => prereleasePackageNames.has(name);
        return collectPackages(this.packageGraph, { isCandidate }).map((pkg) => pkg.name);
      }
      recommendVersions(resolvePrereleaseId) {
        const independentVersions = this.project.isIndependent();
        const { changelogPreset, conventionalGraduate, conventionalBumpPrerelease } = this.options;
        const rootPath = this.project.manifest.location;
        const type = independentVersions ? "independent" : "fixed";
        const prereleasePackageNames = this.getPrereleasePackageNames();
        const graduatePackageNames = Array.from(getPackagesForOption(conventionalGraduate));
        const shouldPrerelease = (name) => prereleasePackageNames && prereleasePackageNames.includes(name);
        const shouldGraduate = (name) => graduatePackageNames.includes("*") || graduatePackageNames.includes(name);
        const getPrereleaseId = (node) => {
          if (!shouldGraduate(node.name) && (shouldPrerelease(node.name) || node.prereleaseId)) {
            return resolvePrereleaseId(node.prereleaseId);
          }
        };
        let chain = Promise.resolve();
        if (type === "fixed") {
          chain = chain.then(() => this.setGlobalVersionFloor());
        }
        chain = chain.then(
          () => this.reduceVersions(
            (node) => recommendVersion(node, type, {
              changelogPreset,
              rootPath,
              tagPrefix: this.tagPrefix,
              prereleaseId: getPrereleaseId(node),
              conventionalBumpPrerelease
            })
          )
        );
        if (type === "fixed") {
          chain = chain.then((versions) => {
            this.globalVersion = this.setGlobalVersionCeiling(versions);
            return versions;
          });
        }
        return chain;
      }
      setGlobalVersionFloor() {
        const globalVersion = this.project.version;
        for (const node of this.updates) {
          if (import_semver5.default.lt(node.version, globalVersion)) {
            this.logger.verbose(
              "version",
              `Overriding version of ${node.name} from ${node.version} to ${globalVersion}`
            );
            node.pkg.set("version", globalVersion);
          }
        }
      }
      setGlobalVersionCeiling(versions) {
        let highestVersion = this.project.version;
        versions.forEach((bump) => {
          if (bump && import_semver5.default.gt(bump, highestVersion)) {
            highestVersion = bump;
          }
        });
        versions.forEach((_, name) => versions.set(name, highestVersion));
        return highestVersion;
      }
      setUpdatesForVersions(versions) {
        if (this.project.isIndependent() || versions.size === this.packageGraph.size) {
          this.updatesVersions = versions;
        } else {
          let hasBreakingChange;
          for (const [name, bump] of versions) {
            hasBreakingChange = hasBreakingChange || isBreakingChange(this.packageGraph.get(name).version, bump);
          }
          if (hasBreakingChange) {
            this.updates = Array.from(this.packageGraph.values());
            if (this.options.private === false) {
              this.updates = this.updates.filter((node) => !node.pkg.private);
            }
            this.updatesVersions = new Map(this.updates.map((node) => [node.name, this.globalVersion]));
          } else {
            this.updatesVersions = versions;
          }
        }
        this.packagesToVersion = this.updates.map((node) => node.pkg);
      }
      confirmVersions() {
        const changes = this.packagesToVersion.map((pkg) => {
          let line = ` - ${pkg.name}: ${pkg.version} => ${this.updatesVersions.get(pkg.name)}`;
          if (pkg.private) {
            line += ` (${import_chalk3.default.red("private")})`;
          }
          return line;
        });
        output("");
        output("Changes:");
        output(changes.join(import_os3.default.EOL));
        output("");
        if (this.options.yes) {
          this.logger.info("auto-confirmed");
          return true;
        }
        const message = this.composed ? "Are you sure you want to publish these packages?" : "Are you sure you want to create these versions?";
        return promptConfirmation(message);
      }
      updatePackageVersions() {
        const { conventionalCommits, changelogPreset, changelog = true } = this.options;
        const independentVersions = this.project.isIndependent();
        const rootPath = this.project.manifest.location;
        const changedFiles = /* @__PURE__ */ new Set();
        let chain = Promise.resolve();
        if (!this.hasRootedLeaf) {
          chain = chain.then(() => this.runRootLifecycle("preversion"));
        }
        const actions = [
          (pkg) => this.runPackageLifecycle(pkg, "preversion").then(() => pkg),
          (pkg) => pkg.refresh(),
          (pkg) => {
            pkg.set("version", this.updatesVersions.get(pkg.name));
            for (const [depName, resolved] of this.packageGraph.get(pkg.name).localDependencies) {
              const depVersion = this.updatesVersions.get(depName);
              if (depVersion && resolved.type !== "directory") {
                pkg.updateLocalDependency(resolved, depVersion, this.savePrefix);
              }
            }
            return Promise.all([updateLockfileVersion(pkg), pkg.serialize()]).then(([lockfilePath]) => {
              changedFiles.add(pkg.manifestLocation);
              if (lockfilePath) {
                changedFiles.add(lockfilePath);
              }
              return pkg;
            });
          },
          (pkg) => this.runPackageLifecycle(pkg, "version").then(() => pkg)
        ];
        if (conventionalCommits && changelog) {
          const type = independentVersions ? "independent" : "fixed";
          actions.push(
            (pkg) => updateChangelog(pkg, type, {
              changelogPreset,
              rootPath,
              tagPrefix: this.tagPrefix
            }).then(({ logPath, newEntry }) => {
              changedFiles.add(logPath);
              if (independentVersions) {
                this.releaseNotes.push({
                  name: pkg.name,
                  notes: newEntry
                });
              }
              return pkg;
            })
          );
        }
        const mapUpdate = (0, import_p_pipe.default)(...actions);
        chain = chain.then(
          () => runTopologically(this.packagesToVersion, mapUpdate, {
            concurrency: this.concurrency,
            rejectCycles: this.options.rejectCycles
          })
        );
        if (!independentVersions) {
          this.project.version = this.globalVersion;
          if (conventionalCommits && changelog) {
            chain = chain.then(
              () => updateChangelog(this.project.manifest, "root", {
                changelogPreset,
                rootPath,
                tagPrefix: this.tagPrefix,
                version: this.globalVersion
              }).then(({ logPath, newEntry }) => {
                changedFiles.add(logPath);
                this.releaseNotes.push({
                  name: "fixed",
                  notes: newEntry
                });
              })
            );
          }
          chain = chain.then(
            () => Promise.resolve(this.project.serializeConfig()).then((lernaConfigLocation) => {
              changedFiles.add(lernaConfigLocation);
            })
          );
        }
        const npmClientArgsRaw = this.options.npmClientArgs || [];
        const npmClientArgs = npmClientArgsRaw.reduce((args, arg) => args.concat(arg.split(/\s|,/)), []);
        if (this.options.npmClient === "pnpm") {
          chain = chain.then(() => {
            this.logger.verbose("version", "Updating root pnpm-lock.yaml");
            return childProcess11.exec("pnpm", ["install", "--lockfile-only", "--ignore-scripts", ...npmClientArgs], this.execOpts).then(() => {
              const lockfilePath = import_path17.default.join(this.project.rootPath, "pnpm-lock.yaml");
              changedFiles.add(lockfilePath);
            });
          });
        }
        if (this.options.npmClient === "npm" || !this.options.npmClient) {
          const lockfilePath = import_path17.default.join(this.project.rootPath, "package-lock.json");
          if (import_fs4.default.existsSync(lockfilePath)) {
            chain = chain.then(() => {
              this.logger.verbose("version", "Updating root package-lock.json");
              return childProcess11.exec(
                "npm",
                ["install", "--package-lock-only", "--ignore-scripts", ...npmClientArgs],
                this.execOpts
              ).then(() => {
                changedFiles.add(lockfilePath);
              });
            });
          }
        }
        if (!this.hasRootedLeaf) {
          chain = chain.then(() => this.runRootLifecycle("version"));
        }
        if (this.commitAndTag) {
          chain = chain.then(() => gitAdd(Array.from(changedFiles), this.gitOpts, this.execOpts));
        }
        return chain;
      }
      commitAndTagUpdates() {
        let chain = Promise.resolve();
        if (this.project.isIndependent()) {
          chain = chain.then(() => this.gitCommitAndTagVersionForUpdates());
        } else {
          chain = chain.then(() => this.gitCommitAndTagVersion());
        }
        chain = chain.then((tags) => {
          this.tags = tags;
        });
        chain = chain.then(
          () => (0, import_p_map5.default)(this.packagesToVersion, (pkg) => this.runPackageLifecycle(pkg, "postversion"))
        );
        if (!this.hasRootedLeaf) {
          chain = chain.then(() => this.runRootLifecycle("postversion"));
        }
        return chain;
      }
      gitCommitAndTagVersionForUpdates() {
        const tags = this.packagesToVersion.map((pkg) => `${pkg.name}@${this.updatesVersions.get(pkg.name)}`);
        const subject = this.options.message || "Publish";
        const message = tags.reduce((msg, tag) => `${msg}${import_os3.default.EOL} - ${tag}`, `${subject}${import_os3.default.EOL}`);
        return Promise.resolve().then(() => gitCommit(message, this.gitOpts, this.execOpts)).then(
          () => Promise.all(tags.map((tag) => gitTag(tag, this.gitOpts, this.execOpts, this.options.gitTagCommand)))
        ).then(() => tags);
      }
      gitCommitAndTagVersion() {
        const version = this.globalVersion;
        const tag = `${this.tagPrefix}${version}`;
        const message = this.options.message ? this.options.message.replace(/%s/g, tag).replace(/%v/g, version) : tag;
        return Promise.resolve().then(() => gitCommit(message, this.gitOpts, this.execOpts)).then(() => gitTag(tag, this.gitOpts, this.execOpts, this.options.gitTagCommand)).then(() => [tag]);
      }
      gitPushToRemote() {
        this.logger.info("git", "Pushing tags...");
        return gitPush(this.gitRemote, this.currentBranch, this.execOpts);
      }
    };
    module2.exports.VersionCommand = VersionCommand;
  }
});

// libs/commands/version/src/command.ts
var require_command = __commonJS({
  "libs/commands/version/src/command.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var import_semver5 = __toESM(require("semver"));
    function addBumpPositional(yargs2, additionalKeywords = []) {
      const semverKeywords = ["major", "minor", "patch", "premajor", "preminor", "prepatch", "prerelease"].concat(
        additionalKeywords
      );
      const bumpOptionList = `'${semverKeywords.slice(0, -1).join("', '")}', or '${semverKeywords[semverKeywords.length - 1]}'.`;
      yargs2.positional("bump", {
        describe: `Increment version(s) by explicit version _or_ semver keyword,
${bumpOptionList}`,
        type: "string",
        coerce: (choice) => {
          if (!import_semver5.default.valid(choice) && semverKeywords.indexOf(choice) === -1) {
            throw new Error(`bump must be an explicit version string _or_ one of: ${bumpOptionList}`);
          }
          return choice;
        }
      });
    }
    var command = {
      command: "version [bump]",
      describe: "Bump version of packages changed since the last release",
      builder(yargs2, composed) {
        const opts = {
          "allow-branch": {
            describe: "Specify which branches to allow versioning from.",
            type: "array"
          },
          amend: {
            describe: "Amend the existing commit, instead of generating a new one.",
            type: "boolean"
          },
          "conventional-commits": {
            describe: "Use conventional-changelog to determine version bump and generate CHANGELOG.",
            type: "boolean"
          },
          "conventional-graduate": {
            describe: "Version currently prereleased packages to a non-prerelease version."
          },
          "conventional-prerelease": {
            describe: "Version changed packages as prereleases when using --conventional-commits."
          },
          "conventional-bump-prerelease": {
            describe: "Bumps prerelease versions if conventional commits requires it.",
            type: "boolean"
          },
          "changelog-preset": {
            describe: "Custom conventional-changelog preset.",
            type: "string",
            requiresArg: true,
            defaultDescription: "angular"
          },
          exact: {
            describe: "Specify cross-dependency version numbers exactly rather than with a caret (^).",
            type: "boolean"
          },
          "force-publish": {
            describe: "Always include targeted packages in versioning operations, skipping default logic."
          },
          "git-remote": {
            describe: "Push git changes to the specified remote.",
            type: "string",
            requiresArg: true,
            defaultDescription: "origin"
          },
          "create-release": {
            describe: "Create an official GitHub or GitLab release for every version.",
            type: "string",
            choices: ["gitlab", "github"]
          },
          "ignore-changes": {
            describe: [
              "Ignore changes in files matched by glob(s) when detecting changed packages.",
              "Pass --no-ignore-changes to completely disable."
            ].join("\n"),
            type: "array"
          },
          "ignore-scripts": {
            describe: "Disable all lifecycle scripts",
            type: "boolean"
          },
          "include-merged-tags": {
            describe: "Include tags from merged branches when detecting changed packages.",
            type: "boolean"
          },
          m: {
            describe: "Use a custom commit message when creating the version commit.",
            alias: "message",
            type: "string",
            requiresArg: true
          },
          "no-changelog": {
            describe: "Do not generate CHANGELOG.md files when using --conventional-commits.",
            type: "boolean"
          },
          changelog: {
            hidden: true,
            type: "boolean"
          },
          "no-commit-hooks": {
            describe: "Do not run git commit hooks when committing version changes.",
            type: "boolean"
          },
          "commit-hooks": {
            hidden: true,
            type: "boolean"
          },
          "no-git-tag-version": {
            describe: "Do not commit or tag version changes.",
            type: "boolean"
          },
          "git-tag-version": {
            hidden: true,
            type: "boolean"
          },
          "no-granular-pathspec": {
            describe: "Do not stage changes file-by-file, but globally.",
            type: "boolean"
          },
          "granular-pathspec": {
            hidden: true,
            type: "boolean"
          },
          "no-private": {
            describe: "Do not version private packages.",
            type: "boolean"
          },
          private: {
            hidden: true,
            type: "boolean"
          },
          "no-push": {
            describe: "Do not push tagged commit to git remote.",
            type: "boolean"
          },
          push: {
            hidden: true,
            type: "boolean"
          },
          preid: {
            describe: "Specify the prerelease identifier when versioning a prerelease",
            type: "string",
            requiresArg: true,
            defaultDescription: "alpha"
          },
          "sign-git-commit": {
            describe: "Pass the `--gpg-sign` flag to `git commit`.",
            type: "boolean"
          },
          "signoff-git-commit": {
            describe: "Pass the `--signoff` flag to `git commit`.",
            type: "boolean"
          },
          "sign-git-tag": {
            describe: "Pass the `--sign` flag to `git tag`.",
            type: "boolean"
          },
          "force-git-tag": {
            describe: "Pass the `--force` flag to `git tag`.",
            type: "boolean"
          },
          "tag-version-prefix": {
            describe: "Customize the tag prefix. To remove entirely, pass an empty string.",
            type: "string",
            requiresArg: true,
            defaultDescription: "v"
          },
          "git-tag-command": {
            describe: "Allows users to specify a custom command to be used when applying git tags. For example, this may be useful for providing a wrapper command in CI/CD pipelines that have no direct write access.",
            type: "string"
          },
          "npm-client-args": {
            describe: "Additional arguments to pass to the npm client when performing 'npm install'.",
            type: "array"
          },
          y: {
            describe: "Skip all confirmation prompts.",
            alias: "yes",
            type: "boolean"
          }
        };
        if (composed) {
          Object.keys(opts).forEach((key) => {
            opts[key].hidden = true;
          });
          yargs2.default("composed", composed).hide("composed");
        } else {
          addBumpPositional(yargs2);
        }
        yargs2.options(opts);
        yargs2.parserConfiguration({
          "populate--": true
        });
        if (!composed) {
          yargs2.group(Object.keys(opts), "Command Options:");
        }
        return yargs2.option("ignore", {
          hidden: true,
          conflicts: "ignore-changes",
          type: "array"
        }).option("cd-version", {
          hidden: true,
          conflicts: "bump",
          type: "string",
          requiresArg: true
        }).option("repo-version", {
          hidden: true,
          conflicts: "bump",
          type: "string",
          requiresArg: true
        }).option("skip-git", {
          hidden: true,
          type: "boolean"
        }).option("github-release", {
          hidden: true,
          type: "boolean"
        }).check((argv) => {
          if (argv.ignore) {
            argv.ignoreChanges = argv.ignore;
            delete argv.ignore;
            import_npmlog38.default.warn("deprecated", "--ignore has been renamed --ignore-changes");
          }
          if (argv.cdVersion && !argv.bump) {
            argv.bump = argv.cdVersion;
            delete argv.cdVersion;
            delete argv["cd-version"];
            import_npmlog38.default.warn("deprecated", "--cd-version has been replaced by positional [bump]");
          }
          if (argv.repoVersion && !argv.bump) {
            argv.bump = argv.repoVersion;
            delete argv.repoVersion;
            delete argv["repo-version"];
            import_npmlog38.default.warn("deprecated", "--repo-version has been replaced by positional [bump]");
          }
          if (argv.skipGit) {
            argv.gitTagVersion = false;
            argv["git-tag-version"] = false;
            argv.push = false;
            delete argv.skipGit;
            delete argv["skip-git"];
            import_npmlog38.default.warn("deprecated", "--skip-git has been replaced by --no-git-tag-version --no-push");
          }
          if (argv.githubRelease) {
            argv.createRelease = "github";
            delete argv.githubRelease;
            import_npmlog38.default.warn("deprecated", "--github-release has been replaced by --create-release=github");
          }
          if (argv["--"]) {
            import_npmlog38.default.warn("EDOUBLEDASH", "Arguments after -- are no longer passed to subprocess executions.");
            import_npmlog38.default.warn("EDOUBLEDASH", "This will cause an error in a future major version.");
          }
          return argv;
        });
      },
      handler(argv) {
        return require_src()(argv);
      },
      addBumpPositional
    };
    module2.exports = command;
  }
});

// libs/commands/publish/src/lib/create-temp-licenses.ts
var require_create_temp_licenses = __commonJS({
  "libs/commands/publish/src/lib/create-temp-licenses.ts"(exports2, module2) {
    "use strict";
    var import_fs_extra11 = __toESM(require("fs-extra"));
    var import_p_map5 = __toESM(require("p-map"));
    var import_path17 = __toESM(require("path"));
    module2.exports.createTempLicenses = createTempLicenses;
    function createTempLicenses(srcLicensePath, packagesToBeLicensed) {
      if (!srcLicensePath || !packagesToBeLicensed.length) {
        return Promise.resolve();
      }
      const licenseFileName = import_path17.default.basename(srcLicensePath);
      const options = {
        preserveTimestamps: process.arch !== "ia32"
      };
      packagesToBeLicensed.forEach((pkg) => {
        pkg.licensePath = import_path17.default.join(pkg.contents, licenseFileName);
      });
      return (0, import_p_map5.default)(packagesToBeLicensed, (pkg) => import_fs_extra11.default.copy(srcLicensePath, pkg.licensePath, options));
    }
  }
});

// libs/commands/publish/src/lib/get-current-sha.ts
var require_get_current_sha = __commonJS({
  "libs/commands/publish/src/lib/get-current-sha.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var childProcess11 = require("@lerna/child-process");
    module2.exports.getCurrentSHA = getCurrentSHA;
    function getCurrentSHA(opts) {
      import_npmlog38.default.silly("getCurrentSHA");
      const sha = childProcess11.execSync("git", ["rev-parse", "HEAD"], opts);
      import_npmlog38.default.verbose("getCurrentSHA", sha);
      return sha;
    }
  }
});

// libs/commands/publish/src/lib/get-current-tags.ts
var require_get_current_tags = __commonJS({
  "libs/commands/publish/src/lib/get-current-tags.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var import_npm_package_arg7 = __toESM(require("npm-package-arg"));
    var childProcess11 = require("@lerna/child-process");
    module2.exports.getCurrentTags = getCurrentTags;
    function getCurrentTags(execOpts, matchingPattern) {
      import_npmlog38.default.silly("getCurrentTags", "matching %j", matchingPattern);
      const opts = Object.assign({}, execOpts, {
        reject: false
      });
      return childProcess11.exec("git", ["tag", "--sort", "version:refname", "--points-at", "HEAD", "--list", matchingPattern], opts).then((result) => {
        const lines = result.stdout.split("\n").filter(Boolean);
        if (matchingPattern === "*@*") {
          return lines.map((tag) => (0, import_npm_package_arg7.default)(tag).name);
        }
        return lines;
      });
    }
  }
});

// libs/commands/publish/src/lib/get-unpublished-packages.ts
var require_get_unpublished_packages = __commonJS({
  "libs/commands/publish/src/lib/get-unpublished-packages.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var import_p_map5 = __toESM(require("p-map"));
    var import_pacote = __toESM(require("pacote"));
    module2.exports.getUnpublishedPackages = getUnpublishedPackages;
    function getUnpublishedPackages(packageGraph, opts) {
      import_npmlog38.default.silly("getUnpublishedPackages");
      let chain = Promise.resolve();
      const graphNodesToCheck = Array.from(packageGraph.values());
      const mapper = (pkg) => import_pacote.default.packument(pkg.name, opts).then(
        (packument) => {
          if (packument.versions === void 0 || packument.versions[pkg.version] === void 0) {
            return pkg;
          }
        },
        () => {
          import_npmlog38.default.warn("", "Unable to determine published version, assuming %j unpublished.", pkg.name);
          return pkg;
        }
      );
      chain = chain.then(() => (0, import_p_map5.default)(graphNodesToCheck, mapper, { concurrency: 4 }));
      return chain.then((results) => results.filter(Boolean));
    }
  }
});

// libs/commands/publish/src/lib/fetch-config.ts
var require_fetch_config = __commonJS({
  "libs/commands/publish/src/lib/fetch-config.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    module2.exports.getFetchConfig = getFetchConfig;
    function getFetchConfig(options, extra) {
      return {
        log: import_npmlog38.default,
        ...options,
        ...extra
      };
    }
  }
});

// libs/commands/publish/src/lib/get-profile-data.ts
var require_get_profile_data = __commonJS({
  "libs/commands/publish/src/lib/get-profile-data.ts"(exports2, module2) {
    "use strict";
    init_src();
    var import_npm_registry_fetch2 = __toESM(require("npm-registry-fetch"));
    module2.exports.getProfileData = getProfileData;
    function getProfileData(opts) {
      opts.log.verbose("", "Retrieving npm user profile");
      return pulseTillDone(import_npm_registry_fetch2.default.json("/-/npm/v1/user", opts)).then((data) => {
        opts.log.silly("npm profile get", "received %j", data);
        return Object.assign(
          { username: data.name },
          data
        );
      });
    }
  }
});

// libs/commands/publish/src/lib/get-whoami.ts
var require_get_whoami = __commonJS({
  "libs/commands/publish/src/lib/get-whoami.ts"(exports2, module2) {
    "use strict";
    init_src();
    var import_npm_registry_fetch2 = __toESM(require("npm-registry-fetch"));
    module2.exports.getWhoAmI = getWhoAmI;
    function getWhoAmI(opts) {
      opts.log.verbose("", "Retrieving npm username");
      return pulseTillDone(import_npm_registry_fetch2.default.json("/-/whoami", opts)).then((data) => {
        opts.log.silly("npm whoami", "received %j", data);
        return data;
      });
    }
  }
});

// libs/commands/publish/src/lib/get-npm-username.ts
var require_get_npm_username = __commonJS({
  "libs/commands/publish/src/lib/get-npm-username.ts"(exports2, module2) {
    "use strict";
    init_src();
    var { getFetchConfig } = require_fetch_config();
    var { getProfileData } = require_get_profile_data();
    var { getWhoAmI } = require_get_whoami();
    module2.exports.getNpmUsername = getNpmUsername;
    function getNpmUsername(options) {
      const opts = getFetchConfig(options, {
        fetchRetries: 0
      });
      opts.log.info("", "Verifying npm credentials");
      return getProfileData(opts).catch((err) => {
        if (err.code === "E500" || err.code === "E404") {
          return getWhoAmI(opts);
        }
        throw err;
      }).then(success, failure);
      function success(result) {
        opts.log.silly("get npm username", "received %j", result);
        if (!result.username) {
          throw new ValidationError(
            "ENEEDAUTH",
            "You must be logged in to publish packages. Use `npm login` and try again."
          );
        }
        return result.username;
      }
      function failure(err) {
        opts.log.pause();
        console.error(err.message);
        opts.log.resume();
        if (opts.registry === "https://registry.npmjs.org/") {
          if (err.code === "E403") {
            throw new ValidationError(
              "ENEEDAUTH",
              "Access verification failed. Ensure that your npm access token has both read and write access, or remove the verifyAccess option to skip this verification. Note that npm automation tokens do NOT have read access (https://docs.npmjs.com/creating-and-viewing-access-tokens)."
            );
          }
          throw new ValidationError("EWHOAMI", "Authentication error. Use `npm whoami` to troubleshoot.");
        }
        opts.log.warn(
          "EWHOAMI",
          "Unable to determine npm username from third-party registry, this command will likely fail soon!"
        );
      }
    }
  }
});

// libs/commands/publish/src/lib/get-tagged-packages.ts
var require_get_tagged_packages = __commonJS({
  "libs/commands/publish/src/lib/get-tagged-packages.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var import_path17 = __toESM(require("path"));
    var childProcess11 = require("@lerna/child-process");
    module2.exports.getTaggedPackages = getTaggedPackages;
    function getTaggedPackages(packageGraph, rootPath, execOpts) {
      import_npmlog38.default.silly("getTaggedPackages");
      return childProcess11.exec("git", ["diff-tree", "--name-only", "--no-commit-id", "--root", "-r", "-c", "HEAD"], execOpts).then(({ stdout }) => {
        const manifests = stdout.split("\n").filter((fp) => import_path17.default.basename(fp) === "package.json");
        const locations = new Set(manifests.map((fp) => import_path17.default.join(rootPath, import_path17.default.dirname(fp))));
        return Array.from(packageGraph.values()).filter((node) => locations.has(node.location));
      });
    }
  }
});

// libs/commands/publish/src/lib/get-packages-without-license.ts
var require_get_packages_without_license = __commonJS({
  "libs/commands/publish/src/lib/get-packages-without-license.ts"(exports2, module2) {
    "use strict";
    var import_path17 = __toESM(require("path"));
    module2.exports.getPackagesWithoutLicense = getPackagesWithoutLicense;
    function getPackagesWithoutLicense(project, packagesToPublish) {
      return project.getPackageLicensePaths().then((licensePaths) => {
        const licensed = new Set(licensePaths.map((lp) => import_path17.default.dirname(lp)));
        return packagesToPublish.filter((pkg) => !licensed.has(pkg.location));
      });
    }
  }
});

// libs/commands/publish/src/lib/git-checkout.ts
var require_git_checkout = __commonJS({
  "libs/commands/publish/src/lib/git-checkout.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var childProcess11 = require("@lerna/child-process");
    module2.exports.gitCheckout = gitCheckout;
    function gitCheckout(stagedFiles, gitOpts, execOpts) {
      const files = gitOpts.granularPathspec ? stagedFiles : ".";
      import_npmlog38.default.silly("gitCheckout", files);
      return childProcess11.exec("git", ["checkout", "--"].concat(files), execOpts);
    }
  }
});

// libs/commands/publish/src/lib/remove-temp-licenses.ts
var require_remove_temp_licenses = __commonJS({
  "libs/commands/publish/src/lib/remove-temp-licenses.ts"(exports2, module2) {
    "use strict";
    var import_fs_extra11 = __toESM(require("fs-extra"));
    var import_p_map5 = __toESM(require("p-map"));
    module2.exports.removeTempLicenses = removeTempLicenses;
    function removeTempLicenses(packagesToBeLicensed) {
      if (!packagesToBeLicensed.length) {
        return Promise.resolve();
      }
      return (0, import_p_map5.default)(packagesToBeLicensed, (pkg) => import_fs_extra11.default.remove(pkg.licensePath));
    }
  }
});

// libs/commands/publish/src/lib/verify-npm-package-access.ts
var require_verify_npm_package_access = __commonJS({
  "libs/commands/publish/src/lib/verify-npm-package-access.ts"(exports2, module2) {
    "use strict";
    init_src();
    var import_libnpmaccess = __toESM(require("libnpmaccess"));
    var { getFetchConfig } = require_fetch_config();
    module2.exports.verifyNpmPackageAccess = verifyNpmPackageAccess;
    function verifyNpmPackageAccess(packages, username, options) {
      const opts = getFetchConfig(options, {
        fetchRetries: 0
      });
      opts.log.silly("verifyNpmPackageAccess");
      return pulseTillDone(import_libnpmaccess.default.lsPackages(username, opts)).then(success, failure);
      function success(result) {
        if (result === null) {
          opts.log.warn(
            "",
            "The logged-in user does not have any previously-published packages, skipping permission checks..."
          );
        } else {
          for (const pkg of packages) {
            if (pkg.name in result && result[pkg.name] !== "read-write") {
              throw new ValidationError(
                "EACCESS",
                `You do not have write permission required to publish "${pkg.name}"`
              );
            }
          }
        }
      }
      function failure(err) {
        if (err.code === "E500" || err.code === "E404") {
          opts.log.warn(
            "EREGISTRY",
            "Registry %j does not support `npm access ls-packages`, skipping permission checks...",
            opts.registry
          );
          return;
        }
        opts.log.pause();
        console.error(err.message);
        opts.log.resume();
        throw new ValidationError("EWHOAMI", "Authentication error. Use `npm whoami` to troubleshoot.");
      }
    }
  }
});

// libs/commands/publish/src/lib/get-two-factor-auth-required.ts
var require_get_two_factor_auth_required = __commonJS({
  "libs/commands/publish/src/lib/get-two-factor-auth-required.ts"(exports2, module2) {
    "use strict";
    init_src();
    var { getFetchConfig } = require_fetch_config();
    var { getProfileData } = require_get_profile_data();
    module2.exports.getTwoFactorAuthRequired = getTwoFactorAuthRequired;
    function getTwoFactorAuthRequired(options) {
      const opts = getFetchConfig(options, {
        fetchRetries: 0
      });
      opts.log.info("", "Checking two-factor auth mode");
      return getProfileData(opts).then(success, failure);
      function success(result) {
        opts.log.silly("2FA", result.tfa);
        if (result.tfa.pending) {
          return false;
        }
        return result.tfa.mode === "auth-and-writes";
      }
      function failure(err) {
        if (err.code === "E500" || err.code === "E404") {
          opts.log.warn(
            "EREGISTRY",
            `Registry "${opts.registry}" does not support 'npm profile get', skipping two-factor auth check...`
          );
          return false;
        }
        opts.log.pause();
        console.error(err.message);
        opts.log.resume();
        throw new ValidationError("ETWOFACTOR", "Unable to obtain two-factor auth mode");
      }
    }
  }
});

// libs/commands/publish/src/index.ts
var require_src2 = __commonJS({
  "libs/commands/publish/src/index.ts"(exports2, module2) {
    "use strict";
    init_src();
    var import_crypto = __toESM(require("crypto"));
    var import_fs4 = __toESM(require("fs"));
    var import_os3 = __toESM(require("os"));
    var import_p_map5 = __toESM(require("p-map"));
    var import_p_pipe = __toESM(require("p-pipe"));
    var import_path17 = __toESM(require("path"));
    var import_semver5 = __toESM(require("semver"));
    var versionCommand = require_src();
    var { createTempLicenses } = require_create_temp_licenses();
    var { getCurrentSHA } = require_get_current_sha();
    var { getCurrentTags } = require_get_current_tags();
    var { getUnpublishedPackages } = require_get_unpublished_packages();
    var { getNpmUsername } = require_get_npm_username();
    var { getTaggedPackages } = require_get_tagged_packages();
    var { getPackagesWithoutLicense } = require_get_packages_without_license();
    var { gitCheckout } = require_git_checkout();
    var { removeTempLicenses } = require_remove_temp_licenses();
    var { verifyNpmPackageAccess } = require_verify_npm_package_access();
    var { getTwoFactorAuthRequired } = require_get_two_factor_auth_required();
    module2.exports = function factory(argv) {
      return new PublishCommand(argv);
    };
    var PublishCommand = class extends Command {
      get otherCommandConfigs() {
        return ["version"];
      }
      get requiresGit() {
        return this.options.bump !== "from-package";
      }
      configureProperties() {
        super.configureProperties();
        this.toposort = this.options.sort !== false;
        const {
          exact,
          gitHead,
          gitReset,
          tagVersionPrefix = "v",
          verifyAccess
        } = this.options;
        if (this.requiresGit && gitHead) {
          throw new ValidationError("EGITHEAD", "--git-head is only allowed with 'from-package' positional");
        }
        this.savePrefix = exact ? "" : "^";
        this.tagPrefix = tagVersionPrefix;
        this.gitReset = gitReset !== false;
        this.npmSession = import_crypto.default.randomBytes(8).toString("hex");
        this.verifyAccess = verifyAccess;
      }
      get userAgent() {
        return `lerna/${this.options.lernaVersion}/node@${process.version}+${process.arch} (${process.platform})`;
      }
      initialize() {
        if (this.options.verifyAccess === false) {
          this.logger.warn(
            "verify-access",
            "--verify-access=false and --no-verify-access are no longer needed, because the legacy preemptive access verification is now disabled by default. Requests will fail with appropriate errors when not authorized correctly."
          );
        }
        if (this.options.graphType === "dependencies") {
          this.logger.warn(
            "graph-type",
            "--graph-type=dependencies is deprecated and will be removed in lerna v6. If you have a use-case you feel requires it please open an issue to discuss: https://github.com/lerna/lerna/issues/new/choose"
          );
        }
        if (this.options.includePrivate) {
          if (this.options.includePrivate.length === 0) {
            throw new ValidationError(
              "EINCLPRIV",
              "Must specify at least one private package to include with --include-private."
            );
          }
          this.logger.info("publish", `Including private packages %j`, this.options.includePrivate);
        }
        if (this.options.skipNpm) {
          this.logger.warn("deprecated", "Instead of --skip-npm, call `lerna version` directly");
          return versionCommand(this.argv).then(() => false);
        }
        if (this.options.canary) {
          this.logger.info("canary", "enabled");
        }
        if (this.options.requireScripts) {
          this.logger.info("require-scripts", "enabled");
        }
        this.logger.verbose("session", this.npmSession);
        this.logger.verbose("user-agent", this.userAgent);
        this.conf = npmConf2({
          lernaCommand: "publish",
          _auth: this.options.legacyAuth,
          npmSession: this.npmSession,
          npmVersion: this.userAgent,
          otp: this.options.otp,
          registry: this.options.registry,
          "ignore-prepublish": this.options.ignorePrepublish,
          "ignore-scripts": this.options.ignoreScripts
        });
        this.otpCache = { otp: this.conf.get("otp") };
        this.conf.set("user-agent", this.userAgent, "cli");
        if (this.conf.get("registry") === "https://registry.yarnpkg.com") {
          this.logger.warn("", "Yarn's registry proxy is broken, replacing with public npm registry");
          this.logger.warn("", "If you don't have an npm token, you should exit and run `npm login`");
          this.conf.set("registry", "https://registry.npmjs.org/", "cli");
        }
        const distTag = this.getDistTag();
        if (distTag) {
          this.conf.set("tag", distTag.trim(), "cli");
        }
        this.hasRootedLeaf = this.packageGraph.has(this.project.manifest.name);
        if (this.hasRootedLeaf) {
          this.logger.info("publish", "rooted leaf detected, skipping synthetic root lifecycles");
        }
        this.runPackageLifecycle = createRunner(this.options);
        this.runRootLifecycle = /^(pre|post)?publish$/.test(process.env.npm_lifecycle_event) ? (stage) => {
          this.logger.warn("lifecycle", "Skipping root %j because it has already been called", stage);
        } : (stage) => this.runPackageLifecycle(this.project.manifest, stage);
        let chain = Promise.resolve();
        if (this.options.bump === "from-git") {
          chain = chain.then(() => this.detectFromGit());
        } else if (this.options.bump === "from-package") {
          chain = chain.then(() => this.detectFromPackage());
        } else if (this.options.canary) {
          chain = chain.then(() => this.detectCanaryVersions());
        } else {
          chain = chain.then(() => versionCommand(this.argv));
        }
        return chain.then((result) => {
          if (!result) {
            return false;
          }
          if (!result.updates.length) {
            this.logger.success("No changed packages to publish");
            return false;
          }
          this.updates = this.filterPrivatePkgUpdates(result.updates);
          this.updatesVersions = new Map(result.updatesVersions);
          this.packagesToPublish = this.updates.map((node) => node.pkg);
          if (this.options.contents) {
            for (const pkg of this.packagesToPublish) {
              pkg.contents = this.options.contents;
            }
          }
          if (result.needsConfirmation) {
            return this.confirmPublish();
          }
          return true;
        });
      }
      execute() {
        this.enableProgressBar();
        this.logger.info("publish", "Publishing packages to npm...");
        let chain = Promise.resolve();
        chain = chain.then(() => this.prepareRegistryActions());
        chain = chain.then(() => this.prepareLicenseActions());
        chain = chain.then(() => this.preparePrivatePackages());
        if (this.options.canary) {
          chain = chain.then(() => this.updateCanaryVersions());
        }
        chain = chain.then(() => this.resolveLocalDependencyLinks());
        chain = chain.then(() => this.resolveWorkspaceDependencyLinks());
        chain = chain.then(() => this.annotateGitHead());
        chain = chain.then(() => this.serializeChanges());
        chain = chain.then(() => this.packUpdated());
        chain = chain.then(() => this.publishPacked());
        chain = chain.then(() => this.restorePrivatePackages());
        chain = chain.then(() => this.serializeChanges());
        if (this.gitReset) {
          chain = chain.then(() => this.resetChanges());
        }
        if (this.options.tempTag) {
          chain = chain.then(() => this.npmUpdateAsLatest());
        }
        return chain.then(() => {
          const count = this.publishedPackages.length;
          const publishedPackagesSorted = this.publishedPackages.sort((a, b) => a.name.localeCompare(b.name));
          if (!count) {
            this.logger.success("All packages have already been published.");
            return;
          }
          output("Successfully published:");
          if (this.options.summaryFile !== void 0) {
            const filePath = this.options.summaryFile ? `${this.options.summaryFile}/lerna-publish-summary.json` : "./lerna-publish-summary.json";
            const jsonObject = publishedPackagesSorted.map((pkg) => {
              return {
                packageName: pkg.name,
                version: pkg.version
              };
            });
            output(jsonObject);
            try {
              import_fs4.default.writeFileSync(filePath, JSON.stringify(jsonObject));
              output("Publish summary created: ", filePath);
            } catch (error) {
              output("Failed to create the summary report", error);
            }
          } else {
            const message = publishedPackagesSorted.map((pkg) => ` - ${pkg.name}@${pkg.version}`);
            output(message.join(import_os3.default.EOL));
          }
          this.logger.success("published", "%d %s", count, count === 1 ? "package" : "packages");
        });
      }
      verifyWorkingTreeClean() {
        return describeRef(this.execOpts).then(throwIfUncommitted);
      }
      detectFromGit() {
        const matchingPattern = this.project.isIndependent() ? "*@*" : `${this.tagPrefix}*.*.*`;
        let chain = Promise.resolve();
        chain = chain.then(() => this.verifyWorkingTreeClean()).catch((err) => {
          if (err.failed && /git describe/.test(err.command)) {
            this.logger.silly("EWORKINGTREE", err.message);
            this.logger.notice("FYI", "Unable to verify working tree, proceed at your own risk");
          } else {
            throw err;
          }
        });
        chain = chain.then(() => getCurrentTags(this.execOpts, matchingPattern));
        chain = chain.then((taggedPackageNames) => {
          if (!taggedPackageNames.length) {
            this.logger.notice("from-git", "No tagged release found");
            return [];
          }
          if (this.project.isIndependent()) {
            return taggedPackageNames.map((name) => this.packageGraph.get(name));
          }
          return getTaggedPackages(this.packageGraph, this.project.rootPath, this.execOpts);
        });
        chain = chain.then((updates) => this.filterPrivatePkgUpdates(updates));
        return chain.then((updates) => {
          const updatesVersions = updates.map((node) => [node.name, node.version]);
          return {
            updates,
            updatesVersions,
            needsConfirmation: true
          };
        });
      }
      detectFromPackage() {
        let chain = Promise.resolve();
        chain = chain.then(() => this.verifyWorkingTreeClean()).catch((err) => {
          if (err.failed && /git describe/.test(err.command)) {
            this.logger.silly("EWORKINGTREE", err.message);
            this.logger.notice("FYI", "Unable to verify working tree, proceed at your own risk");
          } else {
            throw err;
          }
        });
        chain = chain.then(() => getUnpublishedPackages(this.packageGraph, this.conf.snapshot));
        chain = chain.then((updates) => this.filterPrivatePkgUpdates(updates));
        chain = chain.then((unpublished) => {
          if (!unpublished.length) {
            this.logger.notice("from-package", "No unpublished release found");
          }
          return unpublished;
        });
        return chain.then((updates) => {
          const updatesVersions = updates.map((node) => [node.name, node.version]);
          return {
            updates,
            updatesVersions,
            needsConfirmation: true
          };
        });
      }
      detectCanaryVersions() {
        const { cwd } = this.execOpts;
        const {
          bump = "prepatch",
          preid = "alpha",
          ignoreChanges,
          forcePublish,
          includeMergedTags
        } = this.options;
        const release = bump.startsWith("pre") ? bump.replace("release", "patch") : `pre${bump}`;
        let chain = Promise.resolve();
        chain = chain.then(() => this.verifyWorkingTreeClean()).catch((err) => {
          if (err.failed && /git describe/.test(err.command)) {
            this.logger.silly("EWORKINGTREE", err.message);
            this.logger.notice("FYI", "Unable to verify working tree, proceed at your own risk");
          } else {
            throw err;
          }
        });
        chain = chain.then(
          () => this.filterPrivatePkgUpdates(
            collectUpdates(this.packageGraph.rawPackageList, this.packageGraph, this.execOpts, {
              bump: "prerelease",
              canary: true,
              ignoreChanges,
              forcePublish,
              includeMergedTags
            })
          )
        );
        const makeVersion = (fallback) => ({ lastVersion = fallback, refCount, sha }) => {
          const nextVersion = import_semver5.default.inc(lastVersion.replace(this.tagPrefix, ""), release.replace("pre", ""));
          return `${nextVersion}-${preid}.${Math.max(0, refCount - 1)}+${sha}`;
        };
        if (this.project.isIndependent()) {
          chain = chain.then(
            (updates) => (0, import_p_map5.default)(
              updates,
              (node) => describeRef(
                {
                  match: `${node.name}@*`,
                  cwd
                },
                includeMergedTags
              ).then(makeVersion(node.version)).then((version) => [node.name, version])
            ).then((updatesVersions) => ({
              updates,
              updatesVersions
            }))
          );
        } else {
          chain = chain.then(
            (updates) => describeRef(
              {
                match: `${this.tagPrefix}*.*.*`,
                cwd
              },
              includeMergedTags
            ).then(makeVersion(this.project.version)).then((version) => updates.map((node) => [node.name, version])).then((updatesVersions) => ({
              updates,
              updatesVersions
            }))
          );
        }
        return chain.then(({ updates, updatesVersions }) => ({
          updates,
          updatesVersions,
          needsConfirmation: true
        }));
      }
      confirmPublish() {
        const count = this.packagesToPublish.length;
        const message = this.packagesToPublish.map(
          (pkg) => ` - ${pkg.name} => ${this.updatesVersions.get(pkg.name)}${pkg.private ? " (private!)" : ""}`
        );
        output("");
        output(`Found ${count} ${count === 1 ? "package" : "packages"} to publish:`);
        output(message.join(import_os3.default.EOL));
        output("");
        if (this.options.yes) {
          this.logger.info("auto-confirmed");
          return true;
        }
        return promptConfirmation("Are you sure you want to publish these packages?");
      }
      preparePrivatePackages() {
        return Promise.resolve().then(() => {
          this.privatePackagesToPublish = [];
          this.packagesToPublish.forEach((pkg) => {
            if (pkg.private) {
              pkg.removePrivate();
              this.privatePackagesToPublish.push(pkg);
            }
          });
        });
      }
      restorePrivatePackages() {
        return Promise.resolve().then(() => {
          this.privatePackagesToPublish.forEach((pkg) => {
            pkg.private = true;
          });
        });
      }
      prepareLicenseActions() {
        return Promise.resolve().then(() => getPackagesWithoutLicense(this.project, this.packagesToPublish)).then((packagesWithoutLicense) => {
          if (packagesWithoutLicense.length && !this.project.licensePath) {
            this.packagesToBeLicensed = [];
            const names = packagesWithoutLicense.map((pkg) => pkg.name);
            const noun = names.length > 1 ? "Packages" : "Package";
            const verb = names.length > 1 ? "are" : "is";
            const list2 = names.length > 1 ? `${names.slice(0, -1).join(", ")}${names.length > 2 ? "," : ""} and ${names[names.length - 1]}` : names[0];
            this.logger.warn(
              "ENOLICENSE",
              "%s %s %s missing a license.\n%s\n%s",
              noun,
              list2,
              verb,
              "One way to fix this is to add a LICENSE.md file to the root of this repository.",
              "See https://choosealicense.com for additional guidance."
            );
          } else {
            this.packagesToBeLicensed = packagesWithoutLicense;
          }
        });
      }
      prepareRegistryActions() {
        let chain = Promise.resolve();
        if (this.conf.get("registry") !== "https://registry.npmjs.org/") {
          this.logger.notice("", "Skipping all user and access validation due to third-party registry");
          this.logger.notice("", "Make sure you're authenticated properly \xAF\\_(\u30C4)_/\xAF");
          return chain;
        }
        if (process.env.LERNA_INTEGRATION) {
          return chain;
        }
        if (this.verifyAccess) {
          chain = chain.then(() => getNpmUsername(this.conf.snapshot));
          chain = chain.then((username) => {
            if (username) {
              return verifyNpmPackageAccess(this.packagesToPublish, username, this.conf.snapshot);
            }
          });
          chain = chain.then(() => getTwoFactorAuthRequired(this.conf.snapshot));
          chain = chain.then((isRequired) => {
            this.twoFactorAuthRequired = isRequired;
          });
        }
        return chain;
      }
      updateCanaryVersions() {
        return (0, import_p_map5.default)(this.updates, (node) => {
          node.pkg.set("version", this.updatesVersions.get(node.name));
          for (const [depName, resolved] of node.localDependencies) {
            const depVersion = this.updatesVersions.get(depName) || this.packageGraph.get(depName).pkg.version;
            node.pkg.updateLocalDependency(resolved, depVersion, this.savePrefix);
          }
        });
      }
      resolveLocalDependencyLinks() {
        const updatesWithLocalLinks = this.updates.filter(
          (node) => Array.from(node.localDependencies.values()).some((resolved) => resolved.type === "directory")
        );
        return (0, import_p_map5.default)(updatesWithLocalLinks, (node) => {
          for (const [depName, resolved] of node.localDependencies) {
            const depVersion = this.updatesVersions.get(depName) || this.packageGraph.get(depName).pkg.version;
            node.pkg.updateLocalDependency(resolved, depVersion, this.savePrefix);
          }
        });
      }
      resolveWorkspaceDependencyLinks() {
        const updatesWithWorkspaceLinks = this.updates.filter(
          (node) => Array.from(node.localDependencies.values()).some((resolved) => !!resolved.workspaceSpec)
        );
        return (0, import_p_map5.default)(updatesWithWorkspaceLinks, (node) => {
          for (const [depName, resolved] of node.localDependencies) {
            if (resolved.workspaceSpec) {
              let depVersion;
              let savePrefix;
              if (resolved.workspaceAlias) {
                depVersion = this.updatesVersions.get(depName) || this.packageGraph.get(depName).pkg.version;
                savePrefix = resolved.workspaceAlias === "*" ? "" : resolved.workspaceAlias;
              } else {
                const specMatch = resolved.workspaceSpec.match(/^workspace:([~^]?)(.*)/);
                savePrefix = specMatch[1];
                depVersion = specMatch[2];
              }
              node.pkg.updateLocalDependency(resolved, depVersion, savePrefix, { retainWorkspacePrefix: false });
            }
          }
        });
      }
      annotateGitHead() {
        try {
          const gitHead = this.options.gitHead || getCurrentSHA(this.execOpts);
          for (const pkg of this.packagesToPublish) {
            pkg.set("gitHead", gitHead);
          }
        } catch (err) {
          this.logger.silly("EGITHEAD", err.message);
          this.logger.notice(
            "FYI",
            "Unable to set temporary gitHead property, it will be missing from registry metadata"
          );
        }
      }
      serializeChanges() {
        return (0, import_p_map5.default)(this.packagesToPublish, (pkg) => pkg.serialize());
      }
      resetChanges() {
        const { cwd } = this.execOpts;
        const gitOpts = {
          granularPathspec: this.options.granularPathspec !== false
        };
        const dirtyManifests = [this.project.manifest].concat(this.packagesToPublish).map((pkg) => import_path17.default.relative(cwd, pkg.manifestLocation));
        return gitCheckout(dirtyManifests, gitOpts, this.execOpts).catch((err) => {
          this.logger.silly("EGITCHECKOUT", err.message);
          this.logger.notice("FYI", "Unable to reset working tree changes, this probably isn't a git repo.");
        });
      }
      execScript(pkg, script) {
        const scriptLocation = import_path17.default.join(pkg.location, "scripts", script);
        try {
          require(scriptLocation);
        } catch (ex) {
          this.logger.silly("execScript", `No ${script} script found at ${scriptLocation}`);
        }
        return pkg;
      }
      removeTempLicensesOnError(error) {
        return Promise.resolve().then(
          () => removeTempLicenses(this.packagesToBeLicensed).catch((removeError) => {
            this.logger.error(
              "licenses",
              "error removing temporary license files",
              removeError.stack || removeError
            );
          })
        ).then(() => {
          throw error;
        });
      }
      requestOneTimePassword() {
        if (this.otpCache.otp) {
          return;
        }
        return Promise.resolve().then(() => getOneTimePassword("Enter OTP:")).then((otp) => {
          this.otpCache.otp = otp;
        });
      }
      topoMapPackages(mapper) {
        return runTopologically(this.packagesToPublish, mapper, {
          concurrency: this.concurrency,
          rejectCycles: this.options.rejectCycles,
          graphType: this.options.graphType === "dependencies" ? "dependencies" : "allDependencies"
        });
      }
      packUpdated() {
        const tracker = this.logger.newItem("npm pack");
        tracker.addWork(this.packagesToPublish.length);
        let chain = Promise.resolve();
        chain = chain.then(() => createTempLicenses(this.project.licensePath, this.packagesToBeLicensed));
        if (!this.hasRootedLeaf) {
          chain = chain.then(() => this.runRootLifecycle("prepublish"));
          chain = chain.then(() => this.runPackageLifecycle(this.project.manifest, "prepare"));
          chain = chain.then(() => this.runPackageLifecycle(this.project.manifest, "prepublishOnly"));
          chain = chain.then(() => this.runPackageLifecycle(this.project.manifest, "prepack"));
        }
        const opts = this.conf.snapshot;
        const mapper = (0, import_p_pipe.default)(
          ...[
            this.options.requireScripts && ((pkg) => this.execScript(pkg, "prepublish")),
            (pkg) => pulseTillDone(packDirectory(pkg, pkg.location, opts)).then((packed) => {
              tracker.verbose("packed", import_path17.default.relative(this.project.rootPath, pkg.contents));
              tracker.completeWork(1);
              pkg.packed = packed;
              return pkg.refresh();
            })
          ].filter(Boolean)
        );
        chain = chain.then(() => {
          if (this.toposort) {
            return this.topoMapPackages(mapper);
          }
          return (0, import_p_map5.default)(this.packagesToPublish, mapper, { concurrency: this.concurrency });
        });
        chain = chain.then(() => removeTempLicenses(this.packagesToBeLicensed));
        chain = chain.catch((error) => this.removeTempLicensesOnError(error));
        if (!this.hasRootedLeaf) {
          chain = chain.then(() => this.runPackageLifecycle(this.project.manifest, "postpack"));
        }
        return chain.finally(() => tracker.finish());
      }
      publishPacked() {
        this.publishedPackages = [];
        const tracker = this.logger.newItem("publish");
        tracker.addWork(this.packagesToPublish.length);
        let chain = Promise.resolve();
        if (this.twoFactorAuthRequired) {
          chain = chain.then(() => this.requestOneTimePassword());
        }
        const opts = Object.assign(this.conf.snapshot, {
          tag: this.options.tempTag ? "lerna-temp" : this.conf.get("tag")
        });
        const mapper = (0, import_p_pipe.default)(
          ...[
            (pkg) => {
              const preDistTag = this.getPreDistTag(pkg);
              const tag = !this.options.tempTag && preDistTag ? preDistTag : opts.tag;
              const pkgOpts = Object.assign({}, opts, { tag });
              return pulseTillDone(npmPublish(pkg, pkg.packed.tarFilePath, pkgOpts, this.otpCache)).then(() => {
                this.publishedPackages.push(pkg);
                tracker.success("published", pkg.name, pkg.version);
                tracker.completeWork(1);
                logPacked(pkg.packed);
                return pkg;
              }).catch((err) => {
                if (err.code === "EPUBLISHCONFLICT") {
                  tracker.warn("publish", `Package is already published: ${pkg.name}@${pkg.version}`);
                  tracker.completeWork(1);
                  return pkg;
                }
                this.logger.silly("", err);
                this.logger.error(err.code, err.body && err.body.error || err.message);
                err.name = "ValidationError";
                process.exitCode = "errno" in err ? err.errno : 1;
                throw err;
              });
            },
            this.options.requireScripts && ((pkg) => this.execScript(pkg, "postpublish"))
          ].filter(Boolean)
        );
        chain = chain.then(() => {
          if (this.toposort) {
            return this.topoMapPackages(mapper);
          }
          return (0, import_p_map5.default)(this.packagesToPublish, mapper, { concurrency: this.concurrency });
        });
        if (!this.hasRootedLeaf) {
          chain = chain.then(() => this.runRootLifecycle("publish"));
          chain = chain.then(() => this.runRootLifecycle("postpublish"));
        }
        return chain.finally(() => tracker.finish());
      }
      npmUpdateAsLatest() {
        const tracker = this.logger.newItem("npmUpdateAsLatest");
        tracker.addWork(this.packagesToPublish.length);
        tracker.showProgress();
        let chain = Promise.resolve();
        const opts = this.conf.snapshot;
        const getDistTag = (publishConfig) => {
          if (opts.tag === "latest" && publishConfig && publishConfig.tag) {
            return publishConfig.tag;
          }
          return opts.tag;
        };
        const mapper = (pkg) => {
          const spec = `${pkg.name}@${pkg.version}`;
          const preDistTag = this.getPreDistTag(pkg);
          const distTag = preDistTag || getDistTag(pkg.get("publishConfig"));
          return Promise.resolve().then(() => pulseTillDone(npmDistTag.remove(spec, "lerna-temp", opts, this.otpCache))).then(() => pulseTillDone(npmDistTag.add(spec, distTag, opts, this.otpCache))).then(() => {
            tracker.success("dist-tag", "%s@%s => %j", pkg.name, pkg.version, distTag);
            tracker.completeWork(1);
            return pkg;
          });
        };
        chain = chain.then(() => {
          if (this.toposort) {
            return this.topoMapPackages(mapper);
          }
          return (0, import_p_map5.default)(this.packagesToPublish, mapper, { concurrency: this.concurrency });
        });
        return chain.finally(() => tracker.finish());
      }
      getDistTag() {
        if (this.options.distTag) {
          return this.options.distTag;
        }
        if (this.options.canary) {
          return "canary";
        }
      }
      getPreDistTag(pkg) {
        if (!this.options.preDistTag) {
          return;
        }
        const isPrerelease = prereleaseIdFromVersion(pkg.version);
        if (isPrerelease) {
          return this.options.preDistTag;
        }
      }
      filterPrivatePkgUpdates(updates) {
        const privatePackagesToInclude = new Set(this.options.includePrivate || []);
        return updates.filter(
          (node) => !node.pkg.private || privatePackagesToInclude.has("*") || privatePackagesToInclude.has(node.pkg.name)
        );
      }
    };
    module2.exports.PublishCommand = PublishCommand;
  }
});

// libs/commands/publish/src/command.ts
var require_command2 = __commonJS({
  "libs/commands/publish/src/command.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var versionCommand = require_command();
    function composeVersionOptions(yargs2) {
      versionCommand.addBumpPositional(yargs2, ["from-git", "from-package"]);
      versionCommand.builder(yargs2, "publish");
      return yargs2;
    }
    var command = {
      command: "publish [bump]",
      describe: "Publish packages in the current project",
      builder(yargs2) {
        const opts = {
          c: {
            describe: "Publish packages after every successful merge using the sha as part of the tag.",
            alias: "canary",
            type: "boolean"
          },
          preid: {
            describe: "Specify the prerelease identifier when publishing a prerelease",
            type: "string",
            requiresArg: true,
            defaultDescription: "alpha"
          },
          contents: {
            describe: "Subdirectory to publish. Must apply to ALL packages.",
            type: "string",
            requiresArg: true,
            defaultDescription: "."
          },
          "dist-tag": {
            describe: "Publish packages with the specified npm dist-tag",
            type: "string",
            requiresArg: true
          },
          "legacy-auth": {
            describe: "Legacy Base64 Encoded username and password.",
            type: "string"
          },
          "pre-dist-tag": {
            describe: "Publish prerelease packages with the specified npm dist-tag",
            type: "string",
            requiresArg: true
          },
          "git-head": {
            describe: "Explicit SHA to set as gitHead when packing tarballs, only allowed with 'from-package' positional.",
            type: "string",
            requiresArg: true
          },
          "graph-type": {
            describe: "Type of dependency to use when determining package hierarchy.",
            choices: ["all", "dependencies"],
            defaultDescription: "dependencies"
          },
          "ignore-prepublish": {
            describe: "Disable deprecated 'prepublish' lifecycle script",
            type: "boolean"
          },
          "ignore-scripts": {
            describe: "Disable all lifecycle scripts",
            type: "boolean"
          },
          "no-granular-pathspec": {
            describe: "Do not reset changes file-by-file, but globally.",
            type: "boolean"
          },
          "granular-pathspec": {
            hidden: true,
            type: "boolean"
          },
          otp: {
            describe: "Supply a one-time password for publishing with two-factor authentication.",
            type: "string",
            requiresArg: true
          },
          registry: {
            describe: "Use the specified registry for all npm client operations.",
            type: "string",
            requiresArg: true
          },
          "require-scripts": {
            describe: "Execute ./scripts/prepublish.js and ./scripts/postpublish.js, relative to package root.",
            type: "boolean"
          },
          "no-git-reset": {
            describe: "Do not reset changes to working tree after publishing is complete.",
            type: "boolean"
          },
          "git-reset": {
            hidden: true,
            type: "boolean"
          },
          "temp-tag": {
            describe: "Create a temporary tag while publishing.",
            type: "boolean"
          },
          "no-verify-access": {
            describe: "Do not verify package read-write access for current npm user.",
            type: "boolean"
          },
          "verify-access": {
            describe: "Verify package read-write access for current npm user.",
            type: "boolean"
          },
          "summary-file": {
            describe: "Generate a json summary report after all packages have been successfully published, you can pass an optional path for where to save the file.",
            type: "string"
          },
          "include-private": {
            describe: "Include specified private packages when publishing by temporarily removing the private property from the package manifest. This should only be used for testing private packages that will become public. Private packages should not usually be published. See the npm docs for details (https://docs.npmjs.com/cli/v9/configuring-npm/package-json#private).",
            type: "array"
          }
        };
        composeVersionOptions(yargs2);
        yargs2.options(opts);
        const { hiddenOptions } = yargs2.getOptions();
        const sharedKeys = ["preid", "y", "ignore-scripts"];
        for (const sharedKey of sharedKeys) {
          hiddenOptions.splice(
            hiddenOptions.findIndex((k) => k === sharedKey),
            1
          );
        }
        yargs2.group(Object.keys(opts).concat(sharedKeys), "Command Options:");
        return yargs2.option("npm-tag", {
          hidden: true,
          conflicts: "dist-tag",
          type: "string",
          requiresArg: true
        }).option("verify-registry", {
          hidden: true,
          type: "boolean"
        }).option("skip-npm", {
          hidden: true,
          type: "boolean"
        }).check((argv) => {
          if (argv["npmTag"]) {
            argv["distTag"] = argv["npmTag"];
            argv["dist-tag"] = argv["npmTag"];
            delete argv["npmTag"];
            delete argv["npm-tag"];
            import_npmlog38.default.warn("deprecated", "--npm-tag has been renamed --dist-tag");
          }
          return argv;
        }).middleware((args) => {
          const { includePrivate } = args;
          if (includePrivate && Array.isArray(includePrivate)) {
            args["includePrivate"] = includePrivate.reduce((acc, pkg) => [...acc, ...pkg.split(/[\s,]/)], []);
          }
        }, true);
      },
      handler(argv) {
        return require_src2()(argv);
      }
    };
    module2.exports = command;
  }
});

// packages/lerna/src/commands/publish/command.ts
module.exports = require_command2();
