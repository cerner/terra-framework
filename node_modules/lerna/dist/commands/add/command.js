"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// libs/core/src/lib/collect-uncommitted.ts
function collectUncommitted({ cwd, log: log36 = import_npmlog.default }) {
  log36.silly("collect-uncommitted", "git status --porcelain (async)");
  return childProcess.exec("git", ["status", "--porcelain"], { cwd }).then(({ stdout }) => transformOutput(stdout));
}
var import_chalk, import_npmlog, childProcess, maybeColorize, cRed, cGreen, replaceStatus, colorizeStats, splitOnNewLine, filterEmpty, o, transformOutput;
var init_collect_uncommitted = __esm({
  "libs/core/src/lib/collect-uncommitted.ts"() {
    "use strict";
    import_chalk = __toESM(require("chalk"));
    import_npmlog = __toESM(require("npmlog"));
    childProcess = require("@lerna/child-process");
    maybeColorize = (colorize) => (s) => s !== " " ? colorize(s) : s;
    cRed = maybeColorize(import_chalk.default.red);
    cGreen = maybeColorize(import_chalk.default.green);
    replaceStatus = (_, maybeGreen, maybeRed) => `${cGreen(maybeGreen)}${cRed(maybeRed)}`;
    colorizeStats = (stats) => stats.replace(/^([^U]| )([A-Z]| )/gm, replaceStatus).replace(/^\?{2}|U{2}/gm, cRed("$&"));
    splitOnNewLine = (str) => str.split("\n");
    filterEmpty = (lines) => lines.filter((line) => line.length);
    o = (l, r) => (x) => l(r(x));
    transformOutput = o(filterEmpty, o(splitOnNewLine, colorizeStats));
  }
});

// libs/core/src/lib/describe-ref.ts
function getArgs(options, includeMergedTags = false) {
  let args = [
    "describe",
    "--always",
    "--long",
    "--dirty",
    "--first-parent"
  ];
  if (options.match) {
    args.push("--match", options.match);
  }
  if (includeMergedTags) {
    args = args.filter((arg) => arg !== "--first-parent");
  }
  return args;
}
function describeRefSync(options = {}, includeMergedTags) {
  const stdout = childProcess2.execSync("git", getArgs(options, includeMergedTags), options);
  const result = parse(stdout, options.cwd);
  import_npmlog2.default.silly("git-describe.sync", "%j => %j", stdout, result);
  return result;
}
function parse(stdout, cwd) {
  const minimalShaRegex = /^([0-9a-f]{7,40})(-dirty)?$/;
  if (minimalShaRegex.test(stdout)) {
    const [, sha2, isDirty2] = minimalShaRegex.exec(stdout);
    const refCount2 = childProcess2.execSync("git", ["rev-list", "--count", sha2], { cwd });
    return { refCount: refCount2, sha: sha2, isDirty: Boolean(isDirty2) };
  }
  const [, lastTagName, lastVersion, refCount, sha, isDirty] = /^((?:.*@)?(.*))-(\d+)-g([0-9a-f]+)(-dirty)?$/.exec(stdout) || [];
  return { lastTagName, lastVersion, refCount, sha, isDirty: Boolean(isDirty) };
}
var import_npmlog2, childProcess2;
var init_describe_ref = __esm({
  "libs/core/src/lib/describe-ref.ts"() {
    "use strict";
    import_npmlog2 = __toESM(require("npmlog"));
    childProcess2 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/validation-error.ts
var import_npmlog3, ValidationError;
var init_validation_error = __esm({
  "libs/core/src/lib/validation-error.ts"() {
    "use strict";
    import_npmlog3 = __toESM(require("npmlog"));
    ValidationError = class extends Error {
      prefix;
      constructor(prefix, message, ...rest) {
        super(message);
        this.name = "ValidationError";
        this.prefix = prefix;
        import_npmlog3.default.resume();
        import_npmlog3.default.error(prefix, message, ...rest);
      }
    };
  }
});

// libs/core/src/lib/check-working-tree.ts
function mkThrowIfUncommitted(options = {}) {
  return function throwIfUncommitted2({ isDirty }) {
    if (isDirty) {
      return collectUncommitted(options).then((uncommitted) => {
        throw new ValidationError("EUNCOMMIT", `${EUNCOMMIT_MSG}${uncommitted.join("\n")}`);
      });
    }
  };
}
var EUNCOMMIT_MSG, throwIfUncommitted;
var init_check_working_tree = __esm({
  "libs/core/src/lib/check-working-tree.ts"() {
    "use strict";
    init_collect_uncommitted();
    init_describe_ref();
    init_validation_error();
    EUNCOMMIT_MSG = "Working tree has uncommitted changes, please commit or remove the following changes before continuing:\n";
    throwIfUncommitted = mkThrowIfUncommitted();
  }
});

// libs/core/src/lib/cli.ts
var import_dedent, import_npmlog4, import_yargs;
var init_cli = __esm({
  "libs/core/src/lib/cli.ts"() {
    "use strict";
    import_dedent = __toESM(require("dedent"));
    import_npmlog4 = __toESM(require("npmlog"));
    import_yargs = __toESM(require("yargs/yargs"));
  }
});

// libs/core/src/lib/collect-updates/collect-dependents.ts
function collectDependents(nodes) {
  const collected = /* @__PURE__ */ new Set();
  nodes.forEach((currentNode) => {
    if (currentNode.localDependents.size === 0) {
      return;
    }
    const queue2 = [currentNode];
    const seen = /* @__PURE__ */ new Set();
    const visit = (dependentNode, dependentName, siblingDependents) => {
      if (seen.has(dependentNode)) {
        return;
      }
      seen.add(dependentNode);
      if (dependentNode === currentNode || siblingDependents.has(currentNode.name)) {
        return;
      }
      collected.add(dependentNode);
      queue2.push(dependentNode);
    };
    while (queue2.length) {
      const node = queue2.shift();
      node.localDependents.forEach(visit);
    }
  });
  return collected;
}
var init_collect_dependents = __esm({
  "libs/core/src/lib/collect-updates/collect-dependents.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/collect-updates/collect-packages.ts
function collectPackages(packages, { isCandidate = () => true, onInclude, excludeDependents } = {}) {
  const candidates = /* @__PURE__ */ new Set();
  packages.forEach((node, name) => {
    if (isCandidate(node, name)) {
      candidates.add(node);
    }
  });
  if (!excludeDependents) {
    collectDependents(candidates).forEach((node) => candidates.add(node));
  }
  const updates = [];
  packages.forEach((node, name) => {
    if (candidates.has(node)) {
      if (onInclude) {
        onInclude(name);
      }
      updates.push(node);
    }
  });
  return updates;
}
var init_collect_packages = __esm({
  "libs/core/src/lib/collect-updates/collect-packages.ts"() {
    "use strict";
    init_collect_dependents();
  }
});

// libs/core/src/lib/collect-updates/get-packages-for-option.ts
function getPackagesForOption(option) {
  let inputs = null;
  if (option === true) {
    inputs = ["*"];
  } else if (typeof option === "string") {
    inputs = option.split(",");
  } else if (Array.isArray(option)) {
    inputs = [...option];
  }
  return new Set(inputs);
}
var init_get_packages_for_option = __esm({
  "libs/core/src/lib/collect-updates/get-packages-for-option.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/collect-updates/has-tags.ts
function hasTags(opts) {
  import_npmlog5.default.silly("hasTags");
  let result = false;
  try {
    result = !!childProcess3.execSync("git", ["tag"], opts);
  } catch (err) {
    import_npmlog5.default.warn("ENOTAGS", "No git tags were reachable from this branch!");
    import_npmlog5.default.verbose("hasTags error", err);
  }
  import_npmlog5.default.verbose("hasTags", result);
  return result;
}
var import_npmlog5, childProcess3;
var init_has_tags = __esm({
  "libs/core/src/lib/collect-updates/has-tags.ts"() {
    "use strict";
    import_npmlog5 = __toESM(require("npmlog"));
    childProcess3 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/collect-updates/make-diff-predicate.ts
function makeDiffPredicate(committish, execOpts, ignorePatterns = []) {
  const ignoreFilters = new Set(
    ignorePatterns.map(
      (p) => import_minimatch.default.filter(`!${p}`, {
        matchBase: true,
        dot: true
      })
    )
  );
  if (ignoreFilters.size) {
    import_npmlog6.default.info("ignoring diff in paths matching", ignorePatterns);
  }
  return function hasDiffSinceThatIsntIgnored(node) {
    const diff = diffSinceIn(committish, node.location, execOpts);
    if (diff === "") {
      import_npmlog6.default.silly("", "no diff found in %s", node.name);
      return false;
    }
    import_npmlog6.default.silly("found diff in", diff);
    let changedFiles = diff.split("\n");
    if (ignoreFilters.size) {
      for (const ignored of ignoreFilters) {
        changedFiles = changedFiles.filter(ignored);
      }
    }
    if (changedFiles.length) {
      import_npmlog6.default.verbose("filtered diff", changedFiles);
    } else {
      import_npmlog6.default.verbose("", "no diff found in %s (after filtering)", node.name);
    }
    return changedFiles.length > 0;
  };
}
function diffSinceIn(committish, location, opts) {
  const args = ["diff", "--name-only", committish];
  const formattedLocation = (0, import_slash.default)(import_path.default.relative(opts.cwd, location));
  if (formattedLocation) {
    args.push("--", formattedLocation);
  }
  import_npmlog6.default.silly("checking diff", formattedLocation);
  return childProcess4.execSync("git", args, opts);
}
var import_npmlog6, import_minimatch, import_path, import_slash, childProcess4;
var init_make_diff_predicate = __esm({
  "libs/core/src/lib/collect-updates/make-diff-predicate.ts"() {
    "use strict";
    import_npmlog6 = __toESM(require("npmlog"));
    import_minimatch = __toESM(require("minimatch"));
    import_path = __toESM(require("path"));
    import_slash = __toESM(require("slash"));
    childProcess4 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/collect-updates/index.ts
function collectUpdates(filteredPackages, packageGraph, execOpts, commandOptions) {
  const { forcePublish, conventionalCommits, conventionalGraduate, excludeDependents } = commandOptions;
  const useConventionalGraduate = conventionalCommits && conventionalGraduate;
  const forced = getPackagesForOption(useConventionalGraduate ? conventionalGraduate : forcePublish);
  const packages = filteredPackages.length === packageGraph.size ? packageGraph : new Map(filteredPackages.map(({ name }) => [name, packageGraph.get(name)]));
  let committish = commandOptions.since;
  if (hasTags(execOpts)) {
    const { sha, refCount, lastTagName } = describeRefSync(execOpts, commandOptions.includeMergedTags);
    if (refCount === "0" && forced.size === 0 && !committish) {
      import_npmlog7.default.notice("", "Current HEAD is already released, skipping change detection.");
      return [];
    }
    if (commandOptions.canary) {
      committish = `${sha}^..${sha}`;
    } else if (!committish) {
      committish = lastTagName;
    }
  }
  if (forced.size) {
    import_npmlog7.default.warn(
      useConventionalGraduate ? "conventional-graduate" : "force-publish",
      forced.has("*") ? "all packages" : Array.from(forced.values()).join("\n")
    );
  }
  if (useConventionalGraduate) {
    if (forced.has("*")) {
      import_npmlog7.default.info("", "Graduating all prereleased packages");
    } else {
      import_npmlog7.default.info("", "Graduating prereleased packages");
    }
  } else if (!committish || forced.has("*")) {
    import_npmlog7.default.info("", "Assuming all packages changed");
    return collectPackages(packages, {
      onInclude: (name) => import_npmlog7.default.verbose("updated", name),
      excludeDependents
    });
  }
  import_npmlog7.default.info("", `Looking for changed packages since ${committish}`);
  const hasDiff = makeDiffPredicate(committish, execOpts, commandOptions.ignoreChanges);
  const needsBump = !commandOptions.bump || commandOptions.bump.startsWith("pre") ? () => false : (node) => node.prereleaseId;
  const isForced = (node, name) => (forced.has("*") || forced.has(name)) && (useConventionalGraduate ? node.prereleaseId : true);
  return collectPackages(packages, {
    isCandidate: (node, name) => isForced(node, name) || needsBump(node) || hasDiff(node),
    onInclude: (name) => import_npmlog7.default.verbose("updated", name),
    excludeDependents
  });
}
var import_npmlog7;
var init_collect_updates = __esm({
  "libs/core/src/lib/collect-updates/index.ts"() {
    "use strict";
    import_npmlog7 = __toESM(require("npmlog"));
    init_describe_ref();
    init_collect_packages();
    init_get_packages_for_option();
    init_has_tags();
    init_make_diff_predicate();
  }
});

// libs/core/src/lib/package-graph/cyclic-package-graph-node.ts
var lastCollapsedNodeId, CyclicPackageGraphNode;
var init_cyclic_package_graph_node = __esm({
  "libs/core/src/lib/package-graph/cyclic-package-graph-node.ts"() {
    "use strict";
    lastCollapsedNodeId = 0;
    CyclicPackageGraphNode = class extends Map {
      name;
      localDependencies;
      localDependents;
      constructor() {
        super();
        this.name = `(cycle) ${lastCollapsedNodeId += 1}`;
        this.localDependencies = /* @__PURE__ */ new Map();
        this.localDependents = /* @__PURE__ */ new Map();
      }
      get isCycle() {
        return true;
      }
      toString() {
        const parts = Array.from(
          this,
          ([key, node]) => node.isCycle ? `(nested cycle: ${node.toString()})` : key
        );
        parts.push(parts[0]);
        return parts.reverse().join(" -> ");
      }
      flatten() {
        const result = [];
        for (const node of this.values()) {
          if (node.isCycle) {
            result.push(...node.flatten());
          } else {
            result.push(node);
          }
        }
        return result;
      }
      contains(name) {
        for (const [currentName, currentNode] of this) {
          if (currentNode.isCycle) {
            if (currentNode.contains(name)) {
              return true;
            }
          } else if (currentName === name) {
            return true;
          }
        }
        return false;
      }
      insert(node) {
        this.set(node.name, node);
        this.unlink(node);
        for (const [dependencyName, dependencyNode] of node.localDependencies) {
          if (!this.contains(dependencyName)) {
            this.localDependencies.set(dependencyName, dependencyNode);
          }
        }
        for (const [dependentName, dependentNode] of node.localDependents) {
          if (!this.contains(dependentName)) {
            this.localDependents.set(dependentName, dependentNode);
          }
        }
      }
      unlink(candidateNode) {
        this.localDependencies.delete(candidateNode.name);
        this.localDependents.delete(candidateNode.name);
      }
    };
  }
});

// libs/core/src/lib/prerelease-id-from-version.ts
function prereleaseIdFromVersion(version) {
  return (import_semver.default.prerelease(version) || []).shift();
}
var import_semver;
var init_prerelease_id_from_version = __esm({
  "libs/core/src/lib/prerelease-id-from-version.ts"() {
    "use strict";
    import_semver = __toESM(require("semver"));
  }
});

// libs/core/src/lib/package-graph/package-graph-node.ts
var import_semver2, PKG, PackageGraphNode;
var init_package_graph_node = __esm({
  "libs/core/src/lib/package-graph/package-graph-node.ts"() {
    "use strict";
    import_semver2 = __toESM(require("semver"));
    init_prerelease_id_from_version();
    PKG = Symbol("pkg");
    PackageGraphNode = class {
      name;
      externalDependencies;
      localDependencies;
      localDependents;
      [PKG];
      constructor(pkg) {
        this.name = pkg.name;
        this[PKG] = pkg;
        Object.defineProperty(this, PKG, { enumerable: false });
        this.externalDependencies = /* @__PURE__ */ new Map();
        this.localDependencies = /* @__PURE__ */ new Map();
        this.localDependents = /* @__PURE__ */ new Map();
      }
      get location() {
        return this[PKG].location;
      }
      get pkg() {
        return this[PKG];
      }
      get prereleaseId() {
        return prereleaseIdFromVersion(this.version);
      }
      get version() {
        return this[PKG].version;
      }
      satisfies({ gitCommittish, gitRange, fetchSpec }) {
        return import_semver2.default.satisfies(this.version, gitCommittish || gitRange || fetchSpec);
      }
      toString() {
        return this.name;
      }
    };
  }
});

// libs/core/src/lib/package-graph/report-cycles.ts
function reportCycles(paths, rejectCycles) {
  if (!paths.length) {
    return;
  }
  const cycleMessage = ["Dependency cycles detected, you should fix these!"].concat(paths).join("\n");
  if (rejectCycles) {
    throw new ValidationError("ECYCLE", cycleMessage);
  }
  import_npmlog8.default.warn("ECYCLE", cycleMessage);
}
var import_npmlog8;
var init_report_cycles = __esm({
  "libs/core/src/lib/package-graph/report-cycles.ts"() {
    "use strict";
    import_npmlog8 = __toESM(require("npmlog"));
    init_validation_error();
  }
});

// libs/core/src/lib/package-graph/index.ts
var import_npm_package_arg, PackageGraph;
var init_package_graph = __esm({
  "libs/core/src/lib/package-graph/index.ts"() {
    "use strict";
    import_npm_package_arg = __toESM(require("npm-package-arg"));
    init_validation_error();
    init_cyclic_package_graph_node();
    init_package_graph_node();
    init_report_cycles();
    PackageGraph = class extends Map {
      constructor(packages, graphType = "allDependencies", forceLocal) {
        super(packages.map((pkg) => [pkg.name, new PackageGraphNode(pkg)]));
        if (packages.length !== this.size) {
          const seen = /* @__PURE__ */ new Map();
          for (const { name, location } of packages) {
            if (seen.has(name)) {
              seen.get(name).push(location);
            } else {
              seen.set(name, [location]);
            }
          }
          for (const [name, locations] of seen) {
            if (locations.length > 1) {
              throw new ValidationError(
                "ENAME",
                [`Package name "${name}" used in multiple packages:`, ...locations].join("\n	")
              );
            }
          }
        }
        this.forEach((currentNode, currentName) => {
          const graphDependencies = graphType === "dependencies" ? Object.assign({}, currentNode.pkg.optionalDependencies, currentNode.pkg.dependencies) : Object.assign(
            {},
            currentNode.pkg.devDependencies,
            currentNode.pkg.optionalDependencies,
            currentNode.pkg.dependencies
          );
          Object.keys(graphDependencies).forEach((depName) => {
            const depNode = this.get(depName);
            let spec = graphDependencies[depName].replace(/^link:/, "file:");
            const isWorkspaceSpec = /^workspace:/.test(spec);
            let fullWorkspaceSpec;
            let workspaceAlias;
            if (isWorkspaceSpec) {
              fullWorkspaceSpec = spec;
              spec = spec.replace(/^workspace:/, "");
              if (spec === "*" || spec === "^" || spec === "~") {
                workspaceAlias = spec;
                if (depNode?.version) {
                  const prefix = spec === "*" ? "" : spec;
                  const version = depNode.version;
                  spec = `${prefix}${version}`;
                } else {
                  spec = "*";
                }
              }
            }
            const resolved = import_npm_package_arg.default.resolve(depName, spec, currentNode.location);
            resolved.workspaceSpec = fullWorkspaceSpec;
            resolved.workspaceAlias = workspaceAlias;
            if (!depNode) {
              return currentNode.externalDependencies.set(depName, resolved);
            }
            if (forceLocal || resolved.fetchSpec === depNode.location || depNode.satisfies(resolved)) {
              currentNode.localDependencies.set(depName, resolved);
              depNode.localDependents.set(currentName, currentNode);
            } else {
              if (isWorkspaceSpec) {
                throw new ValidationError(
                  "EWORKSPACE",
                  `Package specification "${depName}@${spec}" could not be resolved within the workspace. To reference a non-matching, remote version of a local dependency, remove the 'workspace:' prefix.`
                );
              }
              currentNode.externalDependencies.set(depName, resolved);
            }
          });
        });
      }
      get rawPackageList() {
        return Array.from(this.values()).map((node) => node.pkg);
      }
      addDependencies(filteredPackages) {
        return this.extendList(filteredPackages, "localDependencies");
      }
      addDependents(filteredPackages) {
        return this.extendList(filteredPackages, "localDependents");
      }
      extendList(packageList, nodeProp) {
        const search = new Set(packageList.map(({ name }) => this.get(name)));
        const result = [];
        search.forEach((currentNode) => {
          result.push(currentNode);
          currentNode[nodeProp].forEach((meta, depName) => {
            const depNode = this.get(depName);
            if (depNode !== currentNode && !search.has(depNode)) {
              search.add(depNode);
            }
          });
        });
        return result.map((node) => node.pkg);
      }
      partitionCycles(rejectCycles) {
        const cyclePaths = /* @__PURE__ */ new Set();
        const cycleNodes = /* @__PURE__ */ new Set();
        this.forEach((currentNode, currentName) => {
          const seen = /* @__PURE__ */ new Set();
          const visits = (walk) => (dependentNode, dependentName, siblingDependents) => {
            const step = walk.concat(dependentName);
            if (seen.has(dependentNode)) {
              return;
            }
            seen.add(dependentNode);
            if (dependentNode === currentNode) {
              cycleNodes.add(currentNode);
              cyclePaths.add(step);
              return;
            }
            if (siblingDependents.has(currentName)) {
              const cycleDependentName = Array.from(dependentNode.localDependencies.keys()).find(
                (key) => currentNode.localDependents.has(key)
              );
              const pathToCycle = step.slice().reverse().concat(cycleDependentName);
              cycleNodes.add(dependentNode);
              cyclePaths.add(pathToCycle);
            }
            dependentNode.localDependents.forEach(visits(step));
          };
          currentNode.localDependents.forEach(visits([currentName]));
        });
        reportCycles(
          Array.from(cyclePaths, (cycle) => cycle.join(" -> ")),
          rejectCycles
        );
        return [cyclePaths, cycleNodes];
      }
      collapseCycles(rejectCycles) {
        const cyclePaths = [];
        const nodeToCycle = /* @__PURE__ */ new Map();
        const cycles = /* @__PURE__ */ new Set();
        const walkStack = [];
        const alreadyVisited = /* @__PURE__ */ new Set();
        function visits(baseNode, dependentNode) {
          if (nodeToCycle.has(baseNode)) {
            return;
          }
          let topLevelDependent = dependentNode;
          while (nodeToCycle.has(topLevelDependent)) {
            topLevelDependent = nodeToCycle.get(topLevelDependent);
          }
          const identifier = `${baseNode.name}:${topLevelDependent.name}`;
          if (alreadyVisited.has(identifier)) {
            return;
          }
          alreadyVisited.add(identifier);
          if (topLevelDependent === baseNode || topLevelDependent.isCycle && topLevelDependent.has(baseNode.name)) {
            const cycle = new CyclicPackageGraphNode();
            walkStack.forEach((nodeInCycle) => {
              nodeToCycle.set(nodeInCycle, cycle);
              cycle.insert(nodeInCycle);
              cycles.delete(nodeInCycle);
            });
            cycles.add(cycle);
            cyclePaths.push(cycle.toString());
            return;
          }
          if (walkStack.indexOf(topLevelDependent) === -1) {
            visitWithStack(baseNode, topLevelDependent);
          }
        }
        function visitWithStack(baseNode, currentNode = baseNode) {
          walkStack.push(currentNode);
          currentNode.localDependents.forEach(visits.bind(null, baseNode));
          walkStack.pop();
        }
        this.forEach((currentNode) => visitWithStack(currentNode));
        cycles.forEach((collapsedNode) => visitWithStack(collapsedNode));
        reportCycles(cyclePaths, rejectCycles);
        return cycles;
      }
      pruneCycleNodes(cycleNodes) {
        return this.prune(...cycleNodes);
      }
      prune(...candidates) {
        if (candidates.length === this.size) {
          return this.clear();
        }
        candidates.forEach((node) => this.remove(node));
      }
      remove(candidateNode) {
        this.delete(candidateNode.name);
        this.forEach((node) => {
          node.localDependencies.delete(candidateNode.name);
          node.localDependents.delete(candidateNode.name);
        });
      }
    };
  }
});

// libs/core/src/lib/package.ts
function binSafeName({ name, scope }) {
  return scope ? name.substring(scope.length + 1) : name;
}
function shallowCopy(json) {
  return Object.keys(json).reduce((obj, key) => {
    const val = json[key];
    if (Array.isArray(val)) {
      obj[key] = val.slice();
    } else if (val && typeof val === "object") {
      obj[key] = Object.assign({}, val);
    } else {
      obj[key] = val;
    }
    return obj;
  }, {});
}
var import_load_json_file, import_npm_package_arg2, import_path2, import_write_pkg, PKG2, _location, _resolved, _rootPath, _scripts, _contents, Package;
var init_package = __esm({
  "libs/core/src/lib/package.ts"() {
    "use strict";
    import_load_json_file = __toESM(require("load-json-file"));
    import_npm_package_arg2 = __toESM(require("npm-package-arg"));
    import_path2 = __toESM(require("path"));
    import_write_pkg = __toESM(require("write-pkg"));
    PKG2 = Symbol("pkg");
    _location = Symbol("location");
    _resolved = Symbol("resolved");
    _rootPath = Symbol("rootPath");
    _scripts = Symbol("scripts");
    _contents = Symbol("contents");
    Package = class {
      name;
      [PKG2];
      [_location];
      [_resolved];
      [_rootPath];
      [_scripts];
      [_contents];
      static lazy(ref, dir = ".") {
        if (typeof ref === "string") {
          const location = import_path2.default.resolve(import_path2.default.basename(ref) === "package.json" ? import_path2.default.dirname(ref) : ref);
          const manifest = import_load_json_file.default.sync(import_path2.default.join(location, "package.json"));
          return new Package(manifest, location);
        }
        if ("__isLernaPackage" in ref) {
          return ref;
        }
        return new Package(ref, dir);
      }
      constructor(pkg, location, rootPath = location) {
        const resolved = import_npm_package_arg2.default.resolve(pkg.name, `file:${import_path2.default.relative(rootPath, location)}`, rootPath);
        this.name = pkg.name;
        this[PKG2] = pkg;
        Object.defineProperty(this, PKG2, { enumerable: false, writable: true });
        this[_location] = location;
        this[_resolved] = resolved;
        this[_rootPath] = rootPath;
        this[_scripts] = { ...pkg.scripts };
      }
      get location() {
        return this[_location];
      }
      get private() {
        return Boolean(this[PKG2].private);
      }
      set private(isPrivate) {
        this[PKG2].private = isPrivate;
      }
      get resolved() {
        return this[_resolved];
      }
      get rootPath() {
        return this[_rootPath];
      }
      get scripts() {
        return this[_scripts];
      }
      get bin() {
        const pkg = this[PKG2];
        return typeof pkg.bin === "string" ? {
          [binSafeName(this.resolved)]: pkg.bin
        } : Object.assign({}, pkg.bin);
      }
      get binLocation() {
        return import_path2.default.join(this.location, "node_modules", ".bin");
      }
      get manifestLocation() {
        return import_path2.default.join(this.location, "package.json");
      }
      get nodeModulesLocation() {
        return import_path2.default.join(this.location, "node_modules");
      }
      get __isLernaPackage() {
        return true;
      }
      get version() {
        return this[PKG2].version;
      }
      set version(version) {
        this[PKG2].version = version;
      }
      get contents() {
        if (this[_contents]) {
          return this[_contents];
        }
        if (this[PKG2].publishConfig && this[PKG2].publishConfig.directory) {
          return import_path2.default.join(this.location, this[PKG2].publishConfig.directory);
        }
        return this.location;
      }
      set contents(subDirectory) {
        this[_contents] = import_path2.default.join(this.location, subDirectory);
      }
      get dependencies() {
        return this[PKG2].dependencies;
      }
      get devDependencies() {
        return this[PKG2].devDependencies;
      }
      get optionalDependencies() {
        return this[PKG2].optionalDependencies;
      }
      get peerDependencies() {
        return this[PKG2].peerDependencies;
      }
      get(key) {
        return this[PKG2][key];
      }
      set(key, val) {
        this[PKG2][key] = val;
        return this;
      }
      toJSON() {
        return shallowCopy(this[PKG2]);
      }
      refresh() {
        return (0, import_load_json_file.default)(this.manifestLocation).then((pkg) => {
          this[PKG2] = pkg;
          return this;
        });
      }
      serialize() {
        return (0, import_write_pkg.default)(this.manifestLocation, this[PKG2]).then(() => this);
      }
      updateLocalDependency(resolved, depVersion, savePrefix, options = { retainWorkspacePrefix: true }) {
        const depName = resolved.name;
        let depCollection = this.dependencies;
        if (!depCollection || !depCollection[depName]) {
          depCollection = this.optionalDependencies;
        }
        if (!depCollection || !depCollection[depName]) {
          depCollection = this.devDependencies;
        }
        if (resolved.workspaceSpec && options.retainWorkspacePrefix) {
          if (!resolved.workspaceAlias) {
            const workspacePrefix = resolved.workspaceSpec.match(/^(workspace:[*~^]?)/)[0];
            depCollection[depName] = `${workspacePrefix}${depVersion}`;
          }
        } else if (resolved.registry || resolved.type === "directory") {
          depCollection[depName] = `${savePrefix}${depVersion}`;
        } else if (resolved.gitCommittish) {
          const [tagPrefix] = /^\D*/.exec(resolved.gitCommittish);
          const { hosted } = resolved;
          hosted.committish = `${tagPrefix}${depVersion}`;
          depCollection[depName] = hosted.toString({ noGitPlus: false, noCommittish: false });
        } else if (resolved.gitRange) {
          const { hosted } = resolved;
          hosted.committish = `semver:${savePrefix}${depVersion}`;
          depCollection[depName] = hosted.toString({ noGitPlus: false, noCommittish: false });
        }
      }
      removePrivate() {
        delete this[PKG2].private;
      }
    };
  }
});

// libs/core/src/lib/project/deprecate-config.ts
function remap(search, target, { alsoRoot, toValue } = {}) {
  const pathsToSearch = [search];
  if (alsoRoot) {
    pathsToSearch.unshift(search.split(".").pop());
  }
  return (obj) => {
    for (const searchPath of pathsToSearch) {
      if (import_dot_prop.default.has(obj.config, searchPath)) {
        const fromVal = import_dot_prop.default.get(obj.config, searchPath);
        const toVal = toValue ? toValue(fromVal) : fromVal;
        import_npmlog9.default.warn("project", deprecationMessage(obj, target, searchPath, fromVal, toVal));
        import_dot_prop.default.set(obj.config, target, toVal);
        import_dot_prop.default.delete(obj.config, searchPath);
      }
    }
    return obj;
  };
}
function deprecationMessage(obj, target, searchPath, fromVal, toVal) {
  const localPath = import_path3.default.relative(".", obj.filepath);
  let from;
  let to;
  if (toVal === fromVal) {
    from = `"${searchPath}"`;
    to = `"${target}"`;
  } else {
    from = stringify({ [searchPath]: fromVal });
    to = stringify({ [target]: toVal });
  }
  return `Deprecated key "${searchPath}" found in ${localPath}
Please update ${from} => ${to}`;
}
function stringify(obj) {
  return JSON.stringify(obj).slice(1, -1);
}
function compose(...funcs) {
  return funcs.reduce(
    (a, b) => (...args) => a(b(...args))
  );
}
var import_dot_prop, import_npmlog9, import_path3, deprecateConfig;
var init_deprecate_config = __esm({
  "libs/core/src/lib/project/deprecate-config.ts"() {
    "use strict";
    import_dot_prop = __toESM(require("dot-prop"));
    import_npmlog9 = __toESM(require("npmlog"));
    import_path3 = __toESM(require("path"));
    deprecateConfig = compose(
      remap("command.add.includeFilteredDependencies", "command.add.includeDependencies", { alsoRoot: true }),
      remap("command.add.includeFilteredDependents", "command.add.includeDependents", { alsoRoot: true }),
      remap("command.bootstrap.includeFilteredDependencies", "command.bootstrap.includeDependencies"),
      remap("command.bootstrap.includeFilteredDependents", "command.bootstrap.includeDependents"),
      remap("command.clean.includeFilteredDependencies", "command.clean.includeDependencies"),
      remap("command.clean.includeFilteredDependents", "command.clean.includeDependents"),
      remap("command.exec.includeFilteredDependencies", "command.exec.includeDependencies"),
      remap("command.exec.includeFilteredDependents", "command.exec.includeDependents"),
      remap("command.list.includeFilteredDependencies", "command.list.includeDependencies"),
      remap("command.list.includeFilteredDependents", "command.list.includeDependents"),
      remap("command.run.includeFilteredDependencies", "command.run.includeDependencies"),
      remap("command.run.includeFilteredDependents", "command.run.includeDependents"),
      remap("command.version.githubRelease", "command.version.createRelease", {
        toValue: (value) => value && "github"
      }),
      remap("command.publish.githubRelease", "command.version.createRelease", {
        alsoRoot: true,
        toValue: (value) => value && "github"
      }),
      remap("command.publish.npmTag", "command.publish.distTag", { alsoRoot: true }),
      remap("command.publish.cdVersion", "command.publish.bump", { alsoRoot: true }),
      remap("command.publish.ignore", "command.publish.ignoreChanges"),
      remap("commands", "command"),
      (config, filepath) => ({ config, filepath })
    );
  }
});

// libs/core/src/lib/project/shallow-extend.ts
function shallowExtend(json, defaults = {}) {
  return Object.keys(json).reduce((obj, key) => {
    const val = json[key];
    if (Array.isArray(val)) {
      obj[key] = val.slice();
    } else if (val && typeof val === "object") {
      obj[key] = shallowExtend(val, obj[key]);
    } else {
      obj[key] = val;
    }
    return obj;
  }, defaults);
}
var init_shallow_extend = __esm({
  "libs/core/src/lib/project/shallow-extend.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/project/apply-extends.ts
function applyExtends(config, cwd, seen = /* @__PURE__ */ new Set()) {
  let defaultConfig = {};
  if ("extends" in config) {
    let pathToDefault;
    try {
      pathToDefault = (0, import_resolve_from.default)(cwd, config.extends);
    } catch (err) {
      throw new ValidationError("ERESOLVED", "Config .extends must be locally-resolvable", err);
    }
    if (seen.has(pathToDefault)) {
      throw new ValidationError("ECIRCULAR", "Config .extends cannot be circular", seen);
    }
    seen.add(pathToDefault);
    defaultConfig = require(pathToDefault);
    delete config.extends;
    deprecateConfig(defaultConfig, pathToDefault);
    defaultConfig = applyExtends(defaultConfig, import_path4.default.dirname(pathToDefault), seen);
  }
  return shallowExtend(config, defaultConfig);
}
var import_path4, import_resolve_from;
var init_apply_extends = __esm({
  "libs/core/src/lib/project/apply-extends.ts"() {
    "use strict";
    import_path4 = __toESM(require("path"));
    import_resolve_from = __toESM(require("resolve-from"));
    init_validation_error();
    init_deprecate_config();
    init_shallow_extend();
  }
});

// libs/core/src/lib/project/make-file-finder.ts
function normalize(results) {
  return results.map((fp) => import_path5.default.normalize(fp));
}
function getGlobOpts(rootPath, packageConfigs) {
  const globOpts = {
    cwd: rootPath,
    absolute: true,
    expandDirectories: false,
    followSymbolicLinks: false
  };
  if (packageConfigs.some((cfg) => cfg.indexOf("**") > -1)) {
    if (packageConfigs.some((cfg) => cfg.indexOf("node_modules") > -1)) {
      throw new ValidationError(
        "EPKGCONFIG",
        "An explicit node_modules package path does not allow globstars (**)"
      );
    }
    globOpts.ignore = [
      "**/node_modules/**"
    ];
  }
  return globOpts;
}
function makeFileFinder(rootPath, packageConfigs) {
  const globOpts = getGlobOpts(rootPath, packageConfigs);
  return (fileName, fileMapper, customGlobOpts) => {
    const options = Object.assign({}, customGlobOpts, globOpts);
    const promise = (0, import_p_map.default)(
      Array.from(packageConfigs).sort(),
      (globPath) => {
        let chain = (0, import_globby.default)(import_path5.default.posix.join(globPath, fileName), options);
        chain = chain.then((results) => results.sort());
        chain = chain.then(normalize);
        if (fileMapper) {
          chain = chain.then(fileMapper);
        }
        return chain;
      },
      { concurrency: 4 }
    );
    return promise.then((results) => results.reduce((acc, result) => acc.concat(result), []));
  };
}
function makeSyncFileFinder(rootPath, packageConfigs) {
  const globOpts = getGlobOpts(rootPath, packageConfigs);
  return (fileName, fileMapper, customGlobOpts) => {
    const options = Object.assign({}, customGlobOpts, globOpts);
    const patterns = packageConfigs.map((globPath) => import_path5.default.posix.join(globPath, fileName)).sort();
    let results = import_globby.default.sync(patterns, options);
    results = normalize(results);
    if (fileMapper) {
      results = results.map(fileMapper);
    }
    return results;
  };
}
var import_globby, import_p_map, import_path5;
var init_make_file_finder = __esm({
  "libs/core/src/lib/project/make-file-finder.ts"() {
    "use strict";
    import_globby = __toESM(require("globby"));
    import_p_map = __toESM(require("p-map"));
    import_path5 = __toESM(require("path"));
    init_validation_error();
  }
});

// libs/core/src/lib/project/index.ts
var import_devkit, import_cosmiconfig, import_dedent2, import_fs, import_glob_parent, import_globby2, import_js_yaml, import_load_json_file2, import_npmlog10, import_p_map2, import_path6, _Project, Project, getPackages, getPackagesSync;
var init_project = __esm({
  "libs/core/src/lib/project/index.ts"() {
    "use strict";
    import_devkit = require("@nrwl/devkit");
    import_cosmiconfig = require("cosmiconfig");
    import_dedent2 = __toESM(require("dedent"));
    import_fs = __toESM(require("fs"));
    import_glob_parent = __toESM(require("glob-parent"));
    import_globby2 = __toESM(require("globby"));
    import_js_yaml = require("js-yaml");
    import_load_json_file2 = __toESM(require("load-json-file"));
    import_npmlog10 = __toESM(require("npmlog"));
    import_p_map2 = __toESM(require("p-map"));
    import_path6 = __toESM(require("path"));
    init_package();
    init_validation_error();
    init_apply_extends();
    init_deprecate_config();
    init_make_file_finder();
    _Project = class {
      static getPackages(cwd) {
        return new _Project(cwd).getPackages();
      }
      static getPackagesSync(cwd) {
        return new _Project(cwd).getPackagesSync();
      }
      config;
      configNotFound;
      rootConfigLocation;
      rootPath;
      constructor(cwd) {
        const explorer = (0, import_cosmiconfig.cosmiconfigSync)("lerna", {
          searchPlaces: ["lerna.json", "package.json"],
          transform(obj) {
            if (!obj) {
              return {
                config: {},
                configNotFound: true,
                filepath: import_path6.default.resolve(cwd || ".", "lerna.json")
              };
            }
            deprecateConfig(obj.config, obj.filepath);
            obj.config = applyExtends(obj.config, import_path6.default.dirname(obj.filepath));
            return obj;
          }
        });
        let loaded;
        try {
          loaded = explorer.search(cwd);
        } catch (err) {
          if (err.name === "JSONError") {
            throw new ValidationError(err.name, err.message);
          }
          throw err;
        }
        this.config = loaded.config;
        this.configNotFound = loaded.configNotFound;
        this.rootConfigLocation = loaded.filepath;
        this.rootPath = import_path6.default.dirname(loaded.filepath);
        import_npmlog10.default.verbose("rootPath", this.rootPath);
      }
      get version() {
        return this.config.version;
      }
      set version(val) {
        this.config.version = val;
      }
      get packageConfigs() {
        if (this.config.npmClient === "pnpm") {
          import_npmlog10.default.verbose(
            "packageConfigs",
            "Package manager 'pnpm' detected. Resolving packages using 'pnpm-workspace.yaml'."
          );
          const workspaces = this.pnpmWorkspaceConfig.packages;
          if (!workspaces) {
            throw new ValidationError(
              "EWORKSPACES",
              "No 'packages' property found in pnpm-workspace.yaml. See https://pnpm.io/workspaces for help configuring workspaces in pnpm."
            );
          }
          return workspaces;
        }
        if (this.config.useWorkspaces) {
          const workspaces = this.manifest.get("workspaces");
          if (!workspaces) {
            throw new ValidationError(
              "EWORKSPACES",
              import_dedent2.default`
            Workspaces need to be defined in the root package.json.
            See: https://github.com/lerna/lerna/blob/master/commands/bootstrap/README.md#--use-workspaces
          `
            );
          }
          return workspaces.packages || workspaces;
        }
        if (this.manifest.get("workspaces")) {
          import_npmlog10.default.warn(
            "EWORKSPACES",
            import_dedent2.default`
          Workspaces exist in the root package.json, but Lerna is not configured to use them.
          To fix this and have Lerna use workspaces to resolve packages, set \`useWorkspaces: true\` in lerna.json.
        `
          );
        }
        if (this.config.packages) {
          return this.config.packages;
        }
        import_npmlog10.default.warn(
          "EPACKAGES",
          `No packages defined in lerna.json. Defaulting to packages in ${_Project.PACKAGE_GLOB}`
        );
        return [_Project.PACKAGE_GLOB];
      }
      get packageParentDirs() {
        return this.packageConfigs.map(import_glob_parent.default).map((parentDir) => import_path6.default.resolve(this.rootPath, parentDir));
      }
      get manifest() {
        let manifest;
        try {
          const manifestLocation = import_path6.default.join(this.rootPath, "package.json");
          const packageJson = import_load_json_file2.default.sync(manifestLocation);
          if (!packageJson.name) {
            packageJson.name = import_path6.default.basename(import_path6.default.dirname(manifestLocation));
          }
          manifest = new Package(packageJson, this.rootPath);
          Object.defineProperty(this, "manifest", {
            value: manifest
          });
        } catch (err) {
          if (err.name === "JSONError") {
            throw new ValidationError(err.name, err.message);
          }
        }
        return manifest;
      }
      get pnpmWorkspaceConfig() {
        let config;
        try {
          const configLocation = import_path6.default.join(this.rootPath, "pnpm-workspace.yaml");
          const configContent = import_fs.default.readFileSync(configLocation);
          config = (0, import_js_yaml.load)(configContent);
          Object.defineProperty(this, "pnpmWorkspaceConfig", {
            value: config
          });
        } catch (err) {
          if (err.message.includes("ENOENT: no such file or directory")) {
            throw new ValidationError(
              "ENOENT",
              "No pnpm-workspace.yaml found. See https://pnpm.io/workspaces for help configuring workspaces in pnpm."
            );
          }
          throw new ValidationError(err.name, err.message);
        }
        return config;
      }
      get licensePath() {
        let licensePath;
        try {
          const search = import_globby2.default.sync(_Project.LICENSE_GLOB, {
            cwd: this.rootPath,
            absolute: true,
            caseSensitiveMatch: false,
            deep: 0
          });
          licensePath = search.shift();
          if (licensePath) {
            licensePath = import_path6.default.normalize(licensePath);
            Object.defineProperty(this, "licensePath", {
              value: licensePath
            });
          }
        } catch (err) {
          throw new ValidationError(err.name, err.message);
        }
        return licensePath;
      }
      get fileFinder() {
        const finder = makeFileFinder(this.rootPath, this.packageConfigs);
        Object.defineProperty(this, "fileFinder", {
          value: finder
        });
        return finder;
      }
      getPackages() {
        const mapper = (packageConfigPath) => (0, import_load_json_file2.default)(packageConfigPath).then(
          (packageJson) => new Package(packageJson, import_path6.default.dirname(packageConfigPath), this.rootPath)
        );
        return this.fileFinder("package.json", (filePaths) => (0, import_p_map2.default)(filePaths, mapper, { concurrency: 50 }));
      }
      getPackagesSync() {
        return makeSyncFileFinder(this.rootPath, this.packageConfigs)("package.json", (packageConfigPath) => {
          return new Package(
            import_load_json_file2.default.sync(packageConfigPath),
            import_path6.default.dirname(packageConfigPath),
            this.rootPath
          );
        });
      }
      getPackageLicensePaths() {
        return this.fileFinder(_Project.LICENSE_GLOB, null, { caseSensitiveMatch: false });
      }
      isIndependent() {
        return this.version === "independent";
      }
      serializeConfig() {
        (0, import_devkit.writeJsonFile)(this.rootConfigLocation, this.config, { spaces: 2 });
        return this.rootConfigLocation;
      }
    };
    Project = _Project;
    __publicField(Project, "PACKAGE_GLOB", "packages/*");
    __publicField(Project, "LICENSE_GLOB", "LICEN{S,C}E{,.*}");
    getPackages = Project.getPackages;
    getPackagesSync = Project.getPackagesSync;
  }
});

// libs/core/src/lib/write-log-file.ts
function writeLogFile(cwd) {
  let logOutput = "";
  import_npmlog11.default.record.forEach((m) => {
    let pref = [m.id, m.level];
    if (m.prefix) {
      pref.push(m.prefix);
    }
    pref = pref.join(" ");
    m.message.trim().split(/\r?\n/).map((line) => `${pref} ${line}`.trim()).forEach((line) => {
      logOutput += line + import_os.default.EOL;
    });
  });
  import_write_file_atomic.default.sync(import_path7.default.join(cwd, "lerna-debug.log"), logOutput);
  import_npmlog11.default.record.length = 0;
}
var import_npmlog11, import_os, import_path7, import_write_file_atomic;
var init_write_log_file = __esm({
  "libs/core/src/lib/write-log-file.ts"() {
    "use strict";
    import_npmlog11 = __toESM(require("npmlog"));
    import_os = __toESM(require("os"));
    import_path7 = __toESM(require("path"));
    import_write_file_atomic = __toESM(require("write-file-atomic"));
  }
});

// libs/core/src/lib/command/clean-stack.ts
function cleanStack(err, className) {
  const lines = err.stack ? err.stack.split("\n") : String(err).split("\n");
  const cutoff = new RegExp(`^    at ${className}.runCommand .*$`);
  const relevantIndex = lines.findIndex((line) => cutoff.test(line));
  if (relevantIndex) {
    return lines.slice(0, relevantIndex).join("\n");
  }
  return err;
}
var init_clean_stack = __esm({
  "libs/core/src/lib/command/clean-stack.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/command/default-options.ts
function defaultOptions(...sources) {
  const options = {};
  for (const source of sources) {
    if (source != null) {
      for (const key of Object.keys(source)) {
        if (options[key] === void 0) {
          options[key] = source[key];
        }
      }
    }
  }
  return options;
}
var init_default_options = __esm({
  "libs/core/src/lib/command/default-options.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/command/log-package-error.ts
function logPackageError(err, stream = false) {
  import_npmlog12.default.error(err.command, `exited ${err.exitCode} in '${err.pkg.name}'`);
  if (stream) {
    return;
  }
  if (err.stdout) {
    import_npmlog12.default.error(err.command, "stdout:");
    directLog(err.stdout);
  }
  if (err.stderr) {
    import_npmlog12.default.error(err.command, "stderr:");
    directLog(err.stderr);
  }
  import_npmlog12.default.error(err.command, `exited ${err.exitCode} in '${err.pkg.name}'`);
}
function directLog(message) {
  import_npmlog12.default.pause();
  console.error(message);
  import_npmlog12.default.resume();
}
var import_npmlog12;
var init_log_package_error = __esm({
  "libs/core/src/lib/command/log-package-error.ts"() {
    "use strict";
    import_npmlog12 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/command/warn-if-hanging.ts
function warnIfHanging() {
  const childProcessCount = childProcess5.getChildProcessCount();
  if (childProcessCount > 0) {
    import_npmlog13.default.warn(
      "complete",
      `Waiting for ${childProcessCount} child process${childProcessCount === 1 ? "" : "es"} to exit. CTRL-C to exit immediately.`
    );
  }
}
var import_npmlog13, childProcess5;
var init_warn_if_hanging = __esm({
  "libs/core/src/lib/command/warn-if-hanging.ts"() {
    "use strict";
    import_npmlog13 = __toESM(require("npmlog"));
    childProcess5 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/command/index.ts
var import_clone_deep, import_dedent3, import_execa, import_npmlog14, import_os2, DEFAULT_CONCURRENCY, Command;
var init_command = __esm({
  "libs/core/src/lib/command/index.ts"() {
    "use strict";
    import_clone_deep = __toESM(require("clone-deep"));
    import_dedent3 = __toESM(require("dedent"));
    import_execa = __toESM(require("execa"));
    import_npmlog14 = __toESM(require("npmlog"));
    import_os2 = __toESM(require("os"));
    init_package_graph();
    init_project();
    init_validation_error();
    init_write_log_file();
    init_clean_stack();
    init_default_options();
    init_log_package_error();
    init_warn_if_hanging();
    DEFAULT_CONCURRENCY = import_os2.default.cpus().length;
    Command = class {
      name;
      composed;
      project;
      options;
      runner;
      concurrency;
      toposort;
      execOpts;
      packageGraph;
      logger;
      constructor(_argv, { skipValidations } = { skipValidations: false }) {
        import_npmlog14.default.pause();
        import_npmlog14.default.heading = "lerna";
        const argv = (0, import_clone_deep.default)(_argv);
        import_npmlog14.default.silly("argv", argv);
        this.name = this.constructor.name.replace(/Command$/, "").toLowerCase();
        this.composed = typeof argv.composed === "string" && argv.composed !== this.name;
        if (!this.composed) {
          import_npmlog14.default.notice("cli", `v${argv.lernaVersion}`);
        }
        let runner = new Promise((resolve, reject) => {
          let chain = Promise.resolve();
          chain = chain.then(() => {
            this.project = new Project(argv.cwd);
          });
          chain = chain.then(() => this.configureEnvironment());
          chain = chain.then(() => this.configureOptions());
          chain = chain.then(() => this.configureProperties());
          chain = chain.then(() => this.configureLogging());
          if (!skipValidations) {
            chain = chain.then(() => this.runValidations());
          }
          chain = chain.then(() => this.runPreparations());
          chain = chain.then(() => this.runCommand());
          chain.then(
            (result) => {
              warnIfHanging();
              resolve(result);
            },
            (err) => {
              if (err.pkg) {
                logPackageError(err, this.options.stream);
              } else if (err.name !== "ValidationError") {
                import_npmlog14.default.error("", cleanStack(err, this.constructor.name));
              }
              if (err.name !== "ValidationError" && !err.pkg) {
                writeLogFile(this.project.rootPath);
              }
              warnIfHanging();
              reject(err);
            }
          );
        });
        if (argv.onResolved || argv.onRejected) {
          runner = runner.then(argv.onResolved, argv.onRejected);
          delete argv.onResolved;
          delete argv.onRejected;
        }
        for (const key of ["cwd", "$0"]) {
          Object.defineProperty(argv, key, { enumerable: false });
        }
        Object.defineProperty(this, "argv", {
          value: Object.freeze(argv)
        });
        Object.defineProperty(this, "runner", {
          value: runner
        });
      }
      then(onResolved, onRejected) {
        return this.runner.then(onResolved, onRejected);
      }
      catch(onRejected) {
        return this.runner.catch(onRejected);
      }
      get requiresGit() {
        return true;
      }
      get otherCommandConfigs() {
        return [];
      }
      configureEnvironment() {
        const ci = require("is-ci");
        let loglevel;
        let progress;
        if (ci || !process.stderr.isTTY) {
          import_npmlog14.default.disableColor();
          progress = false;
        } else if (!process.stdout.isTTY) {
          progress = false;
          loglevel = "error";
        } else if (process.stderr.isTTY) {
          import_npmlog14.default.enableColor();
          import_npmlog14.default.enableUnicode();
        }
        Object.defineProperty(this, "envDefaults", {
          value: {
            ci,
            progress,
            loglevel
          }
        });
      }
      configureOptions() {
        const commandConfig = this.project.config.command || {};
        const overrides = [this.name, ...this.otherCommandConfigs].map((key) => commandConfig[key]);
        this.options = defaultOptions(
          this.argv,
          ...overrides,
          this.project.config,
          this.envDefaults
        );
        if (this.options.verbose && this.options.loglevel !== "silly") {
          this.options.loglevel = "verbose";
        }
      }
      argv(argv, arg1, config, envDefaults) {
        throw new Error("Method not implemented.");
      }
      envDefaults(argv, arg1, config, envDefaults) {
        throw new Error("Method not implemented.");
      }
      configureProperties() {
        const { concurrency, sort, maxBuffer } = this.options;
        this.concurrency = Math.max(1, +concurrency || DEFAULT_CONCURRENCY);
        this.toposort = sort === void 0 || sort;
        this.execOpts = {
          cwd: this.project.rootPath,
          maxBuffer
        };
      }
      configureLogging() {
        const { loglevel } = this.options;
        if (loglevel) {
          import_npmlog14.default.level = loglevel;
        }
        import_npmlog14.default.addLevel("success", 3001, { fg: "green", bold: true });
        Object.defineProperty(this, "logger", {
          value: import_npmlog14.default["newGroup"](this.name)
        });
        import_npmlog14.default.resume();
      }
      enableProgressBar() {
        if (this.options.progress !== false) {
          import_npmlog14.default.enableProgress();
        }
      }
      gitInitialized() {
        const opts = {
          cwd: this.project.rootPath,
          reject: false,
          stdio: "ignore"
        };
        return import_execa.default.sync("git", ["rev-parse"], opts).exitCode === 0;
      }
      runValidations() {
        if ((this.options.since !== void 0 || this.requiresGit) && !this.gitInitialized()) {
          throw new ValidationError("ENOGIT", "The git binary was not found, or this is not a git repository.");
        }
        if (!this.project.manifest) {
          throw new ValidationError("ENOPKG", "`package.json` does not exist, have you run `lerna init`?");
        }
        if (this.project.configNotFound) {
          throw new ValidationError("ENOLERNA", "`lerna.json` does not exist, have you run `lerna init`?");
        }
        if (!this.project.version) {
          throw new ValidationError("ENOVERSION", "Required property version does not exist in `lerna.json`");
        }
        if (this.options.independent && !this.project.isIndependent()) {
          throw new ValidationError(
            "EVERSIONMODE",
            import_dedent3.default`
          You ran lerna with --independent or -i, but the repository is not set to independent mode.
          To use independent mode you need to set lerna.json's "version" property to "independent".
          Then you won't need to pass the --independent or -i flags.
        `
          );
        }
        if (this.options.npmClient === "pnpm" && !this.options.useWorkspaces) {
          throw new ValidationError(
            "ENOWORKSPACES",
            "Usage of pnpm without workspaces is not supported. To use pnpm with lerna, set useWorkspaces to true in lerna.json and configure pnpm to use workspaces: https://pnpm.io/workspaces."
          );
        }
      }
      runPreparations() {
        if (!this.composed && this.project.isIndependent()) {
          import_npmlog14.default.info("versioning", "independent");
        }
        if (!this.composed && this.options.ci) {
          import_npmlog14.default.info("ci", "enabled");
        }
        let chain = Promise.resolve();
        chain = chain.then(() => this.project.getPackages());
        chain = chain.then((packages) => {
          this.packageGraph = new PackageGraph(packages);
        });
        return chain;
      }
      runCommand() {
        return Promise.resolve().then(() => this.initialize()).then((proceed) => {
          if (proceed !== false) {
            return this.execute();
          }
        });
      }
      initialize() {
        throw new ValidationError(this.name, "initialize() needs to be implemented.");
      }
      execute() {
        throw new ValidationError(this.name, "execute() needs to be implemented.");
      }
    };
  }
});

// libs/core/src/lib/conventional-commits/get-changelog-config.ts
var import_npm_package_arg3, import_npmlog15, import_pify;
var init_get_changelog_config = __esm({
  "libs/core/src/lib/conventional-commits/get-changelog-config.ts"() {
    "use strict";
    import_npm_package_arg3 = __toESM(require("npm-package-arg"));
    import_npmlog15 = __toESM(require("npmlog"));
    import_pify = __toESM(require("pify"));
    init_validation_error();
  }
});

// libs/core/src/lib/conventional-commits/recommend-version.ts
var import_conventional_recommended_bump, import_npmlog16, import_semver3;
var init_recommend_version = __esm({
  "libs/core/src/lib/conventional-commits/recommend-version.ts"() {
    "use strict";
    import_conventional_recommended_bump = __toESM(require("conventional-recommended-bump"));
    import_npmlog16 = __toESM(require("npmlog"));
    import_semver3 = __toESM(require("semver"));
    init_get_changelog_config();
  }
});

// libs/core/src/lib/conventional-commits/constants.ts
var EOL, BLANK_LINE, COMMIT_GUIDELINE, CHANGELOG_HEADER;
var init_constants = __esm({
  "libs/core/src/lib/conventional-commits/constants.ts"() {
    "use strict";
    EOL = "\n";
    BLANK_LINE = EOL + EOL;
    COMMIT_GUIDELINE = "See [Conventional Commits](https://conventionalcommits.org) for commit guidelines.";
    CHANGELOG_HEADER = [
      "# Change Log",
      "",
      "All notable changes to this project will be documented in this file.",
      COMMIT_GUIDELINE
    ].join(EOL);
  }
});

// libs/core/src/lib/conventional-commits/make-bump-only-filter.ts
var init_make_bump_only_filter = __esm({
  "libs/core/src/lib/conventional-commits/make-bump-only-filter.ts"() {
    "use strict";
    init_constants();
  }
});

// libs/core/src/lib/conventional-commits/read-existing-changelog.ts
var import_fs_extra;
var init_read_existing_changelog = __esm({
  "libs/core/src/lib/conventional-commits/read-existing-changelog.ts"() {
    "use strict";
    import_fs_extra = __toESM(require("fs-extra"));
    init_constants();
  }
});

// libs/core/src/lib/conventional-commits/update-changelog.ts
var import_conventional_changelog_core, import_fs_extra2, import_get_stream, import_npmlog17;
var init_update_changelog = __esm({
  "libs/core/src/lib/conventional-commits/update-changelog.ts"() {
    "use strict";
    import_conventional_changelog_core = __toESM(require("conventional-changelog-core"));
    import_fs_extra2 = __toESM(require("fs-extra"));
    import_get_stream = __toESM(require("get-stream"));
    import_npmlog17 = __toESM(require("npmlog"));
    init_constants();
    init_get_changelog_config();
    init_make_bump_only_filter();
    init_read_existing_changelog();
  }
});

// libs/core/src/lib/conventional-commits/index.ts
var init_conventional_commits = __esm({
  "libs/core/src/lib/conventional-commits/index.ts"() {
    "use strict";
    init_recommend_version();
    init_update_changelog();
  }
});

// libs/core/src/lib/create-symlink.ts
function createSymlink(src, dest, type) {
  import_npmlog18.default.silly("createSymlink", [src, dest, type]);
  if (process.platform === "win32") {
    return createWindowsSymlink(src, dest, type);
  }
  return createPosixSymlink(src, dest, type);
}
function createSymbolicLink(src, dest, type) {
  import_npmlog18.default.silly("createSymbolicLink", [src, dest, type]);
  return import_fs_extra3.default.lstat(dest).then(() => import_fs_extra3.default.unlink(dest)).catch(() => {
  }).then(() => import_fs_extra3.default.symlink(src, dest, type));
}
function createPosixSymlink(src, dest, _type) {
  const type = _type === "exec" ? "file" : _type;
  const relativeSymlink = import_path8.default.relative(import_path8.default.dirname(dest), src);
  if (_type === "exec") {
    return import_fs_extra3.default.pathExists(src).then((exists) => {
      if (exists) {
        return createSymbolicLink(relativeSymlink, dest, type).then(() => import_fs_extra3.default.chmod(src, 493));
      }
      return shShim(src, dest, type).then(() => import_fs_extra3.default.chmod(dest, 493));
    });
  }
  return createSymbolicLink(relativeSymlink, dest, type);
}
function createWindowsSymlink(src, dest, type) {
  if (type === "exec") {
    return import_fs_extra3.default.pathExists(src).then((exists) => {
      if (exists) {
        return (0, import_cmd_shim.default)(src, dest);
      }
      return import_fs_extra3.default.outputFile(src, "").then(() => (0, import_cmd_shim.default)(src, dest)).then(
        () => import_fs_extra3.default.remove(src),
        (err) => import_fs_extra3.default.remove(src).then(() => {
          throw err;
        })
      );
    });
  }
  return createSymbolicLink(src, dest, type);
}
function shShim(src, dest, type) {
  import_npmlog18.default.silly("shShim", [src, dest, type]);
  const absTarget = import_path8.default.resolve(import_path8.default.dirname(dest), src);
  const scriptLines = ["#!/bin/sh", `chmod +x ${absTarget} && exec ${absTarget} "$@"`];
  return import_fs_extra3.default.writeFile(dest, scriptLines.join("\n"));
}
var import_cmd_shim, import_fs_extra3, import_npmlog18, import_path8;
var init_create_symlink = __esm({
  "libs/core/src/lib/create-symlink.ts"() {
    "use strict";
    import_cmd_shim = __toESM(require("cmd-shim"));
    import_fs_extra3 = __toESM(require("fs-extra"));
    import_npmlog18 = __toESM(require("npmlog"));
    import_path8 = __toESM(require("path"));
  }
});

// libs/core/src/lib/filter-packages.ts
function filterPackages(packagesToFilter, include = [], exclude = [], showPrivate, continueIfNoMatch) {
  const filtered = new Set(packagesToFilter);
  const patterns = [].concat(arrify(include), negate(exclude));
  if (showPrivate === false) {
    for (const pkg of filtered) {
      if (pkg.private) {
        filtered.delete(pkg);
      }
    }
  }
  if (patterns.length) {
    import_npmlog19.default.info("filter", patterns);
    if (!include.length) {
      patterns.unshift("**");
    }
    const pnames = Array.from(filtered).map((pkg) => pkg.name);
    const chosen = new Set((0, import_multimatch.default)(pnames, patterns));
    for (const pkg of filtered) {
      if (!chosen.has(pkg.name)) {
        filtered.delete(pkg);
      }
    }
    if (!filtered.size && !continueIfNoMatch) {
      throw new ValidationError("EFILTER", import_util.default.format("No packages remain after filtering", patterns));
    }
  }
  return Array.from(filtered);
}
function arrify(thing) {
  if (!thing) {
    return [];
  }
  if (!Array.isArray(thing)) {
    return [thing];
  }
  return thing;
}
function negate(patterns) {
  return arrify(patterns).map((pattern) => `!${pattern}`);
}
var import_multimatch, import_npmlog19, import_util;
var init_filter_packages = __esm({
  "libs/core/src/lib/filter-packages.ts"() {
    "use strict";
    import_multimatch = __toESM(require("multimatch"));
    import_npmlog19 = __toESM(require("npmlog"));
    import_util = __toESM(require("util"));
    init_validation_error();
  }
});

// libs/core/src/lib/filter-options.ts
function filterOptions(yargs2) {
  const opts = {
    scope: {
      describe: "Include only packages with names matching the given glob.",
      type: "string",
      requiresArg: true
    },
    ignore: {
      describe: "Exclude packages with names matching the given glob.",
      type: "string",
      requiresArg: true
    },
    "no-private": {
      describe: 'Exclude packages with { "private": true } in their package.json.',
      type: "boolean"
    },
    private: {
      hidden: true,
      type: "boolean"
    },
    since: {
      describe: import_dedent4.default`
        Only include packages that have been changed since the specified [ref].
        If no ref is passed, it defaults to the most-recent tag.
      `,
      type: "string"
    },
    "exclude-dependents": {
      describe: import_dedent4.default`
        Exclude all transitive dependents when running a command
        with --since, overriding the default "changed" algorithm.
      `,
      conflicts: "include-dependents",
      type: "boolean"
    },
    "include-dependents": {
      describe: import_dedent4.default`
        Include all transitive dependents when running a command
        regardless of --scope, --ignore, or --since.
      `,
      conflicts: "exclude-dependents",
      type: "boolean"
    },
    "include-dependencies": {
      describe: import_dedent4.default`
        Include all transitive dependencies when running a command
        regardless of --scope, --ignore, or --since.
      `,
      type: "boolean"
    },
    "include-merged-tags": {
      describe: "Include tags from merged branches when running a command with --since.",
      type: "boolean"
    },
    "continue-if-no-match": {
      describe: "Don't fail if no package is matched",
      hidden: true,
      type: "boolean"
    }
  };
  return yargs2.options(opts).group(Object.keys(opts), "Filter Options:").option("include-filtered-dependents", {
    hidden: true,
    conflicts: ["exclude-dependents", "include-dependents"],
    type: "boolean"
  }).option("include-filtered-dependencies", {
    hidden: true,
    conflicts: "include-dependencies",
    type: "boolean"
  }).check((argv) => {
    if (argv["includeFilteredDependents"]) {
      argv["includeDependents"] = true;
      argv["include-dependents"] = true;
      delete argv["includeFilteredDependents"];
      delete argv["include-filtered-dependents"];
      import_npmlog20.default.warn("deprecated", "--include-filtered-dependents has been renamed --include-dependents");
    }
    if (argv["includeFilteredDependencies"]) {
      argv["includeDependencies"] = true;
      argv["include-dependencies"] = true;
      delete argv["includeFilteredDependencies"];
      delete argv["include-filtered-dependencies"];
      import_npmlog20.default.warn("deprecated", "--include-filtered-dependencies has been renamed --include-dependencies");
    }
    return argv;
  });
}
function getFilteredPackages(packageGraph, execOpts, opts) {
  const options = { log: import_npmlog20.default, ...opts };
  if (options.scope) {
    options.log.notice("filter", "including %j", options.scope);
  }
  if (options.ignore) {
    options.log.notice("filter", "excluding %j", options.ignore);
  }
  let chain = Promise.resolve();
  chain = chain.then(
    () => filterPackages(
      packageGraph.rawPackageList,
      options.scope,
      options.ignore,
      options.private,
      options.continueIfNoMatch
    )
  );
  if (options.since !== void 0) {
    options.log.notice("filter", "changed since %j", options.since);
    if (options.excludeDependents) {
      options.log.notice("filter", "excluding dependents");
    }
    if (options.includeMergedTags) {
      options.log.notice("filter", "including merged tags");
    }
    chain = chain.then(
      (filteredPackages) => Promise.resolve(collectUpdates(filteredPackages, packageGraph, execOpts, opts)).then((updates) => {
        const updated = new Set(updates.map(({ pkg }) => pkg.name));
        return filteredPackages.filter((pkg) => updated.has(pkg.name));
      })
    );
  }
  if (options.includeDependents) {
    options.log.notice("filter", "including dependents");
    chain = chain.then((filteredPackages) => packageGraph.addDependents(filteredPackages));
  }
  if (options.includeDependencies) {
    options.log.notice("filter", "including dependencies");
    chain = chain.then((filteredPackages) => packageGraph.addDependencies(filteredPackages));
  }
  return chain;
}
var import_dedent4, import_npmlog20;
var init_filter_options = __esm({
  "libs/core/src/lib/filter-options.ts"() {
    "use strict";
    import_dedent4 = __toESM(require("dedent"));
    import_npmlog20 = __toESM(require("npmlog"));
    init_collect_updates();
    init_filter_packages();
  }
});

// libs/core/src/lib/has-npm-version.ts
function hasNpmVersion(range) {
  return rangeSatisfies(getNpmVersion(), range);
}
function rangeSatisfies(npmVersion, range) {
  return Boolean(import_semver4.default.satisfies(npmVersion, range));
}
function getNpmVersion() {
  return childProcess6.execSync("npm", ["--version"]);
}
var import_semver4, childProcess6;
var init_has_npm_version = __esm({
  "libs/core/src/lib/has-npm-version.ts"() {
    "use strict";
    import_semver4 = __toESM(require("semver"));
    childProcess6 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/query-graph.ts
var QueryGraph, toposort;
var init_query_graph = __esm({
  "libs/core/src/lib/query-graph.ts"() {
    "use strict";
    init_package_graph();
    QueryGraph = class {
      graph;
      cycles;
      static toposort(packages, options) {
        const graph = new QueryGraph(packages, options);
        const result = [];
        let batch = graph.getAvailablePackages();
        while (batch.length) {
          for (const node of batch) {
            result.push(node.pkg);
            graph.markAsDone(node);
          }
          batch = graph.getAvailablePackages();
        }
        return result;
      }
      constructor(packages, { graphType = "allDependencies", rejectCycles } = {}) {
        this.graph = new PackageGraph(packages, graphType);
        this.cycles = this.graph.collapseCycles(rejectCycles);
      }
      _getNextLeaf() {
        return Array.from(this.graph.values()).filter((node) => node.localDependencies.size === 0);
      }
      _getNextCycle() {
        const cycle = Array.from(this.cycles).find((cycleNode) => cycleNode.localDependencies.size === 0);
        if (!cycle) {
          return [];
        }
        this.cycles.delete(cycle);
        return cycle.flatten();
      }
      getAvailablePackages() {
        const availablePackages = this._getNextLeaf();
        if (availablePackages.length > 0) {
          return availablePackages;
        }
        return this._getNextCycle();
      }
      markAsTaken(name) {
        this.graph.delete(name);
      }
      markAsDone(candidateNode) {
        this.graph.remove(candidateNode);
        for (const cycle of this.cycles) {
          cycle.unlink(candidateNode);
        }
      }
    };
    toposort = QueryGraph.toposort;
  }
});

// libs/core/src/lib/listable/listable-format.ts
var import_chalk2, import_columnify;
var init_listable_format = __esm({
  "libs/core/src/lib/listable/listable-format.ts"() {
    "use strict";
    import_chalk2 = __toESM(require("chalk"));
    import_columnify = __toESM(require("columnify"));
    init_query_graph();
  }
});

// libs/core/src/lib/listable/listable-options.ts
var init_listable_options = __esm({
  "libs/core/src/lib/listable/listable-options.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/log-packed.ts
var import_byte_size, import_columnify2, import_npmlog21, import_has_unicode, hasUnicode;
var init_log_packed = __esm({
  "libs/core/src/lib/log-packed.ts"() {
    "use strict";
    import_byte_size = __toESM(require("byte-size"));
    import_columnify2 = __toESM(require("columnify"));
    import_npmlog21 = __toESM(require("npmlog"));
    import_has_unicode = __toESM(require("has-unicode"));
    hasUnicode = (0, import_has_unicode.default)();
  }
});

// libs/core/src/lib/get-npm-exec-opts.ts
function getNpmExecOpts(pkg, registry) {
  const env = {
    LERNA_PACKAGE_NAME: pkg.name
  };
  if (registry) {
    env.npm_config_registry = registry;
  }
  import_npmlog22.default.silly("getNpmExecOpts", pkg.location, registry);
  return {
    cwd: pkg.location,
    env,
    pkg
  };
}
var import_npmlog22;
var init_get_npm_exec_opts = __esm({
  "libs/core/src/lib/get-npm-exec-opts.ts"() {
    "use strict";
    import_npmlog22 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/npm-install.ts
function npmInstall(pkg, { registry, npmClient, npmClientArgs, npmGlobalStyle, mutex, stdio = "pipe", subCommand = "install" }) {
  const opts = getNpmExecOpts(pkg, registry);
  const args = [subCommand];
  let cmd = npmClient || "npm";
  if (npmGlobalStyle) {
    cmd = "npm";
    args.push("--global-style");
  }
  if (cmd === "yarn" && mutex) {
    args.push("--mutex", mutex);
  }
  if (cmd === "yarn") {
    args.push("--non-interactive");
  }
  if (npmClientArgs && npmClientArgs.length) {
    args.push(...npmClientArgs);
  }
  opts.stdio = stdio;
  opts.env.LERNA_EXEC_PATH = pkg.location;
  opts.env.LERNA_ROOT_PATH = pkg.rootPath;
  import_npmlog23.default.silly("npmInstall", [cmd, args]);
  return childProcess7.exec(cmd, args, opts);
}
function npmInstallDependencies(pkg, dependencies, config) {
  import_npmlog23.default.silly("npmInstallDependencies", pkg.name, dependencies);
  if (!(dependencies && dependencies.length)) {
    import_npmlog23.default.verbose("npmInstallDependencies", "no dependencies to install");
    return Promise.resolve();
  }
  const packageJsonBkp = `${pkg.manifestLocation}.lerna_backup`;
  import_npmlog23.default.silly("npmInstallDependencies", "backup", pkg.manifestLocation);
  return import_fs_extra4.default.copy(pkg.manifestLocation, packageJsonBkp).then(() => {
    const cleanup = () => {
      import_npmlog23.default.silly("npmInstallDependencies", "cleanup", pkg.manifestLocation);
      import_fs_extra4.default.renameSync(packageJsonBkp, pkg.manifestLocation);
    };
    const unregister = (0, import_signal_exit.default)(cleanup);
    const done = (finalError) => {
      cleanup();
      unregister();
      if (finalError) {
        throw finalError;
      }
    };
    const tempJson = transformManifest(pkg, dependencies);
    import_npmlog23.default.silly("npmInstallDependencies", "writing tempJson", tempJson);
    return (0, import_write_pkg2.default)(pkg.manifestLocation, tempJson).then(() => npmInstall(pkg, config)).then(() => done(), done);
  });
}
function transformManifest(pkg, dependencies) {
  const json = pkg.toJSON();
  const depMap = new Map(
    dependencies.map((dep) => {
      const { name, rawSpec } = (0, import_npm_package_arg4.default)(dep, pkg.location);
      return [name, rawSpec || "*"];
    })
  );
  delete json.scripts;
  ["dependencies", "devDependencies", "optionalDependencies"].forEach((depType) => {
    const collection = json[depType];
    if (collection) {
      Object.keys(collection).forEach((depName) => {
        if (depMap.has(depName)) {
          collection[depName] = depMap.get(depName);
          depMap.delete(depName);
        } else {
          delete collection[depName];
        }
      });
    }
  });
  ["bundledDependencies", "bundleDependencies"].forEach((depType) => {
    const collection = json[depType];
    if (Array.isArray(collection)) {
      const newCollection = [];
      for (const depName of collection) {
        if (depMap.has(depName)) {
          newCollection.push(depName);
          depMap.delete(depName);
        }
      }
      json[depType] = newCollection;
    }
  });
  if (depMap.size) {
    if (!json.dependencies) {
      json.dependencies = {};
    }
    depMap.forEach((depVersion, depName) => {
      json.dependencies[depName] = depVersion;
    });
  }
  return json;
}
var import_fs_extra4, import_npm_package_arg4, import_npmlog23, import_signal_exit, import_write_pkg2, childProcess7;
var init_npm_install = __esm({
  "libs/core/src/lib/npm-install.ts"() {
    "use strict";
    import_fs_extra4 = __toESM(require("fs-extra"));
    import_npm_package_arg4 = __toESM(require("npm-package-arg"));
    import_npmlog23 = __toESM(require("npmlog"));
    import_signal_exit = __toESM(require("signal-exit"));
    import_write_pkg2 = __toESM(require("write-pkg"));
    init_get_npm_exec_opts();
    childProcess7 = require("@lerna/child-process");
    module.exports.npmInstallDependencies = npmInstallDependencies;
  }
});

// libs/core/src/lib/prompt.ts
function promptTextInput(message, { filter, validate } = {}) {
  import_npmlog24.default.pause();
  return import_inquirer.default.prompt([
    {
      type: "input",
      name: "input",
      message,
      filter,
      validate
    }
  ]).then((answers) => {
    import_npmlog24.default.resume();
    return answers.input;
  });
}
var import_inquirer, import_npmlog24;
var init_prompt = __esm({
  "libs/core/src/lib/prompt.ts"() {
    "use strict";
    import_inquirer = __toESM(require("inquirer"));
    import_npmlog24 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/otplease.ts
function otplease(fn, _opts, otpCache) {
  const opts = { ...otpCache, ..._opts };
  return attempt(fn, opts, otpCache);
}
function attempt(fn, opts, otpCache) {
  return new Promise((resolve) => {
    resolve(fn(opts));
  }).catch((err) => {
    if (err.code !== "EOTP" && !(err.code === "E401" && /one-time pass/.test(err.body))) {
      throw err;
    } else if (!process.stdin.isTTY || !process.stdout.isTTY) {
      throw err;
    } else {
      if (otpCache != null && otpCache.otp != null && otpCache.otp !== opts["otp"]) {
        return attempt(fn, { ...opts, ...otpCache }, otpCache);
      }
      return semaphore.wait().then(() => {
        if (otpCache != null && otpCache.otp != null && otpCache.otp !== opts["otp"]) {
          semaphore.release();
          return attempt(fn, { ...opts, ...otpCache }, otpCache);
        }
        return getOneTimePassword().then(
          (otp) => {
            if (otpCache != null) {
              otpCache.otp = otp;
            }
            semaphore.release();
            return otp;
          },
          (promptError) => {
            semaphore.release();
            return Promise.reject(promptError);
          }
        ).then((otp) => {
          return fn({ ...opts, otp });
        });
      });
    }
  });
}
function getOneTimePassword(message = "This operation requires a one-time password:") {
  return promptTextInput(message, {
    filter: (otp) => otp.replace(/\s+/g, ""),
    validate: (otp) => otp && /^[\d ]+$|^[A-Fa-f0-9]{64,64}$/.test(otp) || "Must be a valid one-time-password. See https://docs.npmjs.com/getting-started/using-two-factor-authentication"
  });
}
var semaphore;
var init_otplease = __esm({
  "libs/core/src/lib/otplease.ts"() {
    "use strict";
    init_prompt();
    semaphore = {
      _promise: void 0,
      _resolve: void 0,
      wait() {
        return new Promise((resolve) => {
          if (!this._promise) {
            this._promise = new Promise((release) => {
              this._resolve = release;
            });
            resolve(void 0);
          } else {
            resolve(this._promise.then(() => this.wait()));
          }
        });
      },
      release() {
        const resolve = this._resolve;
        if (resolve) {
          this._resolve = void 0;
          this._promise = void 0;
          resolve();
        }
      }
    };
  }
});

// libs/core/src/lib/npm-conf/env-replace.ts
function envReplace(str) {
  if (typeof str !== "string" || !str) {
    return str;
  }
  const regex = /(\\*)\$\{([^}]+)\}/g;
  return str.replace(regex, (orig, esc, name) => {
    esc = esc.length > 0 && esc.length % 2;
    if (esc) {
      return orig;
    }
    if (process.env[name] === void 0) {
      throw new Error(`Failed to replace env in config: ${orig}`);
    }
    return process.env[name];
  });
}
var init_env_replace = __esm({
  "libs/core/src/lib/npm-conf/env-replace.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/npm-conf/find-prefix.ts
function findPrefix(start) {
  let dir = import_path9.default.resolve(start);
  let walkedUp = false;
  while (import_path9.default.basename(dir) === "node_modules") {
    dir = import_path9.default.dirname(dir);
    walkedUp = true;
  }
  if (walkedUp) {
    return dir;
  }
  return find(dir, dir);
}
function find(name, original) {
  if (name === "/" || process.platform === "win32" && /^[a-zA-Z]:(\\|\/)?$/.test(name)) {
    return original;
  }
  try {
    const files = import_fs2.default.readdirSync(name);
    if (files.indexOf("node_modules") !== -1 || files.indexOf("package.json") !== -1) {
      return name;
    }
    const dirname = import_path9.default.dirname(name);
    if (dirname === name) {
      return original;
    }
    return find(dirname, original);
  } catch (err) {
    if (name === original) {
      if (err.code === "ENOENT") {
        return original;
      }
      throw err;
    }
    return original;
  }
}
var import_fs2, import_path9;
var init_find_prefix = __esm({
  "libs/core/src/lib/npm-conf/find-prefix.ts"() {
    "use strict";
    import_fs2 = __toESM(require("fs"));
    import_path9 = __toESM(require("path"));
  }
});

// libs/core/src/lib/npm-conf/types.ts
var require_types = __commonJS({
  "libs/core/src/lib/npm-conf/types.ts"(exports2) {
    "use strict";
    var import_path17 = __toESM(require("path"));
    var import_stream = require("stream");
    var import_url2 = __toESM(require("url"));
    var Umask = () => {
    };
    var getLocalAddresses = () => [];
    var semver5 = () => {
    };
    exports2.types = {
      access: [null, "restricted", "public"],
      "allow-same-version": Boolean,
      "always-auth": Boolean,
      also: [null, "dev", "development"],
      audit: Boolean,
      "audit-level": ["low", "moderate", "high", "critical"],
      "auth-type": ["legacy", "sso", "saml", "oauth"],
      "bin-links": Boolean,
      browser: [null, String],
      ca: [null, String, Array],
      cafile: import_path17.default,
      cache: import_path17.default,
      "cache-lock-stale": Number,
      "cache-lock-retries": Number,
      "cache-lock-wait": Number,
      "cache-max": Number,
      "cache-min": Number,
      cert: [null, String],
      cidr: [null, String, Array],
      color: ["always", Boolean],
      depth: Number,
      description: Boolean,
      dev: Boolean,
      "dry-run": Boolean,
      editor: String,
      "engine-strict": Boolean,
      force: Boolean,
      "fetch-retries": Number,
      "fetch-retry-factor": Number,
      "fetch-retry-mintimeout": Number,
      "fetch-retry-maxtimeout": Number,
      git: String,
      "git-tag-version": Boolean,
      "commit-hooks": Boolean,
      global: Boolean,
      globalconfig: import_path17.default,
      "global-style": Boolean,
      group: [Number, String],
      "https-proxy": [null, import_url2.default],
      "user-agent": String,
      "ham-it-up": Boolean,
      heading: String,
      "if-present": Boolean,
      "ignore-prepublish": Boolean,
      "ignore-scripts": Boolean,
      "init-module": import_path17.default,
      "init-author-name": String,
      "init-author-email": String,
      "init-author-url": ["", import_url2.default],
      "init-license": String,
      "init-version": semver5,
      json: Boolean,
      key: [null, String],
      "legacy-bundling": Boolean,
      link: Boolean,
      "local-address": getLocalAddresses(),
      loglevel: ["silent", "error", "warn", "notice", "http", "timing", "info", "verbose", "silly"],
      logstream: import_stream.Stream,
      "logs-max": Number,
      long: Boolean,
      maxsockets: Number,
      message: String,
      "metrics-registry": [null, String],
      "node-options": [null, String],
      "node-version": [null, semver5],
      noproxy: [null, String, Array],
      offline: Boolean,
      "onload-script": [null, String],
      only: [null, "dev", "development", "prod", "production"],
      optional: Boolean,
      "package-lock": Boolean,
      otp: [null, String],
      "package-lock-only": Boolean,
      parseable: Boolean,
      "prefer-offline": Boolean,
      "prefer-online": Boolean,
      prefix: import_path17.default,
      preid: String,
      production: Boolean,
      progress: Boolean,
      proxy: [null, false, import_url2.default],
      "read-only": Boolean,
      "rebuild-bundle": Boolean,
      registry: [null, import_url2.default],
      rollback: Boolean,
      save: Boolean,
      "save-bundle": Boolean,
      "save-dev": Boolean,
      "save-exact": Boolean,
      "save-optional": Boolean,
      "save-prefix": String,
      "save-prod": Boolean,
      scope: String,
      "script-shell": [null, String],
      "scripts-prepend-node-path": [false, true, "auto", "warn-only"],
      searchopts: String,
      searchexclude: [null, String],
      searchlimit: Number,
      searchstaleness: Number,
      "send-metrics": Boolean,
      shell: String,
      shrinkwrap: Boolean,
      "sign-git-commit": Boolean,
      "sign-git-tag": Boolean,
      "sso-poll-frequency": Number,
      "sso-type": [null, "oauth", "saml"],
      "strict-ssl": Boolean,
      tag: String,
      timing: Boolean,
      tmp: import_path17.default,
      unicode: Boolean,
      "unsafe-perm": Boolean,
      "update-notifier": Boolean,
      usage: Boolean,
      user: [Number, String],
      userconfig: import_path17.default,
      umask: Umask,
      version: Boolean,
      "tag-version-prefix": String,
      versions: Boolean,
      viewer: String,
      _exit: Boolean
    };
  }
});

// libs/core/src/lib/npm-conf/parse-field.ts
function parseField(input, key) {
  if (typeof input !== "string") {
    return input;
  }
  const typeList = [].concat(types[key]);
  const isPath = typeList.indexOf(import_path10.default) !== -1;
  const isBool = typeList.indexOf(Boolean) !== -1;
  const isString = typeList.indexOf(String) !== -1;
  const isNumber = typeList.indexOf(Number) !== -1;
  let field = `${input}`.trim();
  if (/^".*"$/.test(field)) {
    try {
      field = JSON.parse(field);
    } catch (err) {
      throw new Error(`Failed parsing JSON config key ${key}: ${field}`);
    }
  }
  if (isBool && !isString && field === "") {
    return true;
  }
  switch (field) {
    case "true": {
      return true;
    }
    case "false": {
      return false;
    }
    case "null": {
      return null;
    }
    case "undefined": {
      return void 0;
    }
  }
  field = envReplace(field);
  if (isPath) {
    const regex = process.platform === "win32" ? /^~(\/|\\)/ : /^~\//;
    if (regex.test(field) && process.env["HOME"]) {
      field = import_path10.default.resolve(process.env["HOME"], field.substr(2));
    }
    field = import_path10.default.resolve(field);
  }
  if (isNumber && !Number.isNaN(field)) {
    field = Number(field);
  }
  return field;
}
var import_path10, types;
var init_parse_field = __esm({
  "libs/core/src/lib/npm-conf/parse-field.ts"() {
    "use strict";
    import_path10 = __toESM(require("path"));
    init_env_replace();
    ({ types } = require_types());
  }
});

// libs/core/src/lib/npm-conf/nerf-dart.ts
function toNerfDart(uri) {
  const parsed = import_url.default.parse(uri);
  delete parsed.protocol;
  delete parsed.auth;
  delete parsed.query;
  delete parsed.search;
  delete parsed.hash;
  return import_url.default.resolve(import_url.default.format(parsed), ".");
}
var import_url;
var init_nerf_dart = __esm({
  "libs/core/src/lib/npm-conf/nerf-dart.ts"() {
    "use strict";
    import_url = __toESM(require("url"));
  }
});

// libs/core/src/lib/npm-conf/conf.ts
var import_assert, import_fs3, import_path11, ConfigChain, Conf;
var init_conf = __esm({
  "libs/core/src/lib/npm-conf/conf.ts"() {
    "use strict";
    import_assert = __toESM(require("assert"));
    import_fs3 = __toESM(require("fs"));
    import_path11 = __toESM(require("path"));
    init_env_replace();
    init_find_prefix();
    init_parse_field();
    init_nerf_dart();
    ({ ConfigChain } = require("config-chain"));
    Conf = class extends ConfigChain {
      root;
      constructor(base) {
        super(base);
        this.root = base;
      }
      add(data, marker) {
        try {
          for (const x of Object.keys(data)) {
            const newKey = envReplace(x);
            const newField = parseField(data[x], newKey);
            delete data[x];
            data[newKey] = newField;
          }
        } catch (err) {
          throw err;
        }
        return super.add(data, marker);
      }
      addFile(file, name = file) {
        const marker = { __source__: name };
        this["sources"][name] = { path: file, type: "ini" };
        this["push"](marker);
        this["_await"]();
        try {
          const contents = import_fs3.default.readFileSync(file, "utf8");
          this["addString"](contents, file, "ini", marker);
        } catch (err) {
          this["add"]({}, marker);
        }
        return this;
      }
      addEnv(env = process.env) {
        const conf = {};
        Object.keys(env).filter((x) => /^npm_config_/i.test(x)).forEach((x) => {
          if (!env[x]) {
            return;
          }
          const p = x.toLowerCase().replace(/^npm_config_/, "").replace(/(?!^)_/g, "-");
          conf[p] = env[x];
        });
        return super.addEnv("", conf, "env");
      }
      loadPrefix() {
        const cli = this["list"][0];
        Object.defineProperty(this, "prefix", {
          enumerable: true,
          set: (prefix) => {
            const g = this["get"]("global");
            this[g ? "globalPrefix" : "localPrefix"] = prefix;
          },
          get: () => {
            const g = this["get"]("global");
            return g ? this["globalPrefix"] : this["localPrefix"];
          }
        });
        Object.defineProperty(this, "globalPrefix", {
          enumerable: true,
          set: (prefix) => {
            this["set"]("prefix", prefix);
          },
          get: () => import_path11.default.resolve(this["get"]("prefix"))
        });
        let p;
        Object.defineProperty(this, "localPrefix", {
          enumerable: true,
          set: (prefix) => {
            p = prefix;
          },
          get: () => p
        });
        if (Object.prototype.hasOwnProperty.call(cli, "prefix")) {
          p = import_path11.default.resolve(cli.prefix);
        } else {
          try {
            p = findPrefix(process.cwd());
          } catch (err) {
            throw err;
          }
        }
        return p;
      }
      loadCAFile(file) {
        if (!file) {
          return;
        }
        try {
          const contents = import_fs3.default.readFileSync(file, "utf8");
          const delim = "-----END CERTIFICATE-----";
          const output2 = contents.split(delim).filter((x) => Boolean(x.trim())).map((x) => x.trimLeft() + delim);
          this["set"]("ca", output2);
        } catch (err) {
          if (err.code === "ENOENT") {
            return;
          }
          throw err;
        }
      }
      loadUser() {
        const defConf = this.root;
        if (this["get"]("global")) {
          return;
        }
        if (process.env["SUDO_UID"]) {
          defConf.user = Number(process.env["SUDO_UID"]);
          return;
        }
        const prefix = import_path11.default.resolve(this["get"]("prefix"));
        try {
          const stats = import_fs3.default.statSync(prefix);
          defConf.user = stats.uid;
        } catch (err) {
          if (err.code === "ENOENT") {
            return;
          }
          throw err;
        }
      }
      getCredentialsByURI(uri) {
        (0, import_assert.default)(uri && typeof uri === "string", "registry URL is required");
        const nerfed = toNerfDart(uri);
        const defnerf = toNerfDart(this["get"]("registry"));
        const c = {
          scope: nerfed,
          token: void 0,
          password: void 0,
          username: void 0,
          email: void 0,
          auth: void 0,
          alwaysAuth: void 0
        };
        if (this["get"](`${nerfed}:always-auth`) !== void 0) {
          const val = this["get"](`${nerfed}:always-auth`);
          c.alwaysAuth = val === "false" ? false : !!val;
        } else if (this["get"]("always-auth") !== void 0) {
          c.alwaysAuth = this["get"]("always-auth");
        }
        if (this["get"](`${nerfed}:_authToken`)) {
          c.token = this["get"](`${nerfed}:_authToken`);
          return c;
        }
        let authDef = this["get"]("_auth");
        let userDef = this["get"]("username");
        let passDef = this["get"]("_password");
        if (authDef && !(userDef && passDef)) {
          authDef = Buffer.from(authDef, "base64").toString();
          authDef = authDef.split(":");
          userDef = authDef.shift();
          passDef = authDef.join(":");
        }
        if (this["get"](`${nerfed}:_password`)) {
          c.password = Buffer.from(this["get"](`${nerfed}:_password`), "base64").toString("utf8");
        } else if (nerfed === defnerf && passDef) {
          c.password = passDef;
        }
        if (this["get"](`${nerfed}:username`)) {
          c.username = this["get"](`${nerfed}:username`);
        } else if (nerfed === defnerf && userDef) {
          c.username = userDef;
        }
        if (this["get"](`${nerfed}:email`)) {
          c.email = this["get"](`${nerfed}:email`);
        } else if (this["get"]("email")) {
          c.email = this["get"]("email");
        }
        if (c.username && c.password) {
          c.auth = Buffer.from(`${c.username}:${c.password}`).toString("base64");
        }
        return c;
      }
      setCredentialsByURI(uri, c) {
        (0, import_assert.default)(uri && typeof uri === "string", "registry URL is required");
        (0, import_assert.default)(c && typeof c === "object", "credentials are required");
        const nerfed = toNerfDart(uri);
        if (c.token) {
          this["set"](`${nerfed}:_authToken`, c.token, "user");
          this["del"](`${nerfed}:_password`, "user");
          this["del"](`${nerfed}:username`, "user");
          this["del"](`${nerfed}:email`, "user");
          this["del"](`${nerfed}:always-auth`, "user");
        } else if (c.username || c.password || c.email) {
          (0, import_assert.default)(c.username, "must include username");
          (0, import_assert.default)(c.password, "must include password");
          (0, import_assert.default)(c.email, "must include email address");
          this["del"](`${nerfed}:_authToken`, "user");
          const encoded = Buffer.from(c.password, "utf8").toString("base64");
          this["set"](`${nerfed}:_password`, encoded, "user");
          this["set"](`${nerfed}:username`, c.username, "user");
          this["set"](`${nerfed}:email`, c.email, "user");
          if (c.alwaysAuth !== void 0) {
            this["set"](`${nerfed}:always-auth`, c.alwaysAuth, "user");
          } else {
            this["del"](`${nerfed}:always-auth`, "user");
          }
        } else {
          throw new Error("No credentials to set.");
        }
      }
    };
  }
});

// libs/core/src/lib/npm-conf/defaults.ts
var require_defaults = __commonJS({
  "libs/core/src/lib/npm-conf/defaults.ts"(exports2) {
    "use strict";
    var import_os3 = __toESM(require("os"));
    var import_path17 = __toESM(require("path"));
    var temp = import_os3.default.tmpdir();
    var uidOrPid = process.getuid ? process.getuid() : process.pid;
    var hasUnicode2 = () => true;
    var isWindows = process.platform === "win32";
    var osenv = {
      editor: () => process.env["EDITOR"] || process.env["VISUAL"] || (isWindows ? "notepad.exe" : "vi"),
      shell: () => isWindows ? process.env["COMSPEC"] || "cmd.exe" : process.env["SHELL"] || "/bin/bash"
    };
    var umask = {
      fromString: () => process.umask()
    };
    var home = import_os3.default.homedir();
    if (home) {
      process.env["HOME"] = home;
    } else {
      home = import_path17.default.resolve(temp, `npm-${uidOrPid}`);
    }
    var cacheExtra = process.platform === "win32" ? "npm-cache" : ".npm";
    var cacheRoot = process.platform === "win32" && process.env["APPDATA"] || home;
    var cache = import_path17.default.resolve(cacheRoot, cacheExtra);
    var defaults;
    var globalPrefix;
    Object.defineProperty(exports2, "defaults", {
      get() {
        if (defaults) {
          return defaults;
        }
        if (process.env["PREFIX"]) {
          globalPrefix = process.env["PREFIX"];
        } else if (process.platform === "win32") {
          globalPrefix = import_path17.default.dirname(process.execPath);
        } else {
          globalPrefix = import_path17.default.dirname(import_path17.default.dirname(process.execPath));
          if (process.env["DESTDIR"]) {
            globalPrefix = import_path17.default.join(process.env["DESTDIR"], globalPrefix);
          }
        }
        defaults = {
          access: null,
          "allow-same-version": false,
          "always-auth": false,
          also: null,
          audit: true,
          "audit-level": "low",
          "auth-type": "legacy",
          "bin-links": true,
          browser: null,
          ca: null,
          cafile: null,
          cache,
          "cache-lock-stale": 6e4,
          "cache-lock-retries": 10,
          "cache-lock-wait": 1e4,
          "cache-max": Infinity,
          "cache-min": 10,
          cert: null,
          cidr: null,
          color: process.env["NO_COLOR"] == null,
          depth: Infinity,
          description: true,
          dev: false,
          "dry-run": false,
          editor: osenv.editor(),
          "engine-strict": false,
          force: false,
          "fetch-retries": 2,
          "fetch-retry-factor": 10,
          "fetch-retry-mintimeout": 1e4,
          "fetch-retry-maxtimeout": 6e4,
          git: "git",
          "git-tag-version": true,
          "commit-hooks": true,
          global: false,
          globalconfig: import_path17.default.resolve(globalPrefix, "etc", "npmrc"),
          "global-style": false,
          group: process.platform === "win32" ? 0 : process.env["SUDO_GID"] || process.getgid && process.getgid(),
          "ham-it-up": false,
          heading: "npm",
          "if-present": false,
          "ignore-prepublish": false,
          "ignore-scripts": false,
          "init-module": import_path17.default.resolve(home, ".npm-init.js"),
          "init-author-name": "",
          "init-author-email": "",
          "init-author-url": "",
          "init-version": "1.0.0",
          "init-license": "ISC",
          json: false,
          key: null,
          "legacy-bundling": false,
          link: false,
          "local-address": void 0,
          loglevel: "notice",
          logstream: process.stderr,
          "logs-max": 10,
          long: false,
          maxsockets: 50,
          message: "%s",
          "metrics-registry": null,
          "node-options": null,
          "node-version": process.version,
          offline: false,
          "onload-script": false,
          only: null,
          optional: true,
          otp: void 0,
          "package-lock": true,
          "package-lock-only": false,
          parseable: false,
          "prefer-offline": false,
          "prefer-online": false,
          prefix: globalPrefix,
          preid: "",
          production: process.env["NODE_ENV"] === "production",
          progress: !process.env["TRAVIS"] && !process.env["CI"],
          proxy: null,
          "https-proxy": null,
          noproxy: null,
          "user-agent": "npm/{npm-version} node/{node-version} {platform} {arch}",
          "read-only": false,
          "rebuild-bundle": true,
          registry: "https://registry.npmjs.org/",
          rollback: true,
          save: true,
          "save-bundle": false,
          "save-dev": false,
          "save-exact": false,
          "save-optional": false,
          "save-prefix": "^",
          "save-prod": false,
          scope: "",
          "script-shell": void 0,
          "scripts-prepend-node-path": "warn-only",
          searchopts: "",
          searchexclude: null,
          searchlimit: 20,
          searchstaleness: 15 * 60,
          "send-metrics": false,
          shell: osenv.shell(),
          shrinkwrap: true,
          "sign-git-commit": false,
          "sign-git-tag": false,
          "sso-poll-frequency": 500,
          "sso-type": "oauth",
          "strict-ssl": true,
          tag: "latest",
          "tag-version-prefix": "v",
          timing: false,
          tmp: temp,
          unicode: hasUnicode2(),
          "unsafe-perm": process.platform === "win32" || process.platform === "cygwin" || !(process.getuid && process.setuid && process.getgid && process.setgid) || process.getuid() !== 0,
          "update-notifier": true,
          usage: false,
          user: process.platform === "win32" || import_os3.default.type() === "OS400" ? 0 : "nobody",
          userconfig: import_path17.default.resolve(home, ".npmrc"),
          umask: process.umask ? process.umask() : umask.fromString("022"),
          version: false,
          versions: false,
          viewer: process.platform === "win32" ? "browser" : "man",
          _exit: true
        };
        return defaults;
      }
    });
  }
});

// libs/core/src/lib/npm-conf/index.ts
var require_npm_conf = __commonJS({
  "libs/core/src/lib/npm-conf/index.ts"(exports2, module2) {
    "use strict";
    var import_path17 = __toESM(require("path"));
    init_conf();
    init_nerf_dart();
    var { defaults } = require_defaults();
    module2.exports = npmConf3;
    module2.exports.Conf = Conf;
    module2.exports.defaults = Object.assign({}, defaults);
    module2.exports.toNerfDart = toNerfDart;
    function npmConf3(opts) {
      const conf = new Conf(Object.assign({}, defaults));
      const cleanOpts = opts ? Object.keys(opts).reduce((acc, key) => {
        if (opts[key] !== void 0) {
          acc[key] = opts[key];
        }
        return acc;
      }, {}) : {};
      conf.add(cleanOpts, "cli");
      conf.addEnv();
      conf.loadPrefix();
      const projectConf = import_path17.default.resolve(conf["localPrefix"], ".npmrc");
      const userConf = conf["get"]("userconfig");
      if (!conf["get"]("global") && projectConf !== userConf) {
        conf.addFile(projectConf, "project");
      } else {
        conf.add({}, "project");
      }
      conf.addFile(conf["get"]("userconfig"), "user");
      if (conf["get"]("prefix")) {
        const etc = import_path17.default.resolve(conf["get"]("prefix"), "etc");
        conf.root.globalconfig = import_path17.default.resolve(etc, "npmrc");
        conf.root.globalignorefile = import_path17.default.resolve(etc, "npmignore");
      }
      conf.addFile(conf["get"]("globalconfig"), "global");
      conf.loadUser();
      const caFile = conf["get"]("cafile");
      if (caFile) {
        conf.loadCAFile(caFile);
      }
      return conf;
    }
  }
});

// libs/core/src/lib/run-lifecycle.ts
function flattenOptions(obj) {
  return {
    ignorePrepublish: obj["ignore-prepublish"],
    ignoreScripts: obj["ignore-scripts"],
    nodeOptions: obj["node-options"],
    scriptShell: obj["script-shell"],
    scriptsPrependNodePath: obj["scripts-prepend-node-path"],
    unsafePerm: obj["unsafe-perm"],
    ...obj
  };
}
function printCommandBanner(id, event, cmd, path17) {
  return console.log(`
> ${id ? `${id} ` : ""}${event} ${path17}
> ${cmd.trim().replace(/\n/g, "\n> ")}
`);
}
function runLifecycle(pkg, stage, options) {
  if ("root" in options) {
    options = options.snapshot;
  }
  const opts = {
    log: import_npmlog25.default,
    unsafePerm: true,
    ...flattenOptions(options)
  };
  const dir = pkg.location;
  const id = `${pkg.name}@${pkg.version}`;
  const config = {};
  if (opts.ignoreScripts) {
    opts.log.verbose("lifecycle", "%j ignored in %j", stage, pkg.name);
    return Promise.resolve();
  }
  if (!pkg.scripts || !pkg.scripts[stage]) {
    opts.log.silly("lifecycle", "No script for %j in %j, continuing", stage, pkg.name);
    return Promise.resolve();
  }
  if (stage === "prepublish" && opts.ignorePrepublish) {
    opts.log.verbose("lifecycle", "%j ignored in %j", stage, pkg.name);
    return Promise.resolve();
  }
  for (const [key, val] of Object.entries(opts)) {
    if (val != null && key !== "log" && key !== "logstream") {
      config[key] = val;
    }
  }
  if (pkg.__isLernaPackage) {
    pkg = pkg.toJSON();
  }
  pkg._id = id;
  opts.log.silly("lifecycle", "%j starting in %j", stage, pkg.name);
  opts.log.info("lifecycle", `${id}~${stage}: ${id}`);
  const stdio = opts.stdio || "pipe";
  if (import_npmlog25.default.level !== "silent") {
    printCommandBanner(id, stage, pkg.scripts[stage], dir);
  }
  return queue.add(
    async () => runScript({
      event: stage,
      path: dir,
      pkg,
      args: [],
      stdio,
      banner: false,
      scriptShell: config.scriptShell
    }).then(
      ({ stdout }) => {
        if (stdout) {
          console.log(stdout.toString().trimEnd());
        }
        opts.log.silly("lifecycle", "%j finished in %j", stage, pkg.name);
      },
      (err) => {
        const exitCode = err.code || 1;
        import_npmlog25.default.error("lifecycle", "%j errored in %j, exiting %d", stage, pkg.name, exitCode);
        err.name = "ValidationError";
        err.exitCode = exitCode;
        process.exitCode = exitCode;
        throw err;
      }
    )
  );
}
function createRunner(commandOptions) {
  const cfg = npmConf(commandOptions).snapshot;
  return (pkg, stage) => runLifecycle(pkg, stage, cfg);
}
var import_npmlog25, import_p_queue, runScript, npmConf, queue;
var init_run_lifecycle = __esm({
  "libs/core/src/lib/run-lifecycle.ts"() {
    "use strict";
    import_npmlog25 = __toESM(require("npmlog"));
    import_p_queue = __toESM(require("p-queue"));
    runScript = require("@npmcli/run-script");
    npmConf = require_npm_conf();
    queue = new import_p_queue.default({ concurrency: 1 });
  }
});

// libs/core/src/lib/npm-publish.ts
var import_fs_extra5, import_libnpmpublish, import_npm_package_arg5, import_npmlog26, import_pify2, readJSON, readJSONAsync;
var init_npm_publish = __esm({
  "libs/core/src/lib/npm-publish.ts"() {
    "use strict";
    import_fs_extra5 = __toESM(require("fs-extra"));
    import_libnpmpublish = require("libnpmpublish");
    import_npm_package_arg5 = __toESM(require("npm-package-arg"));
    import_npmlog26 = __toESM(require("npmlog"));
    import_pify2 = __toESM(require("pify"));
    init_otplease();
    init_run_lifecycle();
    readJSON = require("read-package-json");
    readJSONAsync = (0, import_pify2.default)(readJSON);
  }
});

// libs/core/src/lib/npm-run-script.ts
var import_npmlog27, childProcess8;
var init_npm_run_script = __esm({
  "libs/core/src/lib/npm-run-script.ts"() {
    "use strict";
    import_npmlog27 = __toESM(require("npmlog"));
    init_get_npm_exec_opts();
    childProcess8 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/output.ts
var import_npmlog28;
var init_output = __esm({
  "libs/core/src/lib/output.ts"() {
    "use strict";
    import_npmlog28 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/temp-write.ts
async function tempWrite(fileContent, filePath) {
  const tempPath = tempfile(filePath);
  const write = (0, import_is_stream.default)(fileContent) ? writeStream : writeFileP;
  await (0, import_make_dir.default)(import_path12.default.dirname(tempPath));
  await write(tempPath, fileContent);
  return tempPath;
}
var import_graceful_fs, import_is_stream, import_make_dir, import_path12, import_temp_dir, import_util2, uuid, writeFileP, tempfile, writeStream;
var init_temp_write = __esm({
  "libs/core/src/lib/temp-write.ts"() {
    "use strict";
    import_graceful_fs = __toESM(require("graceful-fs"));
    import_is_stream = __toESM(require("is-stream"));
    import_make_dir = __toESM(require("make-dir"));
    import_path12 = __toESM(require("path"));
    import_temp_dir = __toESM(require("temp-dir"));
    import_util2 = require("util");
    uuid = __toESM(require("uuid"));
    writeFileP = (0, import_util2.promisify)(import_graceful_fs.default.writeFile);
    tempfile = (filePath) => import_path12.default.join(import_temp_dir.default, uuid.v4(), filePath || "");
    writeStream = async (filePath, fileContent) => new Promise((resolve, reject) => {
      const writable = import_graceful_fs.default.createWriteStream(filePath);
      fileContent.on("error", (error) => {
        reject(error);
        fileContent.unpipe(writable);
        writable.end();
      }).pipe(writable).on("error", reject).on("finish", resolve);
    });
    tempWrite.sync = (fileContent, filePath) => {
      const tempPath = tempfile(filePath);
      import_make_dir.default.sync(import_path12.default.dirname(tempPath));
      import_graceful_fs.default.writeFileSync(tempPath, fileContent);
      return tempPath;
    };
  }
});

// libs/core/src/lib/get-packed.ts
var import_fs_extra6, import_ssri, import_tar;
var init_get_packed = __esm({
  "libs/core/src/lib/get-packed.ts"() {
    "use strict";
    import_fs_extra6 = __toESM(require("fs-extra"));
    import_ssri = __toESM(require("ssri"));
    import_tar = __toESM(require("tar"));
  }
});

// libs/core/src/lib/pack-directory.ts
var import_npm_packlist, import_npmlog29, import_tar2;
var init_pack_directory = __esm({
  "libs/core/src/lib/pack-directory.ts"() {
    "use strict";
    import_npm_packlist = __toESM(require("npm-packlist"));
    import_npmlog29 = __toESM(require("npmlog"));
    import_tar2 = __toESM(require("tar"));
    init_temp_write();
    init_get_packed();
    init_package();
    init_run_lifecycle();
  }
});

// libs/core/src/lib/profiler.ts
var import_fs_extra7, import_npmlog30, import_upath;
var init_profiler = __esm({
  "libs/core/src/lib/profiler.ts"() {
    "use strict";
    import_fs_extra7 = __toESM(require("fs-extra"));
    import_npmlog30 = __toESM(require("npmlog"));
    import_upath = __toESM(require("upath"));
  }
});

// libs/core/src/lib/pulse-till-done.ts
function pulseStart(prefix) {
  pulsers += 1;
  if (pulsers > 1) {
    return;
  }
  pulse = setInterval(() => import_npmlog31.default["gauge"].pulse(prefix), 150);
}
function pulseStop() {
  pulsers -= 1;
  if (pulsers > 0) {
    return;
  }
  clearInterval(pulse);
}
function pulseTillDone(prefix, promise) {
  if (!promise) {
    promise = prefix;
    prefix = "";
  }
  pulseStart(prefix);
  return Promise.resolve(promise).then(
    (val) => {
      pulseStop();
      return val;
    },
    (err) => {
      pulseStop();
      throw err;
    }
  );
}
var import_npmlog31, pulsers, pulse;
var init_pulse_till_done = __esm({
  "libs/core/src/lib/pulse-till-done.ts"() {
    "use strict";
    import_npmlog31 = __toESM(require("npmlog"));
    pulsers = 0;
  }
});

// libs/core/src/lib/rimraf-dir.ts
function rimrafDir(dirPath) {
  import_npmlog32.default.silly("rimrafDir", dirPath);
  return (0, import_path_exists.default)(dirPath).then((exists) => {
    if (!exists) {
      return;
    }
    const slashed = import_path13.default.normalize(`${dirPath}/`);
    const args = [RIMRAF_CLI, "--no-glob", slashed];
    return childProcess9.spawn(process.execPath, args).then(() => {
      import_npmlog32.default.verbose("rimrafDir", "removed", dirPath);
      return dirPath;
    });
  });
}
var import_npmlog32, import_path13, import_path_exists, childProcess9, RIMRAF_CLI;
var init_rimraf_dir = __esm({
  "libs/core/src/lib/rimraf-dir.ts"() {
    "use strict";
    import_npmlog32 = __toESM(require("npmlog"));
    import_path13 = __toESM(require("path"));
    import_path_exists = __toESM(require("path-exists"));
    childProcess9 = require("@lerna/child-process");
    RIMRAF_CLI = require.resolve("rimraf/bin");
  }
});

// libs/core/src/lib/run-topologically.ts
function runTopologically(packages, runner, { concurrency, graphType, rejectCycles } = {}) {
  const queue2 = new import_p_queue2.default({ concurrency });
  const graph = new QueryGraph(packages, { graphType, rejectCycles });
  return new Promise((resolve, reject) => {
    const returnValues = [];
    const queueNextAvailablePackages = () => graph.getAvailablePackages().forEach(({ pkg, name }) => {
      graph.markAsTaken(name);
      queue2.add(
        () => runner(pkg).then((value) => returnValues.push(value)).then(() => graph.markAsDone(pkg)).then(() => queueNextAvailablePackages())
      ).catch(reject);
    });
    queueNextAvailablePackages();
    queue2.onIdle().then(() => resolve(returnValues));
  });
}
var import_p_queue2;
var init_run_topologically = __esm({
  "libs/core/src/lib/run-topologically.ts"() {
    "use strict";
    import_p_queue2 = __toESM(require("p-queue"));
    init_query_graph();
  }
});

// libs/core/src/lib/scm-clients/github/create-github-client.ts
var import_npmlog33, import_rest, import_git_url_parse, childProcess10;
var init_create_github_client = __esm({
  "libs/core/src/lib/scm-clients/github/create-github-client.ts"() {
    "use strict";
    import_npmlog33 = __toESM(require("npmlog"));
    import_rest = require("@octokit/rest");
    import_git_url_parse = __toESM(require("git-url-parse"));
    childProcess10 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/scm-clients/gitlab/gitlab-client.ts
var import_node_fetch, import_npmlog34;
var init_gitlab_client = __esm({
  "libs/core/src/lib/scm-clients/gitlab/gitlab-client.ts"() {
    "use strict";
    import_node_fetch = __toESM(require("node-fetch"));
    import_npmlog34 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/scm-clients/gitlab/create-gitlab-client.ts
var import_npmlog35;
var init_create_gitlab_client = __esm({
  "libs/core/src/lib/scm-clients/gitlab/create-gitlab-client.ts"() {
    "use strict";
    import_npmlog35 = __toESM(require("npmlog"));
    init_gitlab_client();
  }
});

// libs/core/src/lib/scm-clients/index.ts
var init_scm_clients = __esm({
  "libs/core/src/lib/scm-clients/index.ts"() {
    "use strict";
    init_create_github_client();
    init_create_gitlab_client();
  }
});

// libs/core/src/lib/symlink-binary/index.ts
function symlinkBinary(srcPackageRef, destPackageRef) {
  return Promise.all([Package.lazy(srcPackageRef), Package.lazy(destPackageRef)]).then(
    ([srcPackage, destPackage]) => {
      const actions = Object.keys(srcPackage.bin).map((name) => {
        const srcLocation = srcPackage.contents ? import_path14.default.resolve(srcPackage.location, srcPackage.contents) : srcPackage.location;
        const src = import_path14.default.join(srcLocation, srcPackage.bin[name]);
        const dst = import_path14.default.join(destPackage.binLocation, name);
        return { src, dst };
      });
      if (actions.length === 0) {
        return Promise.resolve();
      }
      return import_fs_extra8.default.mkdirp(destPackage.binLocation).then(
        () => (0, import_p_map3.default)(actions, (meta) => {
          if (meta) {
            return createSymlink(meta.src, meta.dst, "exec");
          }
        })
      );
    }
  );
}
var import_fs_extra8, import_p_map3, import_path14;
var init_symlink_binary = __esm({
  "libs/core/src/lib/symlink-binary/index.ts"() {
    "use strict";
    import_fs_extra8 = __toESM(require("fs-extra"));
    import_p_map3 = __toESM(require("p-map"));
    import_path14 = __toESM(require("path"));
    init_create_symlink();
    init_package();
  }
});

// libs/core/src/lib/resolve-symlink.ts
function resolveSymlink(filePath) {
  import_npmlog36.default.silly("resolveSymlink", filePath);
  let result;
  if (process.platform === "win32") {
    result = resolveWindowsSymlink(filePath);
  } else {
    result = resolvePosixSymlink(filePath);
  }
  import_npmlog36.default.verbose("resolveSymlink", [filePath, result]);
  return result;
}
function resolveSymbolicLink(filePath) {
  const lstat = import_fs_extra9.default.lstatSync(filePath);
  const resolvedPath = lstat.isSymbolicLink() ? import_path15.default.resolve(import_path15.default.dirname(filePath), import_fs_extra9.default.readlinkSync(filePath)) : false;
  return {
    resolvedPath,
    lstat
  };
}
function resolvePosixSymlink(filePath) {
  return resolveSymbolicLink(filePath).resolvedPath;
}
function resolveWindowsSymlink(filePath) {
  const { resolvedPath, lstat } = resolveSymbolicLink(filePath);
  if (lstat.isFile() && !resolvedPath) {
    try {
      return import_path15.default.resolve(import_path15.default.dirname(filePath), readCmdShim.sync(filePath));
    } catch (e) {
      return false;
    }
  }
  return resolvedPath && import_path15.default.resolve(resolvedPath);
}
var import_fs_extra9, import_npmlog36, import_path15, readCmdShim;
var init_resolve_symlink = __esm({
  "libs/core/src/lib/resolve-symlink.ts"() {
    "use strict";
    import_fs_extra9 = __toESM(require("fs-extra"));
    import_npmlog36 = __toESM(require("npmlog"));
    import_path15 = __toESM(require("path"));
    readCmdShim = require("read-cmd-shim");
  }
});

// libs/core/src/lib/symlink-dependencies.ts
function symlinkDependencies(packages, packageGraph, tracker) {
  tracker.info("", "Symlinking packages and binaries");
  tracker.addWork(packages.length);
  const nodes = packageGraph.size === packages.length ? packageGraph.values() : new Set(packages.map(({ name }) => packageGraph.get(name)));
  return (0, import_p_map_series.default)(nodes, (currentNode) => {
    const currentName = currentNode.name;
    const currentNodeModules = currentNode.pkg.nodeModulesLocation;
    return (0, import_p_map4.default)(currentNode.localDependencies, ([dependencyName, resolved]) => {
      if (resolved.type === "directory") {
        return;
      }
      const dependencyNode = packageGraph.get(dependencyName);
      const targetDirectory = import_path16.default.join(currentNodeModules, dependencyName);
      let chain = Promise.resolve();
      chain = chain.then(() => import_fs_extra10.default.pathExists(targetDirectory));
      chain = chain.then((dirExists) => {
        if (dirExists) {
          const isDepSymlink = resolveSymlink(targetDirectory);
          if (isDepSymlink !== false && isDepSymlink !== dependencyNode.location) {
            tracker.warn(
              "EREPLACE_OTHER",
              `Symlink already exists for ${dependencyName} dependency of ${currentName}, but links to different location. Replacing with updated symlink...`
            );
          } else if (isDepSymlink === false) {
            tracker.warn(
              "EREPLACE_EXIST",
              `${dependencyName} is already installed for ${currentName}. Replacing with symlink...`
            );
            return import_fs_extra10.default.remove(targetDirectory);
          }
        } else {
          return import_fs_extra10.default.ensureDir(import_path16.default.dirname(targetDirectory));
        }
      });
      const dependencyLocation = dependencyNode.pkg.contents ? import_path16.default.resolve(dependencyNode.location, dependencyNode.pkg.contents) : dependencyNode.location;
      chain = chain.then(() => createSymlink(dependencyLocation, targetDirectory, "junction"));
      chain = chain.then(() => symlinkBinary(dependencyNode.pkg, currentNode.pkg));
      return chain;
    }).then(() => {
      tracker.silly("actions", "finished", currentName);
      tracker.completeWork(1);
    });
  }).finally(() => tracker.finish());
}
var import_fs_extra10, import_p_map4, import_p_map_series, import_path16;
var init_symlink_dependencies = __esm({
  "libs/core/src/lib/symlink-dependencies.ts"() {
    "use strict";
    import_fs_extra10 = __toESM(require("fs-extra"));
    import_p_map4 = __toESM(require("p-map"));
    import_p_map_series = __toESM(require("p-map-series"));
    import_path16 = __toESM(require("path"));
    init_create_symlink();
    init_resolve_symlink();
    init_symlink_binary();
  }
});

// libs/core/src/lib/timer.ts
var init_timer = __esm({
  "libs/core/src/lib/timer.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/npm-dist-tag.ts
var npm_dist_tag_exports = {};
__export(npm_dist_tag_exports, {
  add: () => add,
  list: () => list,
  remove: () => remove
});
function add(spec, tag, options, otpCache) {
  const opts = {
    log: import_npmlog37.default,
    ...options,
    spec: (0, import_npm_package_arg6.default)(spec)
  };
  const cleanTag = (tag || opts.defaultTag || opts.tag).trim();
  const { name, rawSpec: version } = opts.spec;
  opts.log.verbose("dist-tag", `adding "${cleanTag}" to ${name}@${version}`);
  if (opts.dryRun) {
    opts.log.silly("dist-tag", "dry-run configured, bailing now");
    return Promise.resolve();
  }
  return fetchTags(opts).then((tags) => {
    if (tags[cleanTag] === version) {
      opts.log.warn("dist-tag", `${name}@${cleanTag} already set to ${version}`);
      return tags;
    }
    const uri = `/-/package/${opts.spec.escapedName}/dist-tags/${encodeURIComponent(cleanTag)}`;
    const payload = {
      ...opts,
      method: "PUT",
      body: JSON.stringify(version),
      headers: {
        "content-type": "application/json"
      },
      spec: opts.spec
    };
    return otplease((wrappedPayload) => (0, import_npm_registry_fetch.default)(uri, wrappedPayload), payload, otpCache).then(() => {
      opts.log.verbose("dist-tag", `added "${cleanTag}" to ${name}@${version}`);
      tags[cleanTag] = version;
      return tags;
    });
  });
}
function remove(spec, tag, options, otpCache) {
  const opts = {
    log: import_npmlog37.default,
    ...options,
    spec: (0, import_npm_package_arg6.default)(spec)
  };
  opts.log.verbose("dist-tag", `removing "${tag}" from ${opts.spec.name}`);
  if (opts.dryRun) {
    opts.log.silly("dist-tag", "dry-run configured, bailing now");
    return Promise.resolve();
  }
  return fetchTags(opts).then((tags) => {
    const version = tags[tag];
    if (!version) {
      opts.log.info("dist-tag", `"${tag}" is not a dist-tag on ${opts.spec.name}`);
      return tags;
    }
    const uri = `/-/package/${opts.spec.escapedName}/dist-tags/${encodeURIComponent(tag)}`;
    const payload = {
      ...opts,
      method: "DELETE",
      spec: opts.spec
    };
    return otplease((wrappedPayload) => (0, import_npm_registry_fetch.default)(uri, wrappedPayload), payload, otpCache).then(() => {
      opts.log.verbose("dist-tag", `removed "${tag}" from ${opts.spec.name}@${version}`);
      delete tags[tag];
      return tags;
    });
  });
}
function list(spec, options) {
  const opts = {
    log: import_npmlog37.default,
    ...options,
    spec: (0, import_npm_package_arg6.default)(spec)
  };
  if (opts.dryRun) {
    opts.log.silly("dist-tag", "dry-run configured, bailing now");
    return Promise.resolve();
  }
  return fetchTags(opts);
}
function fetchTags(opts) {
  return import_npm_registry_fetch.default.json(`/-/package/${opts.spec.escapedName}/dist-tags`, {
    ...opts,
    preferOnline: true,
    spec: opts.spec
  }).then((data) => {
    if (data && typeof data === "object") {
      delete data["_etag"];
    }
    return data || {};
  });
}
var import_npm_package_arg6, import_npm_registry_fetch, import_npmlog37;
var init_npm_dist_tag = __esm({
  "libs/core/src/lib/npm-dist-tag.ts"() {
    "use strict";
    import_npm_package_arg6 = __toESM(require("npm-package-arg"));
    import_npm_registry_fetch = __toESM(require("npm-registry-fetch"));
    import_npmlog37 = __toESM(require("npmlog"));
    init_otplease();
  }
});

// libs/core/src/index.ts
var npmConf2, npmDistTag;
var init_src = __esm({
  "libs/core/src/index.ts"() {
    "use strict";
    init_check_working_tree();
    init_cli();
    init_collect_updates();
    init_command();
    init_conventional_commits();
    init_create_symlink();
    init_describe_ref();
    init_filter_options();
    init_has_npm_version();
    init_listable_format();
    init_listable_options();
    init_log_packed();
    init_npm_install();
    init_npm_publish();
    init_npm_run_script();
    init_otplease();
    init_output();
    init_pack_directory();
    init_package();
    init_package_graph();
    init_prerelease_id_from_version();
    init_profiler();
    init_project();
    init_prompt();
    init_pulse_till_done();
    init_rimraf_dir();
    init_run_lifecycle();
    init_run_topologically();
    init_scm_clients();
    init_symlink_binary();
    init_symlink_dependencies();
    init_temp_write();
    init_timer();
    init_validation_error();
    npmConf2 = require_npm_conf();
    npmDistTag = (init_npm_dist_tag(), __toCommonJS(npm_dist_tag_exports));
  }
});

// libs/commands/bootstrap/src/lib/has-dependency-installed.ts
var require_has_dependency_installed = __commonJS({
  "libs/commands/bootstrap/src/lib/has-dependency-installed.ts"(exports2, module2) {
    "use strict";
    var import_npmlog38 = __toESM(require("npmlog"));
    var import_arborist = __toESM(require("@npmcli/arborist"));
    var import_semver5 = __toESM(require("semver"));
    var cache = /* @__PURE__ */ new Map();
    module2.exports.hasDependencyInstalled = hasDependencyInstalled;
    function hasDependencyInstalled(pkg, depName, needVersion) {
      import_npmlog38.default.silly("hasDependencyInstalled", pkg.name, depName);
      return getInstalled(pkg).then(
        (versions) => versions.has(depName) && import_semver5.default.satisfies(versions.get(depName), needVersion)
      );
    }
    function getInstalled(pkg) {
      if (cache.has(pkg)) {
        return Promise.resolve(cache.get(pkg));
      }
      const arb = new import_arborist.default({
        path: pkg.location
      });
      return arb.loadActual().then((tree) => {
        const deps = /* @__PURE__ */ new Map();
        for (const [dependencyName, node] of tree.children.entries()) {
          deps.set(dependencyName, node.version);
        }
        cache.set(pkg, deps);
        return deps;
      });
    }
  }
});

// libs/commands/bootstrap/src/lib/is-hoisted-package.ts
var require_is_hoisted_package = __commonJS({
  "libs/commands/bootstrap/src/lib/is-hoisted-package.ts"(exports2, module2) {
    "use strict";
    var import_multimatch2 = __toESM(require("multimatch"));
    module2.exports.isHoistedPackage = isHoistedPackage;
    function isHoistedPackage(name, hoisting) {
      return (0, import_multimatch2.default)([name], hoisting).length > 0;
    }
  }
});

// libs/commands/bootstrap/src/index.ts
var require_src = __commonJS({
  "libs/commands/bootstrap/src/index.ts"(exports2, module2) {
    "use strict";
    init_src();
    var import_dedent5 = __toESM(require("dedent"));
    var import_get_port = __toESM(require("get-port"));
    var import_npm_package_arg7 = __toESM(require("npm-package-arg"));
    var import_p_map5 = __toESM(require("p-map"));
    var import_p_map_series2 = __toESM(require("p-map-series"));
    var import_p_waterfall = __toESM(require("p-waterfall"));
    var import_path17 = __toESM(require("path"));
    var { hasDependencyInstalled } = require_has_dependency_installed();
    var { isHoistedPackage } = require_is_hoisted_package();
    module2.exports = function factory(argv) {
      return new BootstrapCommand(argv);
    };
    var BootstrapCommand = class extends Command {
      get requiresGit() {
        return false;
      }
      initialize() {
        const { registry, npmClient = "npm", npmClientArgs = [], mutex, hoist, nohoist } = this.options;
        if (npmClient === "pnpm") {
          throw new ValidationError(
            "EWORKSPACES",
            "Bootstrapping with pnpm is not supported. Use pnpm directly to manage dependencies: https://pnpm.io/cli/install"
          );
        }
        if (npmClient === "yarn" && hoist) {
          throw new ValidationError(
            "EWORKSPACES",
            import_dedent5.default`
            --hoist is not supported with --npm-client=yarn, use yarn workspaces instead
            A guide is available at https://yarnpkg.com/blog/2017/08/02/introducing-workspaces/
          `
          );
        }
        if (npmClient === "yarn" && this.project.manifest.get("workspaces") && this.options.useWorkspaces !== true) {
          throw new ValidationError(
            "EWORKSPACES",
            import_dedent5.default`
            Yarn workspaces are configured in package.json, but not enabled in lerna.json!
            Please choose one: useWorkspaces = true in lerna.json, or remove package.json workspaces config
          `
          );
        }
        const { LERNA_EXEC_PATH = "leaf", LERNA_ROOT_PATH = "root" } = process.env;
        if (LERNA_EXEC_PATH === LERNA_ROOT_PATH) {
          this.logger.warn("bootstrap", "Skipping recursive execution");
          return false;
        }
        if (hoist) {
          let hoisting;
          if (hoist === true) {
            hoisting = ["**"];
          } else {
            hoisting = [].concat(hoist);
          }
          if (nohoist) {
            if (!Array.isArray(nohoist)) {
              hoisting = hoisting.concat(`!${nohoist}`);
            } else {
              hoisting = hoisting.concat(nohoist.map((str) => `!${str}`));
            }
          }
          this.logger.verbose("hoist", "using globs %j", hoisting);
          this.hoisting = hoisting;
        }
        this.runPackageLifecycle = createRunner({ registry });
        this.npmConfig = {
          registry,
          npmClient,
          npmClientArgs,
          mutex
        };
        if (npmClient === "npm" && this.options.ci && hasNpmVersion(">=5.7.0")) {
          this.npmConfig.subCommand = this.hoisting ? "install" : "ci";
          if (this.hoisting) {
            this.npmConfig.npmClientArgs.unshift("--no-save");
          }
        }
        const doubleDashArgs = this.options["--"] || [];
        if (doubleDashArgs.length) {
          this.npmConfig.npmClientArgs = [...npmClientArgs, ...doubleDashArgs];
        }
        if (this.options.ignoreScripts) {
          this.npmConfig.npmClientArgs.unshift("--ignore-scripts");
        }
        this.targetGraph = this.options.forceLocal ? new PackageGraph(this.packageGraph.rawPackageList, "allDependencies", "forceLocal") : this.packageGraph;
        let chain = Promise.resolve();
        chain = chain.then(() => {
          return getFilteredPackages(this.targetGraph, this.execOpts, this.options);
        });
        chain = chain.then((filteredPackages) => {
          this.filteredPackages = filteredPackages;
          if (this.options.contents) {
            for (const pkg of filteredPackages) {
              pkg.contents = this.options.contents;
            }
          }
          if (filteredPackages.length !== this.targetGraph.size && !this.options.forceLocal) {
            this.logger.warn("bootstrap", "Installing local packages that do not match filters from registry");
            this.targetGraph = new PackageGraph(filteredPackages, "allDependencies", this.options.forceLocal);
            this.npmConfig.npmClientArgs.unshift(npmClient === "yarn" ? "--pure-lockfile" : "--no-save");
            if (this.npmConfig.subCommand === "ci") {
              this.npmConfig.subCommand = "install";
            }
          }
        });
        chain = chain.then(() => {
          if (npmClient === "yarn" && !mutex) {
            return (0, import_get_port.default)({ port: 42424, host: "0.0.0.0" }).then((port) => {
              this.npmConfig.mutex = `network:${port}`;
              this.logger.silly("npmConfig", this.npmConfig);
            });
          }
          this.logger.silly("npmConfig", this.npmConfig);
        });
        return chain;
      }
      execute() {
        if (this.options.useWorkspaces || this.rootHasLocalFileDependencies()) {
          if (this.options.rejectCycles) {
            this.packageGraph.collapseCycles({ rejectCycles: this.options.rejectCycles });
          }
          return this.installRootPackageOnly();
        }
        const filteredLength = this.filteredPackages.length;
        const packageCountLabel = `${filteredLength} package${filteredLength > 1 ? "s" : ""}`;
        const scriptsEnabled = this.options.ignoreScripts !== true;
        this.enableProgressBar();
        this.logger.info("", `Bootstrapping ${packageCountLabel}`);
        const tasks = [];
        if (scriptsEnabled) {
          tasks.push(() => this.runLifecycleInPackages("preinstall"));
        }
        tasks.push(
          () => this.getDependenciesToInstall(),
          (result) => this.installExternalDependencies(result),
          () => this.symlinkPackages()
        );
        if (scriptsEnabled) {
          tasks.push(
            () => this.runLifecycleInPackages("install"),
            () => this.runLifecycleInPackages("postinstall")
          );
          if (!this.options.ignorePrepublish) {
            tasks.push(() => this.runLifecycleInPackages("prepublish"));
          }
          tasks.push(() => this.runLifecycleInPackages("prepare"));
        }
        return (0, import_p_waterfall.default)(tasks).then(() => {
          this.logger.success("", `Bootstrapped ${packageCountLabel}`);
        });
      }
      installRootPackageOnly() {
        this.logger.info("bootstrap", "root only");
        this.npmConfig.stdio = "inherit";
        return npmInstall(this.project.manifest, this.npmConfig);
      }
      rootHasLocalFileDependencies() {
        const rootDependencies = Object.assign({}, this.project.manifest.dependencies);
        return Object.keys(rootDependencies).some(
          (name) => this.targetGraph.has(name) && import_npm_package_arg7.default.resolve(name, rootDependencies[name], this.project.rootPath).type === "directory"
        );
      }
      runLifecycleInPackages(stage) {
        this.logger.verbose("lifecycle", stage);
        if (!this.filteredPackages.length) {
          return;
        }
        const tracker = this.logger.newItem(stage);
        const mapPackageWithScript = (pkg) => this.runPackageLifecycle(pkg, stage).then(() => {
          tracker.completeWork(1);
        });
        tracker.addWork(this.filteredPackages.length);
        const runner = this.toposort ? runTopologically(this.filteredPackages, mapPackageWithScript, {
          concurrency: this.concurrency,
          rejectCycles: this.options.rejectCycles
        }) : (0, import_p_map5.default)(this.filteredPackages, mapPackageWithScript, { concurrency: this.concurrency });
        return runner.finally(() => tracker.finish());
      }
      hoistedDirectory(dependency) {
        return import_path17.default.join(this.project.rootPath, "node_modules", dependency);
      }
      hoistedPackageJson(dependency) {
        try {
          return require(import_path17.default.join(this.hoistedDirectory(dependency), "package.json"));
        } catch (e) {
          return {};
        }
      }
      getDependenciesToInstall() {
        const rootPkg = this.project.manifest;
        const rootSet = /* @__PURE__ */ new Set();
        const leaves = /* @__PURE__ */ new Map();
        const depsToInstall = /* @__PURE__ */ new Map();
        const filteredNodes = new Map(
          this.filteredPackages.map((pkg) => [pkg.name, this.targetGraph.get(pkg.name)])
        );
        const mergedRootDeps = Object.assign(
          {},
          rootPkg.devDependencies,
          rootPkg.optionalDependencies,
          rootPkg.dependencies
        );
        const rootExternalVersions = new Map(
          Object.keys(mergedRootDeps).map((externalName) => [externalName, mergedRootDeps[externalName]])
        );
        rootExternalVersions.forEach((version, externalName) => {
          const externalDependents = /* @__PURE__ */ new Set();
          const record = /* @__PURE__ */ new Map();
          record.set(version, externalDependents);
          depsToInstall.set(externalName, record);
        });
        for (const [leafName, leafNode] of filteredNodes) {
          for (const [externalName, resolved] of leafNode.externalDependencies) {
            const version = resolved.rawSpec;
            const record = depsToInstall.get(externalName) || depsToInstall.set(externalName, /* @__PURE__ */ new Map()).get(externalName);
            const externalDependents = record.get(version) || record.set(version, /* @__PURE__ */ new Set()).get(version);
            externalDependents.add(leafName);
          }
        }
        const rootActions = [];
        const leafActions = [];
        let strictExitOnWarning = false;
        for (const [externalName, externalDependents] of depsToInstall) {
          let rootVersion;
          if (this.hoisting && isHoistedPackage(externalName, this.hoisting)) {
            const commonVersion = Array.from(externalDependents.keys()).reduce(
              (a, b) => externalDependents.get(a).size > externalDependents.get(b).size ? a : b
            );
            rootVersion = rootExternalVersions.get(externalName) || commonVersion;
            if (rootVersion !== commonVersion) {
              this.logger.warn(
                "EHOIST_ROOT_VERSION",
                `The repository root depends on ${externalName}@${rootVersion}, which differs from the more common ${externalName}@${commonVersion}.`
              );
              if (this.options.strict) {
                strictExitOnWarning = true;
              }
            }
            const dependents = Array.from(externalDependents.get(rootVersion)).map(
              (leafName) => this.targetGraph.get(leafName).pkg
            );
            externalDependents.delete(rootVersion);
            rootActions.push(
              () => hasDependencyInstalled(rootPkg, externalName, rootVersion).then((isSatisfied) => {
                rootSet.add({
                  name: externalName,
                  dependents,
                  dependency: `${externalName}@${rootVersion}`,
                  isSatisfied
                });
              })
            );
          }
          for (const [leafVersion, leafDependents] of externalDependents) {
            for (const leafName of leafDependents) {
              if (rootVersion) {
                this.logger.warn(
                  "EHOIST_PKG_VERSION",
                  `"${leafName}" package depends on ${externalName}@${leafVersion}, which differs from the hoisted ${externalName}@${rootVersion}.`
                );
                if (this.options.strict) {
                  strictExitOnWarning = true;
                }
              }
              const leafNode = this.targetGraph.get(leafName);
              const leafRecord = leaves.get(leafNode) || leaves.set(leafNode, /* @__PURE__ */ new Set()).get(leafNode);
              leafActions.push(
                () => hasDependencyInstalled(leafNode.pkg, externalName, leafVersion).then((isSatisfied) => {
                  leafRecord.add({
                    dependency: `${externalName}@${leafVersion}`,
                    isSatisfied
                  });
                })
              );
            }
          }
        }
        if (this.options.strict && strictExitOnWarning) {
          throw new ValidationError(
            "EHOISTSTRICT",
            "Package version inconsistencies found while hoisting. Fix the above warnings and retry."
          );
        }
        return (0, import_p_map_series2.default)([...rootActions, ...leafActions], (el) => el()).then(() => {
          this.logger.silly("root dependencies", JSON.stringify(rootSet, null, 2));
          this.logger.silly("leaf dependencies", JSON.stringify(leaves, null, 2));
          return { rootSet, leaves };
        });
      }
      installExternalDependencies({ leaves, rootSet }) {
        const tracker = this.logger.newItem("install dependencies");
        const rootPkg = this.project.manifest;
        const actions = [];
        if (rootSet.size) {
          const root = Array.from(rootSet);
          actions.push(() => {
            const depsToInstallInRoot = root.some(({ isSatisfied }) => !isSatisfied) ? root.map(({ dependency }) => dependency) : [];
            if (depsToInstallInRoot.length) {
              tracker.info("hoist", "Installing hoisted dependencies into root");
            }
            const promise = npmInstallDependencies(rootPkg, depsToInstallInRoot, this.npmConfig);
            return pulseTillDone(promise).then(
              () => (0, import_p_map_series2.default)(root, ({ name, dependents }) => {
                const { bin } = this.hoistedPackageJson(name);
                if (bin) {
                  return (0, import_p_map5.default)(dependents, (pkg) => {
                    const src = this.hoistedDirectory(name);
                    return symlinkBinary(src, pkg);
                  });
                }
              })
            ).then(() => {
              tracker.info("hoist", "Finished bootstrapping root");
              tracker.completeWork(1);
            });
          });
          actions.push(() => {
            const candidates = root.filter((dep) => dep.dependents.length).reduce((list2, { name, dependents }) => {
              const dirs = dependents.filter((pkg) => pkg.nodeModulesLocation !== rootPkg.nodeModulesLocation).map((pkg) => import_path17.default.join(pkg.nodeModulesLocation, name));
              return list2.concat(dirs);
            }, []);
            if (!candidates.length) {
              tracker.verbose("hoist", "nothing to prune");
              tracker.completeWork(1);
              return;
            }
            tracker.info("hoist", "Pruning hoisted dependencies");
            tracker.silly("prune", candidates);
            tracker.addWork(candidates.length);
            return (0, import_p_map5.default)(
              candidates,
              (dirPath) => pulseTillDone(rimrafDir(dirPath)).then(() => {
                tracker.verbose("prune", dirPath);
                tracker.completeWork(1);
              }),
              { concurrency: this.concurrency }
            ).then(() => {
              tracker.info("hoist", "Finished pruning hoisted dependencies");
              tracker.completeWork(1);
            });
          });
        }
        const leafNpmConfig = Object.assign({}, this.npmConfig, {
          npmGlobalStyle: !!this.options.hoist
        });
        leaves.forEach((leafRecord, leafNode) => {
          const deps = Array.from(leafRecord);
          if (deps.some(({ isSatisfied }) => !isSatisfied)) {
            actions.push(() => {
              const dependencies = deps.map(({ dependency }) => dependency);
              const promise = npmInstallDependencies(leafNode.pkg, dependencies, leafNpmConfig);
              return pulseTillDone(promise).then(() => {
                tracker.verbose("installed leaf", leafNode.name);
                tracker.completeWork(1);
              });
            });
          }
        });
        if (actions.length) {
          tracker.info("", "Installing external dependencies");
          tracker.verbose("actions", "%d actions, concurrency %d", actions.length, this.concurrency);
          tracker.addWork(actions.length);
        }
        return (0, import_p_map5.default)(actions, (act) => act(), { concurrency: this.concurrency }).finally(() => tracker.finish());
      }
      symlinkPackages() {
        return symlinkDependencies(
          this.filteredPackages,
          this.targetGraph,
          this.logger.newItem("bootstrap dependencies")
        );
      }
    };
    module2.exports.BootstrapCommand = BootstrapCommand;
  }
});

// libs/commands/add/src/lib/get-range-to-reference.ts
var require_get_range_to_reference = __commonJS({
  "libs/commands/add/src/lib/get-range-to-reference.ts"(exports2, module2) {
    "use strict";
    var import_npm_package_arg7 = __toESM(require("npm-package-arg"));
    var import_path17 = __toESM(require("path"));
    var import_semver5 = __toESM(require("semver"));
    module2.exports.getRangeToReference = getRangeToReference;
    function getRangeToReference(spec, deps, loc, prefix) {
      const current = deps[spec.name];
      const resolved = spec.type === "tag" ? `${prefix}${spec.version}` : spec.fetchSpec;
      if (spec.saveRelativeFileSpec) {
        return import_npm_package_arg7.default.resolve(spec.name, import_path17.default.relative(loc, spec.version), loc).saveSpec;
      }
      if (prefix && current && import_semver5.default.intersects(current, resolved)) {
        return current;
      }
      return resolved;
    }
  }
});

// libs/commands/add/src/index.ts
var require_src2 = __commonJS({
  "libs/commands/add/src/index.ts"(exports2, module2) {
    "use strict";
    init_src();
    var import_dedent5 = __toESM(require("dedent"));
    var import_npm_package_arg7 = __toESM(require("npm-package-arg"));
    var import_p_map5 = __toESM(require("p-map"));
    var import_pacote = __toESM(require("pacote"));
    var import_path17 = __toESM(require("path"));
    var import_semver5 = __toESM(require("semver"));
    var bootstrap = require_src();
    var { getRangeToReference } = require_get_range_to_reference();
    module2.exports = function factory(argv) {
      return new AddCommand(argv);
    };
    var AddCommand = class extends Command {
      get requiresGit() {
        return false;
      }
      get dependencyType() {
        if (this.options.dev) {
          return "devDependencies";
        }
        if (this.options.peer) {
          return "peerDependencies";
        }
        return "dependencies";
      }
      initialize() {
        if (this.options.npmClient === "pnpm") {
          throw new ValidationError(
            "EPNPMNOTSUPPORTED",
            "Add is not supported when using `pnpm` workspaces. Use `pnpm` directly to add dependencies to packages: https://pnpm.io/cli/add"
          );
        }
        this.spec = (0, import_npm_package_arg7.default)(this.options.pkg);
        this.dirs = new Set(this.options.globs.map((fp) => import_path17.default.resolve(this.project.rootPath, fp)));
        this.selfSatisfied = this.packageSatisfied();
        this.savePrefix = this.options.exact ? "" : "^";
        if (this.packageGraph.has(this.spec.name) && !this.selfSatisfied) {
          const available = this.packageGraph.get(this.spec.name).version;
          throw new ValidationError(
            "ENOTSATISFIED",
            import_dedent5.default`
          Requested range not satisfiable:
          ${this.spec.name}@${this.spec.fetchSpec} (available: ${available})
        `
          );
        }
        let chain = Promise.resolve();
        chain = chain.then(() => this.getPackageVersion());
        chain = chain.then((version) => {
          if (version == null) {
            throw new ValidationError(
              "ENOTSATISFIED",
              import_dedent5.default`
            Requested package has no version: ${this.spec.name}
          `
            );
          }
          this.spec.version = version;
        });
        chain = chain.then(() => getFilteredPackages(this.packageGraph, this.execOpts, this.options));
        chain = chain.then((filteredPackages) => {
          this.filteredPackages = filteredPackages;
        });
        chain = chain.then(() => this.collectPackagesToChange());
        chain = chain.then((packagesToChange) => {
          this.packagesToChange = packagesToChange;
        });
        return chain.then(() => {
          const proceed = this.packagesToChange.length > 0;
          if (!proceed) {
            this.logger.warn(`No packages found where ${this.spec.name} can be added.`);
          }
          return proceed;
        });
      }
      execute() {
        const numberOfPackages = `${this.packagesToChange.length} package${this.packagesToChange.length > 1 ? "s" : ""}`;
        this.logger.info("", `Adding ${this.spec.name} in ${numberOfPackages}`);
        let chain = Promise.resolve();
        chain = chain.then(() => this.makeChanges());
        if (this.options.bootstrap !== false) {
          chain = chain.then(() => {
            const argv = Object.assign({}, this.options, {
              args: [],
              cwd: this.project.rootPath,
              composed: "add",
              scope: void 0,
              ignore: void 0,
              private: void 0,
              since: void 0,
              excludeDependents: void 0,
              includeDependents: void 0,
              includeDependencies: void 0
            });
            return bootstrap(argv);
          });
        }
        return chain;
      }
      collectPackagesToChange() {
        const { name: targetName } = this.spec;
        let result = this.filteredPackages;
        if (this.packageGraph.has(targetName)) {
          result = result.filter((pkg) => pkg.name !== targetName);
        }
        if (this.dirs.size) {
          result = result.filter((pkg) => this.dirs.has(pkg.location));
        }
        result = result.filter((pkg) => {
          const deps = this.getPackageDeps(pkg);
          if (!(targetName in deps)) {
            return true;
          }
          return getRangeToReference(this.spec, deps, pkg.location, this.savePrefix) !== deps[targetName];
        });
        return result;
      }
      makeChanges() {
        const { name: targetName } = this.spec;
        return (0, import_p_map5.default)(this.packagesToChange, (pkg) => {
          const deps = this.getPackageDeps(pkg);
          const range = getRangeToReference(this.spec, deps, pkg.location, this.savePrefix);
          this.logger.verbose("add", `${targetName}@${range} to ${this.dependencyType} in ${pkg.name}`);
          deps[targetName] = range;
          return pkg.serialize();
        });
      }
      getPackageDeps(pkg) {
        let deps = pkg.get(this.dependencyType);
        if (!deps) {
          deps = {};
          pkg.set(this.dependencyType, deps);
        }
        return deps;
      }
      getPackageVersion() {
        if (this.selfSatisfied) {
          const node = this.packageGraph.get(this.spec.name);
          return Promise.resolve(this.spec.saveRelativeFileSpec ? node.location : node.version);
        }
        const opts = npmConf2({
          includeDeprecated: false,
          registry: this.options.registry
        });
        return import_pacote.default.manifest(this.spec, opts.snapshot).then((pkg) => pkg.version);
      }
      packageSatisfied() {
        const { name, fetchSpec } = this.spec;
        const pkg = this.packageGraph.get(name);
        if (!pkg) {
          return false;
        }
        if (this.spec.type === "directory" && fetchSpec === pkg.location) {
          this.spec.saveRelativeFileSpec = true;
          return true;
        }
        this.spec.saveRelativeFileSpec = Array.from(this.packageGraph.values()).some(
          (node) => node.localDependencies.size && Array.from(node.localDependencies.values()).some((resolved) => resolved.type === "directory")
        );
        if (fetchSpec === "latest") {
          return true;
        }
        return import_semver5.default.intersects(pkg.version, fetchSpec);
      }
    };
    module2.exports.AddCommand = AddCommand;
  }
});

// libs/commands/add/src/command.ts
var require_command = __commonJS({
  "libs/commands/add/src/command.ts"(exports2, module2) {
    "use strict";
    init_src();
    var command = {
      command: "add <pkg> [globs..]",
      describe: "Add a single dependency to matched packages",
      builder(yargs2) {
        yargs2.positional("pkg", {
          describe: "Package name to add as a dependency",
          type: "string"
        }).positional("globs", {
          describe: "Optional package directory globs to match",
          type: "array"
        }).options({
          D: {
            group: "Command Options:",
            type: "boolean",
            alias: "dev",
            describe: "Save to devDependencies"
          },
          E: {
            group: "Command Options:",
            type: "boolean",
            alias: "exact",
            describe: "Save version exactly"
          },
          P: {
            group: "Command Options:",
            type: "boolean",
            alias: "peer",
            describe: "Save to peerDependencies"
          },
          registry: {
            group: "Command Options:",
            describe: "Use the specified registry for all npm client operations.",
            type: "string",
            requiresArg: true
          },
          "no-bootstrap": {
            group: "Command Options:",
            describe: "Do not automatically chain `lerna bootstrap` after changes are made.",
            type: "boolean"
          },
          bootstrap: {
            hidden: true,
            type: "boolean"
          }
        }).example(
          "$0 add module-1 packages/prefix-*",
          "Adds the module-1 package to the packages in the 'prefix-' prefixed folders"
        ).example("$0 add module-1 --scope=module-2", "Install module-1 to module-2").example("$0 add module-1 --scope=module-2 --dev", "Install module-1 to module-2 in devDependencies").example("$0 add module-1 --scope=module-2 --peer", "Install module-1 to module-2 in peerDependencies").example("$0 add module-1", "Install module-1 in all modules except module-1").example("$0 add module-1 --no-bootstrap", "Skip automatic `lerna bootstrap`").example("$0 add babel-core", "Install babel-core in all modules");
        return filterOptions(yargs2);
      },
      handler(argv) {
        return require_src2()(argv);
      }
    };
    module2.exports = command;
  }
});

// packages/lerna/src/commands/add/command.ts
module.exports = require_command();
