"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateHeight = calculateHeight;
exports.calculateWidth = calculateWidth;
exports.getOffsetToBody = getOffsetToBody;
exports.getOffsetHeightToBody = getOffsetHeightToBody;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _logger = _interopRequireDefault(require("./logger"));

function getComputedStyle(prop) {
  var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.body;
  var result = null;

  if ('getComputedStyle' in window) {
    result = window.getComputedStyle(el, null);
  } else {
    result = document.defaultView.getComputedStyle(el, null);
  }

  return result !== null ? parseInt(result[prop], 10) : 0;
}

function getAllMeasures(dimension) {
  return [dimension.bodyOffset(), dimension.bodyScroll(), dimension.documentElementOffset(), dimension.documentElementScroll()];
}

var getHeight = {
  bodyOffset: function bodyOffset() {
    return document.body.offsetHeight + getComputedStyle('marginTop') + getComputedStyle('marginBottom');
  },
  bodyScroll: function bodyScroll() {
    return document.body.scrollHeight;
  },
  documentElementOffset: function documentElementOffset() {
    return document.documentElement.offsetHeight;
  },
  documentElementScroll: function documentElementScroll() {
    return document.documentElement.scrollHeight;
  },
  max: function max() {
    return Math.max.apply(Math, (0, _toConsumableArray2.default)(getAllMeasures(getHeight)));
  },
  min: function min() {
    return Math.min.apply(Math, (0, _toConsumableArray2.default)(getAllMeasures(getHeight)));
  }
};
var getWidth = {
  bodyOffset: function bodyOffset() {
    return document.body.offsetWidth;
  },
  bodyScroll: function bodyScroll() {
    return document.body.scrollWidth;
  },
  documentElementOffset: function documentElementOffset() {
    return document.documentElement.offsetWidth;
  },
  documentElementScroll: function documentElementScroll() {
    return document.documentElement.scrollWidth;
  },
  scroll: function scroll() {
    return Math.max(getWidth.bodyScroll(), getWidth.documentElementScroll());
  },
  max: function max() {
    return Math.max.apply(Math, (0, _toConsumableArray2.default)(getAllMeasures(getWidth)));
  },
  min: function min() {
    return Math.min.apply(Math, (0, _toConsumableArray2.default)(getAllMeasures(getWidth)));
  }
};

function calculateHeight() {
  var calMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'bodyOffset';

  if (!(calMethod in getHeight)) {
    _logger.default.error("'".concat(calMethod, "' is not a valid method name!"));
  }

  return getHeight[calMethod]();
}

function calculateWidth() {
  var calMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'scroll';

  if (!(calMethod in getWidth)) {
    _logger.default.error("'".concat(calMethod, "' is not a valid method name!"));
  }

  return getWidth[calMethod]();
}
/**
 * This function returns the offset height of the given node relative to the top of document.body
 */


function getOffsetToBody(node) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  // If the given node is body or null, return 0
  if (!node || node === window.document.body) {
    return 0;
  } // Stops if the offset parent node is body;
  // Otherwise keep searching up
  // NOTE: offsetParent will return null on Webkit if the element is hidden
  //       (the style.display of this element or any ancestor is "none") or
  //       if the style.position of the element itself is set to "fixed"
  //       See reference at https://developer.mozilla.org/en-US/docs/Web/API/HTMLelement/offsetParent#Compatibility


  var calculatedOffset = node.offsetTop + offset;
  var offsetParent = node.offsetParent;

  if (offsetParent === window.document.body) {
    return calculatedOffset;
  }

  return getOffsetToBody(offsetParent, calculatedOffset);
}
/**
 * This function returns the offset height of the given node relative to the top of document.body
 *
 * @note We are explicitly using the scrollHeight here since offsetHeight doesn't include any ::before or ::after
 * pseudo-elements, which can throw off the actual total height of the element. From the MDN web docs,
 *
 * scrollHeight:
 * > is a measurement of the height of an element's content, including content not visible on the screen due to
 * > overflow...is equal to the minimum height the element would require in order to fit all the content in the
 * > viewport without using a vertical scrollbar
 *
 * offsetHeight:
 * > is a measurement in pixels of the element's CSS height, including any borders, padding, and horizontal scrollbars
 * > (if rendered). It does not include the height of pseudo-elements such as ::before or ::after
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight
 */


function getOffsetHeightToBody(node) {
  return !node ? 0 : getOffsetToBody(node) + node.scrollHeight;
}