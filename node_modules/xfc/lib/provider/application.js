"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _jsonrpcDispatch = _interopRequireDefault(require("jsonrpc-dispatch"));

var _events = require("events");

var _mutationObserver = _interopRequireDefault(require("mutation-observer"));

var _string = require("../lib/string");

var _uri = _interopRequireDefault(require("../lib/uri"));

var _logger = _interopRequireDefault(require("../lib/logger"));

var _dimension = require("../lib/dimension");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/** Application class which represents an embedded application. */
var Application = /*#__PURE__*/function (_EventEmitter) {
  (0, _inherits2.default)(Application, _EventEmitter);

  var _super = _createSuper(Application);

  function Application() {
    (0, _classCallCheck2.default)(this, Application);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(Application, [{
    key: "init",

    /**
     * init method
     * @param  options.acls            An array that contains white listed origins
     * @param  options.secret          A string or function used for authorization with Consumer
     * @param  options.onReady         A function that will be called after App is authorized
     * @param  options.targetSelectors A DOMString containing one or more selectors to match against.
     *                                 This string must be a valid CSS selector string; if it's not,
     *                                 a SyntaxError exception is thrown.
     * @param  options.options         An optional object used for App to transmit details to frame
     *                                 after App is authorized.
     * @param options.dispatchFunction A function that will be used to dispatch messages instead of
     *                                 `parent.postMessage`. This function will receive the same
     *                                 `message` and `targetOrigin` arguments as `postMessage`.
     * @param options.authorizeMessage A function that will be called with a MessageEvent when the
     *                                 consumer dispatches a message in order to decide whether to
     *                                 handle the message or not. The message will be handled if this
     *                                 function returns true.
     */
    value: function init(_ref) {
      var _ref$acls = _ref.acls,
          acls = _ref$acls === void 0 ? [] : _ref$acls,
          _ref$secret = _ref.secret,
          secret = _ref$secret === void 0 ? null : _ref$secret,
          _ref$onReady = _ref.onReady,
          onReady = _ref$onReady === void 0 ? null : _ref$onReady,
          _ref$targetSelectors = _ref.targetSelectors,
          targetSelectors = _ref$targetSelectors === void 0 ? '' : _ref$targetSelectors,
          _ref$options = _ref.options,
          options = _ref$options === void 0 ? {} : _ref$options,
          _ref$customMethods = _ref.customMethods,
          customMethods = _ref$customMethods === void 0 ? {} : _ref$customMethods,
          _ref$dispatchFunction = _ref.dispatchFunction,
          dispatchFunction = _ref$dispatchFunction === void 0 ? null : _ref$dispatchFunction,
          _ref$authorizeMessage = _ref.authorizeMessage,
          authorizeMessage = _ref$authorizeMessage === void 0 ? null : _ref$authorizeMessage;
      this.acls = [].concat(acls);
      this.secret = secret;
      this.options = options;
      this.onReady = onReady;
      this.targetSelectors = targetSelectors;
      this.resizeConfig = null;
      this.requestResize = this.requestResize.bind(this);
      this.handleConsumerMessage = this.handleConsumerMessage.bind(this);
      this.authorizeConsumer = this.authorizeConsumer.bind(this);
      this.verifyChallenge = this.verifyChallenge.bind(this);
      this.emitError = this.emitError.bind(this);
      this.unload = this.unload.bind(this);

      this.dispatchFunction = dispatchFunction || function (message, targetOrigin) {
        // Don't send messages if not embedded
        if (window.self !== window.top) {
          parent.postMessage(message, targetOrigin);
        }
      };

      this.isMessageAuthorized = authorizeMessage || this.authorizeConsumerMessage; // Resize for slow loading images

      document.addEventListener('load', this.imageRequestResize.bind(this), true);
      var self = this;
      this.JSONRPC = new _jsonrpcDispatch.default(self.send.bind(self), _objectSpread({
        event: function event(_event, detail) {
          self.emit(_event, detail);
          return Promise.resolve();
        },
        resize: function resize() {
          var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          self.resizeConfig = config;
          self.requestResize(); // Registers a mutation observer for body

          var observer = new _mutationObserver.default(function (mutations) {
            return self.requestResize();
          });
          observer.observe(document.body, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          }); // Registers a listener to window.onresize
          // Optimizes the listener by debouncing (https://bencentra.com/code/2015/02/27/optimizing-window-resize.html#debouncing)

          var interval = 100; // Resize event will be considered complete if no follow-up events within `interval` ms.

          var resizeTimer = null;

          window.onresize = function (event) {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(function () {
              return self.requestResize();
            }, interval);
          };

          return Promise.resolve();
        }
      }, customMethods));
      window.addEventListener('message', this.handleConsumerMessage);
      window.addEventListener('beforeunload', this.unload);
    }
    /**
     * imageRequestResize function to call requestResize event for slow loading image
     * @param {object} event - event which triggered the listener
     */

  }, {
    key: "imageRequestResize",
    value: function imageRequestResize(event) {
      var tgt = event.target;

      if (tgt.tagName === 'IMG' && !(tgt.hasAttribute('height') || tgt.hasAttribute('width'))) {
        this.requestResize();
      }
    }
  }, {
    key: "requestResize",
    value: function requestResize() {
      if (!this.resizeConfig) return;

      if (this.resizeConfig.customCal) {
        this.JSONRPC.notification('resize');
      } else if (this.resizeConfig.autoResizeWidth) {
        var width = (0, _dimension.calculateWidth)(this.resizeConfig.WidthCalculationMethod);
        this.JSONRPC.notification('resize', [null, "".concat(width, "px")]);
      } else {
        var height = (0, _dimension.calculateHeight)(this.resizeConfig.heightCalculationMethod); // If targetSelectors is specified from Provider or Consumer or both,
        // need to calculate the height based on specified target selectors

        if (this.targetSelectors || this.resizeConfig.targetSelectors) {
          // Combines target selectors from two sources
          var targetSelectors = [this.targetSelectors, this.resizeConfig.targetSelectors].filter(function (val) {
            return val;
          }).join(', ');
          var heights = [].slice.call(document.querySelectorAll(targetSelectors)).map(_dimension.getOffsetHeightToBody);
          height = Math.max.apply(Math, (0, _toConsumableArray2.default)(heights).concat([height]));
        }

        this.JSONRPC.notification('resize', ["".concat(height, "px")]);
      }
    }
    /**
    * Triggers an event in the parent application.
    * @param {string} event - The event name to trigger.
    * @param {object} detail - The data context to send with the event.
    */

  }, {
    key: "trigger",
    value: function trigger(event, detail) {
      this.JSONRPC.notification('event', [event, detail]);
    }
    /**
    * Calls an event in the parent application.
    * @param {string} method - The event name to trigger.
    * @param {array} args - params to be sent to the event.
    */

  }, {
    key: "invoke",
    value: function invoke(method) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return this.JSONRPC.request(method, args);
    }
    /**
    * Request to mount an application fullscreen.
    * @param {string} url - The url of the application to mount.
    */

  }, {
    key: "fullscreen",
    value: function fullscreen(url) {
      this.trigger('xfc.fullscreen', url);
    }
    /**
     * Sends http errors to consumer.
     * @param  {object} error - an object containing error details
     */

  }, {
    key: "httpError",
    value: function httpError() {
      var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.trigger('xfc.provider.httpError', error);
    }
    /**
     * Request to load a new page of given url
     * @param  {string} url - The url of the new page.
     */

  }, {
    key: "loadPage",
    value: function loadPage(url) {
      this.JSONRPC.notification('loadPage', [url]);
    }
    /**
    * Launches the provider app and begins the authorization sequence.
    */

  }, {
    key: "launch",
    value: function launch() {
      if (window.self !== window.top) {
        // Begin launch and authorization sequence
        this.JSONRPC.notification('launch'); // We have a specific origin to trust (excluding wildcard *),
        // wait for response to authorize.

        if (this.acls.some(function (x) {
          return x !== '*';
        })) {
          this.JSONRPC.request('authorizeConsumer', []).then(this.authorizeConsumer).catch(this.emitError); // We don't know who to trust, challenge parent for secret
        } else if (this.secret) {
          this.JSONRPC.request('challengeConsumer', []).then(this.verifyChallenge).catch(this.emitError); // acl is '*' and there is no secret, immediately authorize content
        } else {
          this.authorizeConsumer();
        } // If not embedded, immediately authorize content

      } else {
        this.authorizeConsumer();
      }
    }
    /**
     * Verify an incoming message event's origin against the configured ACLs
     * @param {object} event - The emitted message event.
     */

  }, {
    key: "authorizeConsumerMessage",
    value: function authorizeConsumerMessage(event) {
      // Ignore Non-JSONRPC messages or messages not from the parent frame
      if (!event.data.jsonrpc || event.source !== window.parent) {
        return false;
      }

      _logger.default.log('<< provider', event.origin, event.data); // For Chrome, the origin property is in the event.originalEvent object


      var origin = event.origin || event.originalEvent.origin;

      if (!this.activeACL && this.acls.includes(origin)) {
        this.activeACL = origin;
      }

      if (this.acls.includes('*') || this.acls.includes(origin) || this.acls.some(function (acl) {
        // Strip leading wildcard to get domain and verify it matches the end of the event's origin.
        var domain = acl.replace(/^\*/, '');
        return origin.substring(origin.length - domain.length) === domain;
      })) {
        return true;
      }

      return false;
    }
    /**
    * Handles an incoming message event by processing the JSONRPC request
    * @param {object} event - The emitted message event.
    */

  }, {
    key: "handleConsumerMessage",
    value: function handleConsumerMessage(event) {
      if (this.isMessageAuthorized(event)) {
        this.JSONRPC.handle(event.data);
      }
    }
    /**
    * Send the given message to the application's parent.
    * @param {object} message - The message to send.
    */

  }, {
    key: "send",
    value: function send(message) {
      var _this = this;

      if (this.acls.length < 1) {
        _logger.default.error('Message not sent, no acls provided.');
      }

      if (message) {
        _logger.default.log('>> provider', this.acls, message);

        if (this.activeACL) {
          this.dispatchFunction(message, this.activeACL);
        } else if (this.acls.some(function (acl) {
          return acl.includes('*');
        })) {
          // If acls includes urls with wild cards we do not know
          // where we are embedded.  Provide '*' so the messages can be sent.
          this.acls.forEach(function (uri) {
            return _this.dispatchFunction(message, '*');
          });
        } else {
          this.acls.forEach(function (uri) {
            return _this.dispatchFunction(message, uri);
          });
        }
      }
    }
    /**
    * Verify the challange made to the parent frame.
    * @param {string} secretAttempt - The secret string to verify
    */

  }, {
    key: "verifyChallenge",
    value: function verifyChallenge(secretAttempt) {
      var _this2 = this;

      var authorize = function authorize() {
        _this2.acls = ['*'];

        _this2.authorizeConsumer();
      };

      if (typeof this.secret === 'string' && (0, _string.fixedTimeCompare)(this.secret, secretAttempt)) {
        authorize();
      } else if (typeof this.secret === 'function') {
        return this.secret.call(this, secretAttempt).then(authorize);
      }

      return Promise.resolve();
    }
    /**
    * Authorize the parent frame by unhiding the container.
    */

  }, {
    key: "authorizeConsumer",
    value: function authorizeConsumer() {
      document.documentElement.removeAttribute('hidden'); // Emit a ready event

      this.emit('xfc.ready');
      this.JSONRPC.notification('authorized', [{
        url: window.location.href,
        options: this.options
      }]); // If there is an onReady callback, execute it

      if (typeof this.onReady === 'function') {
        this.onReady.call(this);
      }
    }
    /**
     * Emit the given error
     * @param  {object} error - an error object containing error code and error message
     */

  }, {
    key: "emitError",
    value: function emitError(error) {
      this.emit('xfc.error', error);
    }
  }, {
    key: "unload",
    value: function unload() {
      // These patterns trigger unload events but don't actually unload the page
      var protocols = /^(tel|mailto|fax|sms|callto):/;
      var element = document.activeElement;

      if (!element || !(element.hasAttribute && element.hasAttribute('download') || protocols.test(element.href))) {
        this.JSONRPC.notification('unload');
        this.trigger('xfc.unload');
      }
    }
  }]);
  return Application;
}(_events.EventEmitter);

var _default = Application;
exports.default = _default;