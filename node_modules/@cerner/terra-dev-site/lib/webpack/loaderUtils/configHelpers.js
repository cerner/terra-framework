"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var path = require('path');
var fs = require('fs');
var lodashStartCase = require('lodash.startcase');
var monoRepoPackageCache = {};

/**
 * Cheat. If the filename still contains a period, don't run startcase. This allows for filenames of version (v0.5.0).
 */
var startCase = function startCase(string) {
  if (string.includes('.')) {
    return string;
  }
  return lodashStartCase(string);
};

/**
 * Gathers the complete set of requested page types.
 */
var pageTypes = function pageTypes(primaryNavigationItems) {
  return primaryNavigationItems.reduce(function (acc, primaryNavigationItem) {
    return acc.concat([primaryNavigationItem.contentExtension]);
  }, []);
};

/**
 * Provides the namespace for the package in this order, mono repo package, node_modules package, provided package name.
 */
var getNamespace = function getNamespace(directory, namespace) {
  // If this is a monorepo package, we need to pull the namespace from the package.json file to account for scoping.
  var packageRoot = (/.*packages\/[^/]*/.exec(directory) || {})[0];
  var afterPackages;
  if (packageRoot) {
    var packagePath = path.join(packageRoot, 'package.json');
    // cache the package name to avoid opening the files all the time.
    afterPackages = monoRepoPackageCache[packagePath];
    if (!afterPackages && fs.existsSync(packagePath)) {
      // eslint-disable-next-line global-require, import/no-dynamic-require
      afterPackages = require(packagePath).name;
      monoRepoPackageCache[packagePath] = afterPackages;
    }
  }
  // Find the directory name directly after node modules... include scoped package if they exist.
  var afterNodeModules = (/node_modules\/((@[^/]*\/)?[^/]*)/.exec(directory) || {})[1];
  return afterPackages || afterNodeModules || namespace;
};

/**
 * Returns an array of routes based on folder path.
 */
var getRoutes = function getRoutes(fileName, entryPoint) {
  var parsedPath = path.parse(entryPoint);
  var routes = [];
  if (parsedPath.dir !== '/') {
    routes = parsedPath.dir.split('/');
  }

  // Note: splitting on separator results in the first array element to be '' so we shift to get rid of it.
  routes.shift();

  // add on the file name as the last route
  routes.push(fileName);
  return routes;
};

/**
 * Returns an object of the end most extension and the filename minus that extension.
 *
* @param {*} filePath A string representing the directory path of the file.
*/
var parseExtension = function parseExtension(filePath) {
  var result = /\.([^.]+$)/.exec(filePath);
  var extension;
  if (result) {
    var _result = (0, _slicedToArray2.default)(result, 2);
    extension = _result[1];
  }
  return {
    name: filePath.replace(/\.[^.]+$/, ''),
    extension: extension
  };
};

/**
 * Returns a linux style file path.
 *
* @param {*} filePath A string representing the directory path of the file.
*/
var formatPath = function formatPath(filePath) {
  return filePath.replace(/\\/g, '/');
};
var configHelpers = {
  startCase: startCase,
  pageTypes: pageTypes,
  getNamespace: getNamespace,
  getRoutes: getRoutes,
  parseExtension: parseExtension,
  formatPath: formatPath
};
module.exports = configHelpers;