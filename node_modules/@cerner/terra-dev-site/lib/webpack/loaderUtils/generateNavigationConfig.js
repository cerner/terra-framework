"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var path = require('path');
var glob = require('glob');
var kebabCase = require('lodash.kebabcase');
var _require = require('./configHelpers'),
  startCase = _require.startCase,
  pageTypes = _require.pageTypes,
  getNamespace = _require.getNamespace,
  getRoutes = _require.getRoutes,
  parseExtension = _require.parseExtension,
  formatPath = _require.formatPath;

/**
* Creates the basic page config consisting of name of the page, the route to the page and the sort group for the page.
*/
var getPageConfig = function getPageConfig(route) {
  // Grab the group extension if one exists.
  var _parseExtension = parseExtension(route),
    name = _parseExtension.name,
    group = _parseExtension.extension;
  return {
    label: startCase(name),
    group: group
  };
};
var generateUrl = function generateUrl(routes, namespace, primaryPath) {
  return "".concat(primaryPath, "/").concat(kebabCase(namespace), "/").concat(routes.map(function (route) {
    return kebabCase(route.replace(/\.[^.]+$/, ''));
  }).join('/'));
};

/**
* Recursively generates page configs.
*/
var recurs = function recurs(_ref) {
  var config = _ref.config,
    routes = _ref.routes,
    contentPath = _ref.contentPath,
    ext = _ref.ext,
    contentImports = _ref.contentImports,
    url = _ref.url,
    pageConfig = _ref.pageConfig;
  // Prefer modifying config over creating new config, this way we blend file paths together in the ui.
  var configCopy = config || getPageConfig(routes[0]);

  // Pop off the top most directory.
  var slicedDir = routes.slice(1);

  // If this is not an end point, recursively gather the child pages.
  if (slicedDir.length > 0) {
    if (!configCopy.children) {
      configCopy.children = {};
    }
    configCopy.children[slicedDir[0]] = recurs({
      config: configCopy.children[slicedDir[0]],
      routes: slicedDir,
      contentPath: contentPath,
      ext: ext,
      contentImports: contentImports,
      url: url,
      pageConfig: pageConfig
    });
  } else {
    // if this is a leaf page, add the content path and type to the config.
    configCopy.path = url;
    // eslint-disable-next-line no-param-reassign
    contentImports[url] = contentPath;
    configCopy.type = ext;
    // eslint-disable-next-line no-param-reassign
    pageConfig[url] = {
      label: configCopy.label,
      type: ext
    };
  }
  return configCopy;
};

/**
* Builds out config for a root page.
*/
var buildPageConfig = function buildPageConfig(_ref2) {
  var filePaths = _ref2.filePaths,
    namespace = _ref2.namespace,
    contentImports = _ref2.contentImports,
    primaryNavItemsMap = _ref2.primaryNavItemsMap,
    pageConfig = _ref2.pageConfig;
  return filePaths.reduce(function (acc, _ref3) {
    var filePath = _ref3.filePath,
      entryPoint = _ref3.entryPoint;
    // Break up the file path
    var parsedPath = path.parse(entryPoint);
    // Grab the type (doc, test, etc) and the name without the extension.
    var _parseExtension2 = parseExtension(parsedPath.name),
      name = _parseExtension2.name,
      fileType = _parseExtension2.extension;
    var referenceNavItem = primaryNavItemsMap[fileType];
    var primaryNavItem = acc[referenceNavItem.path];
    if (!primaryNavItem) {
      primaryNavItem = {
        label: referenceNavItem.label,
        path: referenceNavItem.path,
        children: {}
      };
      acc[referenceNavItem.path] = primaryNavItem;
    }

    // Drop the period for the extension.
    var ext = parsedPath.ext.slice(1);
    var routes = getRoutes(name, entryPoint);
    var packageNamespace = getNamespace(filePath, namespace);
    var key = routes[0];
    primaryNavItem.children[key] = recurs({
      config: primaryNavItem.children[key],
      routes: routes,
      contentPath: filePath,
      ext: ext,
      contentImports: contentImports,
      url: generateUrl(routes, packageNamespace, primaryNavItem.path),
      pageConfig: pageConfig
    });
    return acc;
  }, {});
};

/**
* Simple alpha sort. Modified from MDN, if I'm (Matt) being honest.
*/
var alphaSort = function alphaSort(a, b) {
  if (a && !b) {
    return -1;
  }
  if (!a && b) {
    return 1;
  }
  if (!a && !b) {
    return 0;
  }
  var nameA = a.toUpperCase(); // ignore upper and lowercase
  var nameB = b.toUpperCase(); // ignore upper and lowercase
  if (nameA < nameB) {
    return -1;
  }
  if (nameA > nameB) {
    return 1;
  }

  // names must be equal
  return 0;
};

/**
* Sort first by group, then by alpha as a tie breaker.
*/
var sortPage = function sortPage(a, b) {
  var result = alphaSort(a.group, b.group);
  if (result === 0) {
    result = alphaSort(a.label, b.label);
  }
  return result;
};

/**
* Sort the pages objects and convert them into ordered arrays.
*/
var sortPageConfig = function sortPageConfig(config) {
  return config.sort(sortPage).map(function (page) {
    // eslint-disable-next-line no-param-reassign
    delete page.group;
    if (page.children) {
      // eslint-disable-next-line no-param-reassign
      page.children = sortPageConfig(Object.values(page.children));
    }
    return page;
  });
};
var addWatchContentDirectories = function addWatchContentDirectories(_ref4) {
  var mode = _ref4.mode,
    addContextDependency = _ref4.addContextDependency,
    sourceFolder = _ref4.sourceFolder,
    isLernaMonoRepo = _ref4.isLernaMonoRepo,
    contentDirectory = _ref4.contentDirectory;
  if (mode === 'production') {
    return;
  }
  var processPath = formatPath(process.cwd());
  if (isLernaMonoRepo) {
    glob.sync("".concat(processPath, "/packages/*/").concat(sourceFolder, "/").concat(contentDirectory)).forEach(function (dir) {
      addContextDependency("".concat(dir, "/"));
    });
  } else {
    addContextDependency("".concat(processPath, "/").concat(sourceFolder, "/").concat(contentDirectory, "/"));
  }
};
var getSearchPatterns = function getSearchPatterns(_ref5) {
  var additionalSearchDirectories = _ref5.additionalSearchDirectories,
    primaryNavigationItems = _ref5.primaryNavigationItems,
    resolveExtensions = _ref5.resolveExtensions,
    mode = _ref5.mode,
    sourceFolder = _ref5.sourceFolder,
    distributionFolder = _ref5.distributionFolder,
    isLernaMonoRepo = _ref5.isLernaMonoRepo,
    contentDirectory = _ref5.contentDirectory;
  var processPath = formatPath(process.cwd());
  var typesGlob = pageTypes(primaryNavigationItems).join(',');
  var typesRegex = pageTypes(primaryNavigationItems).map(function (type) {
    return "/".concat(type);
  }).join('|');

  // remove . from extensions
  var extensions = resolveExtensions.map(function (ext) {
    return ext.slice(1);
  });

  // the markdown extension is not optional.
  var ext = [].concat((0, _toConsumableArray2.default)(extensions), ['md', 'mdx']);
  var sourceDir = mode !== 'production' ? "".concat(sourceFolder) : "".concat(distributionFolder);
  var localPackages = (0, _toConsumableArray2.default)(isLernaMonoRepo ? [{
    pattern: "".concat(processPath, "/packages/*/").concat(sourceDir, "/").concat(contentDirectory, "/**/*.{").concat(typesGlob, ",}.{").concat(ext.join(','), "}"),
    entryPoint: "".concat(processPath, "/packages/[^/]*/").concat(sourceDir, "/").concat(contentDirectory, "(").concat(typesRegex, ")?")
  }] : [{
    pattern: "".concat(processPath, "/").concat(sourceDir, "/").concat(contentDirectory, "/**/*.{").concat(typesGlob, ",}.{").concat(ext.join(','), "}"),
    entryPoint: "".concat(processPath, "/").concat(sourceDir, "/").concat(contentDirectory, "(").concat(typesRegex, ")?")
  }]);
  return [].concat((0, _toConsumableArray2.default)(localPackages), (0, _toConsumableArray2.default)(additionalSearchDirectories.map(function (searchDirectory) {
    return {
      pattern: "".concat(searchDirectory, "/**/*.{").concat(typesGlob, ",}.{").concat(ext.join(','), "}"),
      entryPoint: "".concat(searchDirectory, "(").concat(typesRegex, ")?")
    };
  })));
};
var executeSearchPatterns = function executeSearchPatterns(_ref6) {
  var patterns = _ref6.patterns;
  return patterns.reduce(function (acc, _ref7) {
    var pattern = _ref7.pattern,
      entryPoint = _ref7.entryPoint;
    return acc.concat(glob.sync(pattern, {
      nodir: true
    }).map(function (filePath) {
      return {
        filePath: filePath,
        entryPoint: filePath.replace(new RegExp(entryPoint).exec(filePath)[0], '')
      };
    }));
  }, []);
};
var findFirstPagePath = function findFirstPagePath(navItem) {
  if (navItem.children) {
    return findFirstPagePath(navItem.children[0]);
  }
  return navItem.path;
};

/**
* Generates the file representing page config, which is in turn consumed by route config.
*/
var generatePagesConfig = function generatePagesConfig(_ref8) {
  var siteConfig = _ref8.siteConfig,
    resolveExtensions = _ref8.resolveExtensions,
    mode = _ref8.mode,
    contentDirectory = _ref8.contentDirectory,
    isLernaMonoRepo = _ref8.isLernaMonoRepo,
    addContextDependency = _ref8.addContextDependency,
    logger = _ref8.logger;
  var additionalSearchDirectories = siteConfig.additionalSearchDirectories,
    primaryNavigationItems = siteConfig.primaryNavigationItems,
    sourceFolder = siteConfig.sourceFolder,
    distributionFolder = siteConfig.distributionFolder,
    enableDebugLogging = siteConfig.enableDebugLogging;

  // Watch directories for changes
  addWatchContentDirectories({
    mode: mode,
    addContextDependency: addContextDependency,
    sourceFolder: sourceFolder,
    isLernaMonoRepo: isLernaMonoRepo,
    contentDirectory: contentDirectory
  });

  // Get the default search patterns for both normal and lerna mono repos.
  var patterns = getSearchPatterns({
    additionalSearchDirectories: additionalSearchDirectories,
    primaryNavigationItems: primaryNavigationItems,
    resolveExtensions: resolveExtensions,
    mode: mode,
    sourceFolder: sourceFolder,
    distributionFolder: distributionFolder,
    isLernaMonoRepo: isLernaMonoRepo,
    contentDirectory: contentDirectory
  });
  if (enableDebugLogging) {
    logger.info('*****************************');
    logger.info('[terra dev site] Search Patterns:');
    logger.info(JSON.stringify(patterns, null, 2));
  }

  // Execute the globs and regex masks, to trim the directories.
  var filePaths = executeSearchPatterns({
    patterns: patterns
  });

  // Add Additional content
  primaryNavigationItems.forEach(function (item) {
    if (item.additionalContent) {
      item.additionalContent.forEach(function (content) {
        filePaths.push({
          filePath: formatPath(content.filePath),
          entryPoint: "/".concat(content.label, ".").concat(item.contentExtension).concat(path.extname(content.filePath))
        });
      });
    }
  });
  if (enableDebugLogging) {
    logger.info('*****************************');
    logger.info('[terra dev site] File Paths:');
    logger.info(JSON.stringify(filePaths, null, 2));
  }
  var contentImports = {};
  var pageConfig = {};

  // Create a map of primary navigation items
  var primaryNavItemsMap = primaryNavigationItems.reduce(function (acc, primaryNavigationItem) {
    acc[primaryNavigationItem.contentExtension] = primaryNavigationItem;
    return acc;
  }, {});

  // Build out the navigation config from the discovered file paths.
  var config = buildPageConfig({
    filePaths: filePaths,
    namespace: siteConfig.namespace,
    contentImports: contentImports,
    primaryNavItemsMap: primaryNavItemsMap,
    pageConfig: pageConfig
  });
  var routesMap = {};

  // convert navigation items to an array and sort
  var navigationConfig = primaryNavigationItems.reduce(function (acc, primaryNavigationItem) {
    var navItem = config[primaryNavigationItem.path];
    if (navItem) {
      navItem.children = sortPageConfig(Object.values(navItem.children));
      routesMap[navItem.path] = findFirstPagePath(navItem);
      if (navItem.children.length === 1 && !navItem.children[0].children) {
        var _navItem$children = (0, _slicedToArray2.default)(navItem.children, 1);
        navItem.pageConfig = _navItem$children[0];
        delete navItem.children;
      }
      acc.push(navItem);
    }
    return acc;
  }, []);
  if (enableDebugLogging) {
    logger.info('*****************************');
    logger.info('[terra dev site] Navigation Config:');
    logger.info(JSON.stringify(navigationConfig, null, 2));
  }

  // map root route to first content item in the first primary nav item
  if (navigationConfig.length > 0) {
    routesMap['/'] = routesMap[navigationConfig[0].path];
  }
  return {
    contentImports: contentImports,
    navigationConfig: navigationConfig,
    routesMap: routesMap,
    pageConfig: pageConfig
  };
};
module.exports = generatePagesConfig;