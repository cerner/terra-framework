"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var path = require('path');
var _require = require('loader-utils'),
  getOptions = _require.getOptions;
var findSource = require('../loaderUtils/findSource');
var generateMarkdown = function generateMarkdown(content, extension) {
  return ["```".concat(extension), content, '```'].join('\n');
};

/**
 * Load the contents of the file into the codeblock
 * This loader expects to be chained with the mdx loader.
 */

var loader = /*#__PURE__*/function () {
  var _loader = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(content) {
    var _this = this;
    var callback, resourcePath, _getOptions, resolveExtensions, _findSource, source, filePath, extension;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            callback = this.async();
            resourcePath = this.resourcePath;
            _getOptions = getOptions(this), resolveExtensions = _getOptions.resolveExtensions;
            _findSource = findSource(resourcePath, resolveExtensions), source = _findSource.source, filePath = _findSource.filePath, extension = _findSource.extension; // short circuit, if this already is the source file, just return that.
            if (!(filePath === resourcePath)) {
              _context.next = 6;
              break;
            }
            return _context.abrupt("return", callback(null, generateMarkdown(content, extension)));
          case 6:
            return _context.abrupt("return", this.resolve('', source, function (resolveError, result) {
              if (result) {
                _this.addDependency(result);
                // remove . from extension;
                var srcExtension = path.extname(result).slice(1);
                return _this.fs.readFile(result, function (readFileError, srcFile) {
                  return callback(null, generateMarkdown(srcFile, srcExtension));
                });
              }
              // Fallback, if no result is found generate the snippet from the existing file,
              return callback(null, generateMarkdown(content, extension));
            }));
          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  function loader(_x) {
    return _loader.apply(this, arguments);
  }
  return loader;
}();
module.exports = loader;