"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _require = require('loader-utils'),
  getOptions = _require.getOptions;
var reactDocs = require('react-docgen');
var findSource = require('../loaderUtils/findSource');

/**
 * Parses prop types into a more compact representation.
 * @param {object} type prop type information to parse.
 * @param {string} type.value the value for the type
 * @param {string} type.name the name of the type
 * @param {boolean} type.required whether or not the type is required
 * @param {description} type.description the description of the type
 * @param {bool} indent should indent the return value.
 */
var parsePropType = function parsePropType(_ref) {
  var type = _ref.type,
    _ref$indent = _ref.indent,
    indent = _ref$indent === void 0 ? false : _ref$indent;
  var value = type.value,
    name = type.name,
    required = type.required,
    description = type.description;
  var returnValue = [];
  if (value) {
    if (name === 'instanceOf') {
      returnValue = ["InstanceOf: ".concat(value, ",")];
    } else if (name === 'enum') {
      returnValue = ['enum: ['].concat((0, _toConsumableArray2.default)(value.map(function (val) {
        return "  ".concat(val.value);
      })), ['],']);
    } else if (name === 'union') {
      returnValue = ['unionOf: ['].concat((0, _toConsumableArray2.default)(value.map(function (val) {
        return parsePropType({
          type: val,
          indent: true
        });
      })), ['],']);
    } else if (name === 'arrayOf') {
      returnValue = ['arrayOf: [{'].concat((0, _toConsumableArray2.default)(parsePropType({
        type: value,
        indent: true
      })), ['}],']);
    } else if (name === 'objectOf') {
      returnValue = ['objectOf: {'].concat((0, _toConsumableArray2.default)(parsePropType({
        type: value,
        indent: true
      })), ['},']);
    } else if (name === 'shape') {
      returnValue = ['shape: {'].concat((0, _toConsumableArray2.default)(Object.entries(value).reduce(function (acc, _ref2) {
        var _ref3 = (0, _slicedToArray2.default)(_ref2, 2),
          key = _ref3[0],
          val = _ref3[1];
        return acc.concat(["".concat(key, ": {")].concat((0, _toConsumableArray2.default)(parsePropType({
          type: val,
          indent: true
        })), ['},']));
      }, []).map(function (val) {
        return "  ".concat(val);
      })), ['},']);
    } else if (name === 'exact') {
      returnValue = ['exactShape: {'].concat((0, _toConsumableArray2.default)(Object.entries(value).reduce(function (acc, _ref4) {
        var _ref5 = (0, _slicedToArray2.default)(_ref4, 2),
          key = _ref5[0],
          val = _ref5[1];
        return acc.concat(["".concat(key, ": {")].concat((0, _toConsumableArray2.default)(parsePropType({
          type: val,
          indent: true
        })), ['},']));
      }, []).map(function (val) {
        return "  ".concat(val);
      })), ['},']);
    }
  } else {
    if (!indent) {
      returnValue.push(name);
    } else {
      returnValue.push("type: '".concat(name, "',"));
    }
    if (required) {
      returnValue.push("required: ".concat(required, ","));
    }
    if (description) {
      returnValue.push("description: '".concat(description, "',"));
    }
  }
  if (indent) {
    return returnValue.map(function (val) {
      return "  ".concat(val);
    });
  }
  return returnValue;
};

/**
 * Create the type mdx react component
 * @param {name, value} type
 */
var propType = function propType(_ref6) {
  var type = _ref6.type;
  // return value;
  var parsed = parsePropType({
    type: type
  }).join('\n');
  return "\n```javascript\n".concat(parsed, "\n```");
};

/**
 * Create the default value string.
 * @param {*} value
 */
var propDefaultValue = function propDefaultValue(value) {
  if (!value) {
    return 'none';
  }
  return "```javascript\n".concat(value.value, "\n```");
};
var generatePropsTable = function generatePropsTable(_ref7) {
  var filePath = _ref7.filePath,
    source = _ref7.source,
    callback = _ref7.callback;
  var parsedProps;
  try {
    parsedProps = reactDocs.parse(source, undefined, undefined, {
      filename: filePath
    });
  } catch (e) {
    return callback("Could not convert file to props table:\n".concat(filePath, "\n").concat(e));
  }
  var count = 0;
  // loop through parsed props to generate table.
  var rows = Object.entries(parsedProps.props).map(function (_ref8) {
    var _ref9 = (0, _slicedToArray2.default)(_ref8, 2),
      name = _ref9[0],
      prop = _ref9[1];
    if (prop.description.includes('@private')) {
      return '';
    }
    count += 1;
    var type = propType({
      type: prop.type
    });
    var defaultValue = propDefaultValue(prop.defaultValue);
    var required = prop.required || prop.type.name === 'custom' && prop.type.raw && prop.type.raw.includes('isRequired') ? 'true' : 'false';
    return ["<Row key=\"ROW".concat(count, "\">"), '<PropNameCell>', name, '</PropNameCell>', '<TypeCell>',
    // these spaces are important, it allows mdx to process this value.
    '', type, '', '</TypeCell>', "<RequiredCell isRequired={".concat(required, "} />"), '<DefaultValueCell>', '', defaultValue, '', '</DefaultValueCell>', '<DescriptionCell>', '', prop.description, '', '</DescriptionCell>', '</Row>'].join('\n');
  });
  return callback(null, ['import PropsTable, { PropNameCell, TypeCell, RequiredCell, DefaultValueCell, DescriptionCell, Row } from \'@cerner/terra-dev-site/lib/loader-components/_PropsTable\';', '', '<PropsTable>'].concat((0, _toConsumableArray2.default)(rows), ['</PropsTable>', '']).join('\n'));
};

/**
 * The async loader to create the props table component
 * Don't use an arrow function or you wont have access to `this`
 */
var loader = /*#__PURE__*/function () {
  var _loader = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(content) {
    var _this = this;
    var _getOptions, resolveExtensions, resourcePath, _findSource, source, filePath, callback;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            // Retrieve mdx options and resolve extensions.
            _getOptions = getOptions(this), resolveExtensions = _getOptions.resolveExtensions; // Find src
            resourcePath = this.resourcePath;
            _findSource = findSource(resourcePath, resolveExtensions), source = _findSource.source, filePath = _findSource.filePath;
            callback = this.async(); // short circuit, if this already is the source file, just return that.
            if (!(filePath === resourcePath)) {
              _context3.next = 6;
              break;
            }
            return _context3.abrupt("return", generatePropsTable({
              filePath: filePath,
              source: content,
              callback: callback
            }));
          case 6:
            return _context3.abrupt("return", this.resolve('', source, /*#__PURE__*/function () {
              var _ref10 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(err, result) {
                return _regenerator.default.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        if (!err) {
                          _context2.next = 2;
                          break;
                        }
                        return _context2.abrupt("return", callback(new Error("A non transpiled source file is required for the props table to be generated:\n".concat(source))));
                      case 2:
                        // Add the src file to webpack's dependency list
                        _this.addDependency(result);

                        // Read src file
                        return _context2.abrupt("return", _this.fs.readFile(result, /*#__PURE__*/function () {
                          var _ref11 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(readFileError, srcFile) {
                            return _regenerator.default.wrap(function _callee$(_context) {
                              while (1) {
                                switch (_context.prev = _context.next) {
                                  case 0:
                                    return _context.abrupt("return", generatePropsTable({
                                      filePath: result,
                                      source: srcFile,
                                      callback: callback
                                    }));
                                  case 1:
                                  case "end":
                                    return _context.stop();
                                }
                              }
                            }, _callee);
                          }));
                          return function (_x4, _x5) {
                            return _ref11.apply(this, arguments);
                          };
                        }()));
                      case 4:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));
              return function (_x2, _x3) {
                return _ref10.apply(this, arguments);
              };
            }()));
          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  function loader(_x) {
    return _loader.apply(this, arguments);
  }
  return loader;
}();
module.exports = loader;