"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/* eslint-disable no-param-reassign */
var HtmlWebpackPlugin = require('html-webpack-plugin');
var path = require('path');
var _require = require('webpack'),
  DefinePlugin = _require.DefinePlugin;
var fs = require('fs');
var logging = require('webpack/lib/logging/runtime');
var chalk = require('chalk');
// const https = require('https');
// const http = require('http');

var DirectorySwitcherPlugin = require('./resolve/DirectorySwitcherPlugin');
var LocalPackageAliasPlugin = require('./resolve/LocalPackageAliasPlugin');
var _require2 = require('./siteLoaderUtils'),
  babelLoader = _require2.babelLoader,
  getMdxLoader = _require2.getMdxLoader;
var getNewRelicJS = require('../new-relic/getNewRelicJS');
var logger = logging.getLogger('terra-dev-site');

// Singletons
var oneTimeSetupComplete = false;
var siteRegistry = {};
var processPath = process.cwd();
var isLernaMonoRepo = fs.existsSync(path.join(processPath, 'lerna.json'));
var entryLoaderData = {};
var generatedBootstrapData = {};
var urlQueue = [];

/**
 * Updates the webpack options with defaults that terra-dev-site requires.
 */
var SitePlugin = /*#__PURE__*/function () {
  function SitePlugin(_ref) {
    var entry = _ref.entry,
      config = _ref.config;
    (0, _classCallCheck2.default)(this, SitePlugin);
    // Apply defaults to the config.
    this.siteConfig = config;
    var _this$siteConfig = this.siteConfig,
      pathPrefix = _this$siteConfig.pathPrefix,
      titleConfig = _this$siteConfig.titleConfig;
    this.entry = entry;
    if (pathPrefix) {
      this.entryKey = "".concat(pathPrefix, "/index");
      this.resourceQuery = "?terra-entry-".concat(pathPrefix);
      this.htmlFileName = "".concat(pathPrefix, "/index.html");
      this.url = "/".concat(pathPrefix, "/");
    } else {
      this.entryKey = 'index';
      this.resourceQuery = '?terra-entry';
      this.htmlFileName = 'index.html';
      this.url = '/';
    }
    if (siteRegistry[pathPrefix]) {
      throw Error('The PathPrefix must be unique per TerraDevSite Plugin');
    }
    // Register each application instance with the siteRegistry
    siteRegistry[pathPrefix] = {
      path: pathPrefix,
      url: this.url,
      title: titleConfig.title,
      entry: this.entryKey
    };
  }
  (0, _createClass2.default)(SitePlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;
      var isWebpack5 = compiler.webpack && compiler.webpack.version.startsWith('5');
      var publicPath = SitePlugin.getPublicPath({
        compiler: compiler
      });

      // Strip the trailing / from the public path.
      var basename = publicPath.slice(0, -1);
      var _this$siteConfig2 = this.siteConfig,
        sourceFolder = _this$siteConfig2.sourceFolder,
        distributionFolder = _this$siteConfig2.distributionFolder;

      // Since there can be multiple dev site plugins this config we only want to do once for all of them.
      SitePlugin.applyOneTimeSetup({
        compiler: compiler,
        sourceFolder: sourceFolder,
        distributionFolder: distributionFolder,
        basename: basename,
        isWebpack5: isWebpack5
      });

      // Get the list of apps excluding this current app.
      var filteredSites = Object.values(siteRegistry).filter(function (site) {
        return site.path !== _this.siteConfig.pathPrefix;
      });

      // Map to what we want to send to site config
      var otherSites = filteredSites.map(function (site) {
        return {
          path: site.path,
          title: site.title,
          url: "".concat(basename).concat(site.url)
        };
      });

      // if there is a path prefix we want to update the react router basename to include the prefix.
      if (this.siteConfig.pathPrefix) {
        basename = [basename, this.siteConfig.pathPrefix].join('/');
      }
      entryLoaderData[this.resourceQuery] = {
        entryPath: this.entry,
        siteConfig: this.siteConfig,
        sites: otherSites,
        basename: basename,
        resolveExtensions: compiler.options.resolve.extensions,
        isLernaMonoRepo: isLernaMonoRepo,
        contentDirectory: this.siteConfig.contentDirectory,
        dataCallback: function dataCallback(data) {
          // this data callback allows us to pull information back out of the loader.
          generatedBootstrapData[_this.resourceQuery] = data.relativeUrls;
        }
      };
      var webpackConfig = {
        entry: (0, _defineProperty2.default)({}, this.entryKey, "@cerner/terra-dev-site/lib/webpack/templates/entry.template".concat(this.resourceQuery))
      };

      // If this plugin is used with webpack 5 we must normalize the webpack config.
      if (isWebpack5) {
        webpackConfig = compiler.webpack.config.getNormalizedWebpackOptions(webpackConfig);
      }

      // ENTRY
      compiler.options.entry = _objectSpread(_objectSpread({}, compiler.options.entry), webpackConfig.entry);

      // Generate the index.html file for the site.
      new HtmlWebpackPlugin({
        title: this.siteConfig.titleConfig.title,
        publicPath: publicPath,
        filename: this.htmlFileName,
        template: path.join(__dirname, '..', 'templates', 'index.html'),
        favicon: this.siteConfig.faviconFilePath,
        headHtml: [getNewRelicJS()].concat(this.siteConfig.headHtml),
        excludeChunks: ['rewriteHistory', 'redirect'].concat((0, _toConsumableArray2.default)(Object.values(filteredSites).map(function (site) {
          return site.entry;
        })), (0, _toConsumableArray2.default)(this.siteConfig.excludeChunks))
      }).apply(compiler);

      // Clean up the singletons after plugins are applied.
      compiler.hooks.afterPlugins.tap('terra-dev-site-site-plugin', function () {
        oneTimeSetupComplete = false;
        siteRegistry = {};
      });

      // Evaluate all URLS found in the site for correctness.
      compiler.hooks.done.tap('terra-dev-site-plugin', function () {
        // Convert generated links for all sites into a single list.
        var validRelativeUrls = Object.values(generatedBootstrapData).reduce(function (acc, urls) {
          return acc.concat(urls);
        }, []);
        // add the favicon since it's valid too.
        validRelativeUrls.push("".concat(publicPath.slice(0, -1), "/favicon.ico"));

        // Log formatting
        var invalidUrlLog = function invalidUrlLog(url) {
          return "".concat(chalk.blue(url.url), " in:\n ").concat(chalk.yellow(url.file.history[0].replace(url.file.cwd, '')), " at line ").concat(url.node.position.start.line);
        };

        // Create a promise array to allow all logs to happen at the same time.
        var resultPromises = [];
        var queueLength = urlQueue.length;
        for (var index = 0; index < queueLength; index += 1) {
          var url = urlQueue.shift();
          if (url.url.startsWith('/')) {
            // for relative urls check against the know list of valid relative urls.
            // Remove query params or hash links from the end of the url.
            var urlWithoutHash = url.url.replace(/[#?].*$/, '');
            if (!validRelativeUrls.includes(urlWithoutHash)) {
              resultPromises.push(Promise.resolve("".concat(chalk.red('[Broken Link]'), " ").concat(invalidUrlLog(url))));
            }
          } else if (url.url.startsWith('https')) {
            // required to not assume https urls are invalid.
            // We cannot validate engineering.cerner.com urls without additional work because they use the 404 status to redirect.
            // resultPromises.push(new Promise((resolve) => {
            //   https.get(url.url, (response) => {
            //     if (response.statusCode >= 400) {
            //       resolve( `${chalk.red('[Broken Link]')} ${chalk.blue(url.url)} in:\n ${chalk.yellow(url.file.history[0].replace(url.file.cwd, ''))} at line ${url.node.position.start.line}`);
            //     } else {
            //       resolve();
            //     }
            //   });
            // }));
          } else if (url.url.startsWith('http')) {
            // required to not assume http urls are invalid.
            // resultPromises.push(new Promise((resolve) => {
            //   http.get(url.url, (response) => {
            //     if (response.statusCode >= 400) {
            //       resolve(`${chalk.red('[Broken Link]')} ${chalk.blue(url.url)} in:\n ${chalk.yellow(url.file.history[0].replace(url.file.cwd, ''))} at line ${url.node.position.start.line}`);
            //     } else {
            //       resolve();
            //     }
            //   });
            // }));
          } else if (url.url.startsWith('#')) {
            // Assume anchors are fine.
            // We could check the document for an id to ensure the anchor link will take you somewhere but thats beyond the initial scope.
          } else if (url.url.startsWith('.')) {
            // To validate these we'd have to know the url for the current document. doable, but may need some duplicate logic.
          } else {
            // Catchall for oddball links, mailtos, and anything else unexpected.
            resultPromises.push(Promise.resolve("".concat(chalk.red('[Unexpected Link]'), " ").concat(invalidUrlLog(url))));
          }
        }
        // Resolve all promises and log results. this would matter more if we were verifying external urls.
        Promise.all(resultPromises).then(function (values) {
          values.forEach(function (value) {
            if (value) {
              logger.warn(value);
            }
          });
        });
      });
    }
  }], [{
    key: "applyOneTimeSetup",
    value: function applyOneTimeSetup(_ref2) {
      var compiler = _ref2.compiler,
        sourceFolder = _ref2.sourceFolder,
        distributionFolder = _ref2.distributionFolder,
        basename = _ref2.basename,
        isWebpack5 = _ref2.isWebpack5;
      if (oneTimeSetupComplete) {
        return;
      }
      oneTimeSetupComplete = true;
      var mdxLoader = getMdxLoader({
        publicPath: compiler.options.output.publicPath,
        urlInspectCallback: function urlInspectCallback(url) {
          // this callback notifies us of all the urls used in md or mdx files.
          urlQueue.push(url);
        }
      });

      // If a mono repo, update the rootDirectories to include all the packages.
      var rootDirectories = (0, _toConsumableArray2.default)(isLernaMonoRepo ? [path.resolve(processPath, 'packages', '*')] : [processPath]);
      var webpackConfig = {
        entry: {
          rewriteHistory: '@cerner/terra-dev-site/lib/browser-router-redirect/rewriteHistory',
          redirect: '@cerner/terra-dev-site/lib/browser-router-redirect/redirect'
        },
        module: {
          rules: [{
            // Drop loaders in a 'one of' block to avoid the original loaders applying on top of the new loaders.
            // Only the first loader will apply and no others.
            oneOf: [{
              test: /\.mdx$/,
              use: [babelLoader, mdxLoader]
            }, {
              test: /\.md$/,
              oneOf: [{
                // Use MDX to import any md files imported from an mdx file.
                issuer: [/\.mdx?$/, /entry\.template$/],
                use: [babelLoader, mdxLoader]
              }, {
                use: 'raw-loader'
              }]
            }, {
              resourceQuery: '?dev-site-codeblock',
              // this bypasses the default json loader
              type: 'javascript/auto',
              use: [babelLoader, mdxLoader, {
                loader: 'devSiteCodeblock',
                options: {
                  resolveExtensions: compiler.options.resolve.extensions
                }
              }]
            }, {
              resourceQuery: '?dev-site-example',
              use: [babelLoader, 'devSiteExample']
            }, {
              test: /\.json$/,
              // this bypasses the default json loader
              type: 'javascript/auto',
              resourceQuery: '?dev-site-package',
              use: [babelLoader, 'devSitePackage']
            }, {
              resourceQuery: '?dev-site-props-table',
              use: [babelLoader, mdxLoader, {
                loader: 'devSitePropsTable',
                options: {
                  resolveExtensions: compiler.options.resolve.extensions
                }
              }]
            }, {
              // This loader generates the entrypoint and sets up the config template path and resource query.
              resourceQuery: /\?terra-entry/,
              use: [babelLoader, {
                loader: 'devSiteEntry',
                options: {
                  entryLoaderData: entryLoaderData
                }
              }]
            }]
          }]
        },
        resolve: {
          plugins: [].concat((0, _toConsumableArray2.default)(compiler.options.mode !== 'production' && sourceFolder !== distributionFolder ? [
          // Switch between source and distribution files.
          new DirectorySwitcherPlugin({
            source: sourceFolder,
            distribution: distributionFolder,
            rootDirectories: rootDirectories
          })] : []), [
          // Alias the local package to allow imports to reference the file as if it was imported from node modules.
          new LocalPackageAliasPlugin({
            rootDirectories: rootDirectories
          })])
        },
        // add the path to search for dev site loaders
        resolveLoader: {
          modules: [path.resolve(__dirname, '..', 'loaders'), 'node_modules']
        },
        devServer: {
          // Setting this to enable browser routing
          historyApiFallback: true
        }
      };

      // If this plugin is used with webpack 5 we must normalize the webpack config.
      if (isWebpack5) {
        webpackConfig = compiler.webpack.config.getNormalizedWebpackOptions(webpackConfig);
      }

      // Remove once we no longer support webpack 4
      delete compiler.options.entry.terraDevSiteDummy;

      // ENTRY
      compiler.options.entry = _objectSpread(_objectSpread({}, compiler.options.entry), webpackConfig.entry);

      // MODULE
      webpackConfig.module.rules[0].oneOf = webpackConfig.module.rules[0].oneOf.concat(compiler.options.module.rules);
      compiler.options.module.rules = webpackConfig.module.rules;

      // RESOLVE
      compiler.options.resolve.plugins = (compiler.options.resolve.plugins || []).concat(webpackConfig.resolve.plugins);

      // RESOLVE LOADER
      compiler.options.resolveLoader.modules = webpackConfig.resolveLoader.modules;

      // generate the 404 page.
      new HtmlWebpackPlugin({
        filename: '404.html',
        template: path.join(__dirname, '..', 'templates', '404.html'),
        inject: 'head',
        chunks: ['redirect']
      }).apply(compiler);

      // WEBPACK DEV SERVER
      if (compiler.options.devServer) {
        // Setting this to enable browser routing
        compiler.options.devServer.historyApiFallback = webpackConfig.devServer.historyApiFallback;
      }
      new DefinePlugin({
        // Base name is used to namespace terra-dev-site this is used in redirect.js which is only used in the 404 page.
        TERRA_DEV_SITE_BASENAME: JSON.stringify(basename)
      }).apply(compiler);
    }
  }, {
    key: "getPublicPath",
    value: function getPublicPath(_ref3) {
      var compiler = _ref3.compiler;
      if (process.env.TERRA_DEV_SITE_PUBLIC_PATH) {
        compiler.options.output.publicPath = process.env.TERRA_DEV_SITE_PUBLIC_PATH;
        // if we don't have a default or the default is auto, set the public path to /;
      } else if (!compiler.options.output || !compiler.options.output.publicPath || compiler.options.output.publicPath === 'auto') {
        compiler.options.output.publicPath = '/';
      }
      return compiler.options.output.publicPath;
    }
  }]);
  return SitePlugin;
}();
module.exports = SitePlugin;