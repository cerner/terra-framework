"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var path = require('path');
var glob = require('glob');

/**
 * This plugin is intended to facilitate switching between a source directory
 * and a transpiled distribution directory.
 */
var DirectorySwitcherPlugin = /*#__PURE__*/function () {
  function DirectorySwitcherPlugin() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$shouldSwitch = _ref.shouldSwitch,
      shouldSwitch = _ref$shouldSwitch === void 0 ? true : _ref$shouldSwitch,
      _ref$source = _ref.source,
      source = _ref$source === void 0 ? 'src' : _ref$source,
      _ref$distribution = _ref.distribution,
      distribution = _ref$distribution === void 0 ? 'lib' : _ref$distribution,
      _ref$rootDirectories = _ref.rootDirectories,
      rootDirectories = _ref$rootDirectories === void 0 ? [process.cwd()] : _ref$rootDirectories;
    (0, _classCallCheck2.default)(this, DirectorySwitcherPlugin);
    this.shouldSwitch = shouldSwitch;
    this.dirs = rootDirectories.reduce(
    // expand glob for the source directory, if not found don't switch.
    function (acc, root) {
      return acc.concat(glob.sync(path.join(root, source)).map(function (sourcePath) {
        return {
          distribution: path.join(path.dirname(sourcePath), distribution),
          source: sourcePath
        };
      }));
    }, []);
    // Temporary https://github.com/webpack/enhanced-resolve/issues/200 or prop driven or just hard coded ¯\_(ツ)_/¯
    this.extensions = ['.js'];
  }
  (0, _createClass2.default)(DirectorySwitcherPlugin, [{
    key: "apply",
    value: function apply(resolver) {
      var _this = this;
      if (this.shouldSwitch) {
        var hook = resolver.ensureHook('described-relative');
        resolver.getHook('described-relative').tapAsync('MyResolverPlugin', function (request, resolveContext, callback) {
          // Look for paths starting with one of the paths to swap
          var index = _this.dirs.findIndex(function (pairs) {
            return request.path.startsWith(pairs.distribution);
          });
          if (index >= 0) {
            var _this$dirs$index = _this.dirs[index],
              distribution = _this$dirs$index.distribution,
              source = _this$dirs$index.source;
            // trim the request
            var remainingRequest = request.path.substring(distribution.length);

            // if the remaining request extension is one that is resolved, remove it. This allows .js files to resolve to .jsx files
            var extension = remainingRequest.substring(remainingRequest.lastIndexOf('.'));
            if (_this.extensions.includes(extension)) {
              remainingRequest = remainingRequest.replace(/\.[^/.]+$/, '');
            }
            var newPathStr = source + remainingRequest;
            var obj = _objectSpread(_objectSpread({}, request), {}, {
              path: newPathStr
            });
            // After changing the path call back into the same hook to continue resolution.
            return resolver.doResolve(hook, obj, "Switched ".concat(request.path, " to ").concat(obj.path), resolveContext, callback);
          }
          return callback();
        });
      }
    }
  }]);
  return DirectorySwitcherPlugin;
}();
module.exports = DirectorySwitcherPlugin;