"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _bind = _interopRequireDefault(require("classnames/bind"));
var KeyCode = _interopRequireWildcard(require("keycode-js"));
var _theme = require("terra-application/lib/theme");
var _CollapsingNavigationMenuItem = _interopRequireDefault(require("./CollapsingNavigationMenuItem"));
var _CollapsingNavigationMenuModule = _interopRequireDefault(require("./CollapsingNavigationMenu.module.scss"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var cx = _bind.default.bind(_CollapsingNavigationMenuModule.default);
var propTypes = {
  /**
   * A string id used to uniquely identify the Collapsing Navigation Menu and its
   * components in the DOM.
   */
  id: _propTypes.default.string.isRequired,
  /**
   * Currently selected path
   */
  selectedPath: _propTypes.default.string,
  /**
   * menu items to display.
   */
  // eslint-disable-next-line react/forbid-prop-types
  menuItems: _propTypes.default.any,
  /**
   * On select callback
   */
  onSelect: _propTypes.default.func.isRequired
};

/**
 * Returns a list of keys in the tree to 'open' that lead to the selected path.
 * @param {*} item the item to traverse
 * @param {*} selectedPath the currently selected path
 */
var keysToItem = function keysToItem(item, selectedPath) {
  var paths = [];
  if (item.childItems) {
    item.childItems.some(function (childItem) {
      if (selectedPath === childItem.path) {
        paths = [item.path];
        // if found bail early.
        return true;
      }
      var childPaths = keysToItem(childItem, selectedPath);
      if (childPaths.length > 0) {
        paths = childPaths.concat([item.path]);
        // if found bail early.
        return true;
      }
      return false;
    });
  }
  return paths;
};

/**
 * Returns an object containing the keys of the items to open to reveal the selected path in the tree.
 * @param {*} menuItems list of all menu items
 * @param {*} selectedPath the currently selected path
 */
var openKeysToItem = function openKeysToItem(menuItems, selectedPath) {
  return keysToItem(menuItems, selectedPath).reduce(function (acc, path) {
    acc[path] = true;
    return acc;
  }, {});
};
var CollapsingNavigationMenu = function CollapsingNavigationMenu(_ref) {
  var id = _ref.id,
    _ref$selectedPath = _ref.selectedPath,
    selectedPath = _ref$selectedPath === void 0 ? undefined : _ref$selectedPath,
    menuItems = _ref.menuItems,
    onSelect = _ref.onSelect;
  var containerRef = _react.default.useRef();
  var _useState = (0, _react.useState)(openKeysToItem(menuItems[0], selectedPath)),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    openKeys = _useState2[0],
    setOpenKeys = _useState2[1];
  var currentNodeId = (0, _react.useRef)();
  var cursor = (0, _react.useRef)(0);
  var selectedItem = (0, _react.useRef)();
  var previousSelectedPath = (0, _react.useRef)(selectedPath);
  var visibleNodes = [];
  var theme = _react.default.useContext(_theme.ThemeContext);

  /**
   * Sets tabindex for current node
   */
  var setTabIndex = function setTabIndex(val) {
    var currentNode = currentNodeId.current && containerRef.current ? containerRef.current.querySelector("#".concat(currentNodeId.current)) : null;
    if (currentNode) {
      currentNode.setAttribute('tabIndex', val);
    }
  };

  /**
   * Assigns focus to current node.
   */
  var focusCurrentNode = function focusCurrentNode() {
    var currentNode = currentNodeId.current && containerRef.current ? containerRef.current.querySelector("#".concat(currentNodeId.current)) : null;
    if (currentNode) {
      currentNode.focus();
    }
  };

  /**
   * Scrolls the currently selected menu item into view on mount.
   * Ensures that the cursor is synched with the currently selected item.
   */
  (0, _react.useEffect)(function () {
    var _selectedItem$current;
    var idx;
    var nodeId = (_selectedItem$current = selectedItem.current) === null || _selectedItem$current === void 0 ? void 0 : _selectedItem$current.getAttribute('id');
    if (!nodeId) {
      idx = 0;
    } else {
      idx = visibleNodes.findIndex(function (el) {
        return el.id === nodeId;
      });
    }
    if (idx >= 0) {
      cursor.current = idx;
      currentNodeId.current = visibleNodes[cursor.current].id;
      setTabIndex('0');
    }
    if (selectedItem && selectedItem.current) {
      selectedItem.current.scrollIntoView();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  (0, _react.useEffect)(function () {
    var _selectedItem$current2;
    var nodeId = (_selectedItem$current2 = selectedItem.current) === null || _selectedItem$current2 === void 0 ? void 0 : _selectedItem$current2.getAttribute('id');
    var idx = visibleNodes.findIndex(function (el) {
      return el.id === nodeId;
    });
    if (idx >= 0) {
      cursor.current = idx;
      currentNodeId.current = visibleNodes[cursor.current].id;
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedPath]);

  /**
   * Ensures that the cursor is synched with the currently selected item.
   * Scrolls selected item into view.
   */
  (0, _react.useEffect)(function () {
    if (currentNodeId.current) {
      cursor.current = visibleNodes.findIndex(function (el) {
        return el.id === currentNodeId.current;
      });
    }
    if (previousSelectedPath.current !== selectedPath) {
      var selectedItemPosition = selectedItem !== null && selectedItem !== void 0 && selectedItem.current ? selectedItem.current.getBoundingClientRect() : null;
      var navigationMenuPosition = containerRef.current.getBoundingClientRect();
      if (selectedItemPosition && navigationMenuPosition && (selectedItemPosition.bottom > navigationMenuPosition.bottom || selectedItemPosition.top < navigationMenuPosition.top)) {
        selectedItem.current.scrollIntoView();
      }
      previousSelectedPath.current = selectedPath;
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [openKeys]);

  /**
   * Ensures the parent of the currently selected item is expanded.
   */
  (0, _react.useEffect)(function () {
    setOpenKeys(_objectSpread(_objectSpread({}, openKeys), openKeysToItem(menuItems[0], selectedPath)));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedPath]);
  var handleOnClick = function handleOnClick(event, item) {
    // Don't update state if function is called through handleKeyDown
    if (event.type === 'click') {
      setTabIndex('-1');
      var eventTargetId = event.target.getAttribute('id');
      currentNodeId.current = eventTargetId;
      cursor.current = visibleNodes.findIndex(function (el) {
        return el.id === eventTargetId;
      });
      setTabIndex('0');
      focusCurrentNode();
    }
    if (!item.childItems) {
      onSelect(item.path);
      return;
    }
    setOpenKeys(_objectSpread(_objectSpread({}, openKeys), {}, (0, _defineProperty2.default)({}, item.path, !openKeys[item.path])));
  };
  var handleDownArrow = function handleDownArrow() {
    if (cursor.current + 1 < visibleNodes.length) {
      setTabIndex('-1');
      cursor.current += 1;
      currentNodeId.current = visibleNodes[cursor.current].id;
      setTabIndex('0');
      focusCurrentNode();
    }
  };
  var handleUpArrow = function handleUpArrow() {
    if (cursor.current >= 1) {
      setTabIndex('-1');
      cursor.current -= 1;
      currentNodeId.current = visibleNodes[cursor.current].id;
      setTabIndex('0');
      focusCurrentNode();
    }
  };

  /**
   * Finds parent of the current node, used for left arrow functionality
   */
  var findParentNode = function findParentNode() {
    if (!currentNodeId.current) {
      return;
    }
    var parentId = visibleNodes.find(function (el) {
      return el.id === currentNodeId.current;
    }).parent;
    if (parentId) {
      setTabIndex('-1');
      cursor.current = visibleNodes.findIndex(function (el) {
        return el.id === parentId;
      });
      currentNodeId.current = visibleNodes[cursor.current].id;
      setTabIndex('0');
      focusCurrentNode();
    }
  };

  /**
   * Finds the first node starting with the given character.
   * Starts at the cursors current position, and wraps around to the beginning of the menu if a match isn't found.
   * @param {*} char The character to search by
   */
  var findNodeMatching = function findNodeMatching(char) {
    var sortedNodes = visibleNodes.slice(cursor.current + 1, visibleNodes.length);
    sortedNodes = sortedNodes.concat(visibleNodes.slice(0, cursor.current));
    var match = sortedNodes.find(function (el) {
      return el.id[0].toUpperCase() === char;
    });
    if (match) {
      setTabIndex('-1');
      cursor.current = visibleNodes.findIndex(function (el) {
        return el.id === match.id;
      });
      currentNodeId.current = match.id;
      setTabIndex('0');
      focusCurrentNode();
    }
  };
  var handleKeyDown = function handleKeyDown(event, item) {
    var expandedValue;
    switch (event.nativeEvent.keyCode) {
      case KeyCode.KEY_SPACE:
      case KeyCode.KEY_RETURN:
        event.preventDefault();
        handleOnClick(event, item);
        break;
      case KeyCode.KEY_DOWN:
        event.preventDefault();
        handleDownArrow();
        break;
      case KeyCode.KEY_UP:
        event.preventDefault();
        handleUpArrow();
        break;
      case KeyCode.KEY_RIGHT:
        event.preventDefault();
        if (currentNodeId.current) {
          expandedValue = containerRef.current.querySelector("#".concat(currentNodeId.current)).getAttribute('aria-expanded');
          if (expandedValue) {
            if (expandedValue === 'true') {
              handleDownArrow();
            } else {
              handleOnClick(event, item);
            }
          }
        }
        break;
      case KeyCode.KEY_LEFT:
        event.preventDefault();
        if (currentNodeId.current) {
          expandedValue = containerRef.current.querySelector("#".concat(currentNodeId.current)).getAttribute('aria-expanded');
          if (expandedValue && expandedValue === 'true') {
            handleOnClick(event, item);
          } else {
            findParentNode();
          }
        }
        break;
      case KeyCode.KEY_HOME:
        event.preventDefault();
        setTabIndex('-1');
        cursor.current = 0;
        currentNodeId.current = visibleNodes[cursor.current].id;
        setTabIndex('0');
        focusCurrentNode();
        break;
      case KeyCode.KEY_END:
        event.preventDefault();
        setTabIndex('-1');
        cursor.current = visibleNodes.length - 1;
        currentNodeId.current = visibleNodes[cursor.current].id;
        setTabIndex('0');
        focusCurrentNode();
        break;
      default:
        if (event.nativeEvent.keyCode >= KeyCode.KEY_A && event.nativeEvent.keyCode <= KeyCode.KEY_Z) {
          event.preventDefault();
          var char = String.fromCharCode(event.nativeEvent.keyCode);
          findNodeMatching(char);
        }
        break;
    }
  };
  var renderMenuItems = function renderMenuItems(currentMenuItem) {
    var parentId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    var firstLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var indexPath = arguments.length > 3 ? arguments[3] : undefined;
    if (!currentMenuItem) {
      return undefined;
    }
    return currentMenuItem.map(function (item, index) {
      var currentPath;
      if (!indexPath) {
        currentPath = "idxPath-".concat(index);
      } else {
        currentPath = "".concat(indexPath, "-").concat(index);
      }
      var itemId = "".concat(id, "-").concat(currentPath);
      var itemIsOpen = !!openKeys[item.path];
      var isSelected = selectedPath === item.path;
      visibleNodes.push({
        id: itemId,
        parentId: parentId
      });
      return /*#__PURE__*/_react.default.createElement(_CollapsingNavigationMenuItem.default, {
        id: itemId,
        key: itemId,
        item: item,
        itemIsOpen: itemIsOpen,
        isSelected: isSelected,
        childItems: itemIsOpen ? renderMenuItems(item.childItems, itemId, false, currentPath) : null,
        firstLevel: firstLevel,
        handleKeyDown: handleKeyDown,
        handleOnClick: handleOnClick,
        ref: isSelected ? selectedItem : null
      });
    });
  };
  return /*#__PURE__*/_react.default.createElement("div", {
    ref: containerRef,
    className: cx('collapsing-navigation-menu', theme.className),
    id: "terra-dev-site-nav-menu",
    role: "tree"
  }, menuItems ? renderMenuItems(menuItems[0].childItems, '', true) : undefined);
};
CollapsingNavigationMenu.propTypes = propTypes;
var _default = CollapsingNavigationMenu;
exports.default = _default;