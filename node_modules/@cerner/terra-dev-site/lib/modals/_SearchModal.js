"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _reactRouterDom = require("react-router-dom");
var _disclosureManager = require("terra-application/lib/disclosure-manager");
var _terraContentContainer = _interopRequireDefault(require("terra-content-container"));
var _terraActionHeader = _interopRequireDefault(require("terra-action-header"));
var _bind = _interopRequireDefault(require("classnames/bind"));
var _terraList = _interopRequireWildcard(require("terra-list"));
var _terraSearchField = _interopRequireDefault(require("terra-search-field"));
var _theme = require("terra-application/lib/theme");
var _fuse = _interopRequireDefault(require("fuse.js"));
var _terraStatusView = _interopRequireDefault(require("terra-status-view"));
var _siteConfigShapes = require("../site/siteConfigShapes");
var _SearchModalModule = _interopRequireDefault(require("./SearchModal.module.scss"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var cx = _bind.default.bind(_SearchModalModule.default);
var propTypes = {
  /**
   * A map listing all the page routes to the page config
   */
  pageConfig: _siteConfigShapes.pageConfigShape.isRequired
};
var clearResults = function clearResults(setState) {
  return setState({
    results: []
  });
};
var handleSearch = function handleSearch(searchString, state, setState) {
  var options = {
    shouldSort: true,
    tokenize: true,
    includeMatches: true,
    threshold: 0.4,
    location: 0,
    distance: 100,
    maxPatternLength: 32,
    minMatchCharLength: 2,
    keys: ['title', 'tags']
  };
  var searchItems = state.searchItems;
  if (searchItems) {
    var fuse = new _fuse.default(searchItems, options); // "list" is the item array
    var results = fuse.search(searchString);
    setState({
      results: results,
      searchString: searchString,
      searchItems: searchItems
    });
  }
};
var highlight = function highlight(key, result) {
  // Filter the matches to only ones that match the key
  var valueArray = result.matches.filter(function (item) {
    return item.key === key;
  }).map(function (match) {
    var startIndex = 0;
    // Split the value string to have spans around the matching indices
    var splitString = match.indices.reduce(function (acc, index) {
      acc.push(match.value.slice(startIndex, index[0]));
      acc.push( /*#__PURE__*/_react.default.createElement("span", {
        key: index[0]
      }, match.value.slice(index[0], index[1] + 1)));
      startIndex = index[1] + 1;
      return acc;
    }, []);
    splitString.push(match.value.slice(startIndex));
    return splitString;
  });
  // The item has a match that should be highlighted
  if (valueArray.length === 1) {
    return valueArray[0];
  }
  // else return the item
  return result.item[key];
};
var searchItem = function searchItem(result) {
  return /*#__PURE__*/_react.default.createElement("div", {
    className: cx('item')
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: cx('title')
  }, highlight('title', result)), /*#__PURE__*/_react.default.createElement("div", {
    className: cx('path')
  }, highlight('path', result)));
};
var cacheSearchItems = function cacheSearchItems(pageConfig, state, setState) {
  if (!state.searchItems) {
    var searchItems = Object.entries(pageConfig).map(function (_ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];
      return {
        title: value.label,
        path: key,
        tags: key.split('/')
      };
    });
    var results = state.results,
      searchString = state.searchString;
    setState({
      results: results,
      searchString: searchString,
      searchItems: searchItems
    });
    handleSearch(searchString, state, setState);
  }
};
var SearchModal = function SearchModal(_ref3) {
  var pageConfig = _ref3.pageConfig;
  var _useState = (0, _react.useState)({
      results: []
    }),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    state = _useState2[0],
    setState = _useState2[1];
  var history = (0, _reactRouterDom.useHistory)();
  cacheSearchItems(pageConfig, state, setState);
  var searchItems = state.searchItems,
    searchString = state.searchString,
    results = state.results;
  var theme = _react.default.useContext(_theme.ThemeContext);
  var disclosureManager = _react.default.useContext(_disclosureManager.DisclosureManagerContext);
  var searchRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(function () {
    searchRef.focus();
  }, []);
  return /*#__PURE__*/_react.default.createElement(_terraContentContainer.default, {
    header: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_terraActionHeader.default, {
      title: "Site Search",
      onBack: disclosureManager.goBack,
      onClose: disclosureManager.closeDisclosure
    }), /*#__PURE__*/_react.default.createElement(_terraSearchField.default, {
      className: cx('search-field', theme.className),
      isBlock: true,
      placeholder: "Search",
      onSearch: function onSearch(string) {
        return handleSearch(string, state, setState);
      },
      onInvalidSearch: function onInvalidSearch() {
        return clearResults(setState);
      },
      inputRefCallback: function inputRefCallback(inputRef) {
        searchRef = inputRef;
      }
    })),
    fill: true
  }, searchItems && searchString && results.length <= 0 && /*#__PURE__*/_react.default.createElement(_terraStatusView.default, {
    variant: "no-matching-results"
  }), results.length > 0 && /*#__PURE__*/_react.default.createElement(_terraList.default, {
    dividerStyle: "standard",
    role: "listbox",
    "aria-label": "Search Results",
    className: cx(theme.className)
  }, state.results.slice(0, 25).map(function (result) {
    return /*#__PURE__*/_react.default.createElement(_terraList.Item, {
      key: result.item.path,
      id: result.item.path.replace(/\//g, '-'),
      isSelectable: true,
      metaData: result,
      onSelect: function onSelect(event, metaData) {
        disclosureManager.dismiss();
        history.push(metaData.item.path);
      }
    }, searchItem(result));
  })));
};
SearchModal.propTypes = propTypes;
var _default = SearchModal;
exports.default = _default;