{"version":3,"file":"findCurrentFiberUsingSlowPath.js","names":["findCurrentFiberUsingSlowPath","fiber","alternate","a","b","parentA","parentB","child","sibling","Error","didFindChild","stateNode","current","module","exports"],"sources":["../src/findCurrentFiberUsingSlowPath.js"],"sourcesContent":["// Extracted from https://github.com/facebook/react/blob/7bdf93b17a35a5d8fcf0ceae0bf48ed5e6b16688/src/renderers/shared/fiber/ReactFiberTreeReflection.js#L104-L228\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  const { alternate } = fiber;\n  if (!alternate) {\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  let a = fiber;\n  let b = alternate;\n  while (true) { // eslint-disable-line\n    const parentA = a.return;\n    const parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      let { child } = parentA;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      let didFindChild = false;\n      let { child } = parentA;\n      while (child) {\n        if (child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        child = child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        ({ child } = parentB);\n        while (child) {\n          if (child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          child = child.sibling;\n        }\n        if (!didFindChild) {\n          throw new Error('Child was not found in either parent set. This indicates a bug '\n            + 'in React related to the return pointer. Please file an issue.');\n        }\n      }\n    }\n  }\n  if (a.stateNode?.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nmodule.exports = findCurrentFiberUsingSlowPath;\n"],"mappings":";;AAAA;AACA,SAASA,6BAA6B,CAACC,KAAK,EAAE;EAAA;EAC5C,IAAQC,SAAS,GAAKD,KAAK,CAAnBC,SAAS;EACjB,IAAI,CAACA,SAAS,EAAE;IACd,OAAOD,KAAK;EACd;EACA;EACA;EACA;EACA,IAAIE,CAAC,GAAGF,KAAK;EACb,IAAIG,CAAC,GAAGF,SAAS;EACjB,OAAO,IAAI,EAAE;IAAE;IACb,IAAMG,OAAO,GAAGF,CAAC,UAAO;IACxB,IAAMG,OAAO,GAAGD,OAAO,GAAGA,OAAO,CAACH,SAAS,GAAG,IAAI;IAClD,IAAI,CAACG,OAAO,IAAI,CAACC,OAAO,EAAE;MACxB;MACA;IACF;;IAEA;IACA;IACA;IACA,IAAID,OAAO,CAACE,KAAK,KAAKD,OAAO,CAACC,KAAK,EAAE;MACnC,IAAMA,KAAK,GAAKF,OAAO,CAAjBE,KAAK;MACX,OAAOA,KAAK,EAAE;QACZ,IAAIA,KAAK,KAAKJ,CAAC,EAAE;UACf;UACA,OAAOF,KAAK;QACd;QACA,IAAIM,KAAK,KAAKH,CAAC,EAAE;UACf;UACA,OAAOF,SAAS;QAClB;QACAK,KAAK,GAAGA,KAAK,CAACC,OAAO;MACvB;MACA;MACA;MACA,MAAM,IAAIC,KAAK,CAAC,gDAAgD,CAAC;IACnE;IAEA,IAAIN,CAAC,UAAO,KAAKC,CAAC,UAAO,EAAE;MACzB;MACA;MACA;MACA;MACAD,CAAC,GAAGE,OAAO;MACXD,CAAC,GAAGE,OAAO;IACb,CAAC,MAAM;MACL;MACA;MACA;MACA;MACA;MACA,IAAII,YAAY,GAAG,KAAK;MACxB,IAAMH,MAAK,GAAKF,OAAO,CAAjBE,KAAK;MACX,OAAOA,MAAK,EAAE;QACZ,IAAIA,MAAK,KAAKJ,CAAC,EAAE;UACfO,YAAY,GAAG,IAAI;UACnBP,CAAC,GAAGE,OAAO;UACXD,CAAC,GAAGE,OAAO;UACX;QACF;QACA,IAAIC,MAAK,KAAKH,CAAC,EAAE;UACfM,YAAY,GAAG,IAAI;UACnBN,CAAC,GAAGC,OAAO;UACXF,CAAC,GAAGG,OAAO;UACX;QACF;QACAC,MAAK,GAAGA,MAAK,CAACC,OAAO;MACvB;MACA,IAAI,CAACE,YAAY,EAAE;QACjB;QACGH,MAAK,GAAKD,OAAO,CAAjBC,KAAK;QACR,OAAOA,MAAK,EAAE;UACZ,IAAIA,MAAK,KAAKJ,CAAC,EAAE;YACfO,YAAY,GAAG,IAAI;YACnBP,CAAC,GAAGG,OAAO;YACXF,CAAC,GAAGC,OAAO;YACX;UACF;UACA,IAAIE,MAAK,KAAKH,CAAC,EAAE;YACfM,YAAY,GAAG,IAAI;YACnBN,CAAC,GAAGE,OAAO;YACXH,CAAC,GAAGE,OAAO;YACX;UACF;UACAE,MAAK,GAAGA,MAAK,CAACC,OAAO;QACvB;QACA,IAAI,CAACE,YAAY,EAAE;UACjB,MAAM,IAAID,KAAK,CAAC,iEAAiE,GAC7E,+DAA+D,CAAC;QACtE;MACF;IACF;EACF;EACA,IAAI,iBAAAN,CAAC,CAACQ,SAAS,iDAAX,aAAaC,OAAO,MAAKT,CAAC,EAAE;IAC9B;IACA,OAAOF,KAAK;EACd;EACA;EACA,OAAOC,SAAS;AAClB;AAEAW,MAAM,CAACC,OAAO,GAAGd,6BAA6B"}