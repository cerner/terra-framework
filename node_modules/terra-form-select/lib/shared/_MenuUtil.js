"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireDefault(require("react"));
var _variants = _interopRequireDefault(require("./_variants"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var MenuUtil = /*#__PURE__*/function () {
  function MenuUtil() {
    _classCallCheck(this, MenuUtil);
  }
  _createClass(MenuUtil, null, [{
    key: "contains",
    value:
    /**
     * Determines if the query is contained within the string.
     * @param {string|undefined} string - The initial string.
     * @param {string|undefined} query - The value being searched for.
     * @return {boolean} - True if the string contains the query.
     */
    function contains() {
      var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      if (!string) {
        return false;
      }
      return string.toString().toLowerCase().indexOf(query.trim().toLowerCase()) > -1;
    }

    /**
     * Compares the value of two strings to determine case insensitive equality.
     * @param {string|undefined} a - The initial value to compare.
     * @param {string|undefined} b - The secondary value to compare.
     * @return {boolean} - True if the values are equal.
     */
  }, {
    key: "isEqual",
    value: function isEqual(a, b) {
      if (a === undefined || a === null || b === undefined || b === null) {
        return false;
      }
      return a.toString().toLowerCase() === b.toString().toLowerCase();
    }

    /**
     * Determines whether the variant allows multiple selections.
     * @param {string} variant - The variant.
     * @return {boolean} - True if the variant allows multiple selections.
     */
  }, {
    key: "allowsMultiSelections",
    value: function allowsMultiSelections(variant) {
      return variant === _variants.default.MULTIPLE || variant === _variants.default.TAG;
    }

    /**
     * Determines whether the provided option is selected.
     * @param {array|number|string} value - The select value.
     * @param {number|string} option - The option value.
     * @return {boolean} - True if the option is selected.
     */
  }, {
    key: "isSelected",
    value: function isSelected(value, option) {
      if (Array.isArray(value)) {
        return MenuUtil.includes(value, option);
      }
      return MenuUtil.isEqual(value, option);
    }

    /**
     * Determines if the query is contained within the array.
     * @param {array|undefined} array - The initial array.
     * @param {string|undefined} query - The value being searched for.
     * @return {boolean} - True if the query is contained within the array.
     */
  }, {
    key: "includes",
    value: function includes(array, query) {
      if (!array || !array.length) {
        return false;
      }
      return array.find(function (option) {
        return MenuUtil.isEqual(option, query);
      }) !== undefined;
    }

    /**
     * Flattens the available options. Ignores disabled options.
     * @param {ReactNode} object - The node being flattened.
     * @param {boolean} - Whether disabled props should be filtered out.
     * @return {array} - An array of available options.
     */
  }, {
    key: "flatten",
    value: function flatten(object, ignoreDisabled) {
      return _react.default.Children.toArray(object).reduce(function (accumulator, option) {
        if (option.type.isOption && (!ignoreDisabled || ignoreDisabled && !option.props.disabled)) {
          accumulator.push(option);
        } else if (option.type.isOptGroup) {
          return accumulator.concat(MenuUtil.flatten(option.props.children, ignoreDisabled));
        }
        return accumulator;
      }, []);
    }

    /**
     * Filters the object content by the search criteria.
     * @param {ReactNode} object - The node being filtered.
     * @param {string} searchValue - The value being searched for.
     * @param {function|undefined} optionFilter - An optional custom filter.
     * @return {array} - An array of filtered content.
     */
  }, {
    key: "filter",
    value: function filter(object, searchValue, optionFilter) {
      return _react.default.Children.toArray(object).reduce(function (accumulator, option) {
        if (option.type.isOption && MenuUtil.filterOption(option, searchValue, optionFilter)) {
          accumulator.push(option);
        } else if (option.type.isOptGroup) {
          var children = MenuUtil.filter(option.props.children, searchValue, optionFilter);
          // Ignore groups that do not contain any filtered options.
          if (children.length > 0) {
            accumulator.push( /*#__PURE__*/_react.default.cloneElement(option, {}, children));
          }
        }
        return accumulator;
      }, []);
    }

    /**
      * Determines if the option should be included in the filtered set.
      * @param {ReactNode} option - The option being filtered.
      * @param {function|undefined} optionFilter - A custom callback to filter against.
      * @return {boolean} - True if the option should be included in the fitlered set.
     */
  }, {
    key: "filterOption",
    value: function filterOption(option, searchValue, optionFilter) {
      if (optionFilter) {
        return optionFilter(searchValue, option);
      }
      return MenuUtil.contains(option.props.display, searchValue);
    }

    /**
     * Finds the option matching the requested value.
     * @param {ReactNode} object - The node being flattened.
     * @param {string} value - The value of the target option.
     * @return {ReactNode|undefined} - The option. Returns undefined if not found.
     */
  }, {
    key: "findByValue",
    value: function findByValue(object, value) {
      return MenuUtil.flatten(object).find(function (_ref) {
        var props = _ref.props;
        return MenuUtil.isEqual(props.value, value);
      });
    }

    /**
     * Finds the parent optGroup element matching the requested value.
     * @param {ReactNode} object - The node being searched.
     * @param {string} value - The value of the target option.
     * @return {ReactNode|undefined} - The optGroup. Returns undefined if not found.
     */
  }, {
    key: "getOptGroupElement",
    value: function getOptGroupElement(object, value) {
      return _react.default.Children.toArray(object).find(function (element) {
        return element.type.isOptGroup && _react.default.Children.toArray(element.props.children).find(function (chidleElement) {
          return chidleElement.props.value === value;
        });
      });
    }

    /**
     * Finds the option matching the requested display value.
     * @param {ReactNode} object - The node being flattened.
     * @param {string} value - The value of the target option.
     * @return {ReactNode|undefined} - The option. Returns undefined if not found.
     */
  }, {
    key: "findByDisplay",
    value: function findByDisplay(object, value) {
      return MenuUtil.flatten(object).find(function (_ref2) {
        var props = _ref2.props;
        return MenuUtil.isEqual(props.display, value);
      });
    }

    /**
     * Finds the first option in the menu.
     * @param {ReactNode} object - The menu.
     * @return {string|null} - The value of the first option. Null if not found.
     */
  }, {
    key: "findFirst",
    value: function findFirst(object) {
      var options = MenuUtil.flatten(object, true);
      if (options.length > 0) {
        return options[0].props.value;
      }
      return null;
    }

    /**
     * Finds the first option in the menu.
     * @param {ReactNode} object - The menu.
     * @return {string|null} - The value of the last option. Null if not found.
     */
  }, {
    key: "findLast",
    value: function findLast(object) {
      var options = MenuUtil.flatten(object, true);
      if (options.length > 0) {
        return options[options.length - 1].props.value;
      }
      return null;
    }

    /**
     * Finds the first option in the menu that starts with the string.
     * @param {ReactNode} object - The menu.
     * @param {string} string - The start string.
     * @return {string|null} - The firt option that starts with the provided string.
     */
  }, {
    key: "findWithStartString",
    value: function findWithStartString(object, string) {
      var option = MenuUtil.flatten(object, true).find(function (opt) {
        return (opt.props.display || '').toLowerCase().startsWith(string.toLowerCase());
      });
      return option ? option.props.value : null;
    }

    /**
     * Finds the option following the active option.
     * @param {ReactNode} object - The node being flattened.
     * @param {string} value - The value of the active option.
     * @return {string|null} - The value of the next option. Returns null if not found.
     */
  }, {
    key: "findNext",
    value: function findNext(object, value) {
      var options = MenuUtil.flatten(object, true);
      var index = options.findIndex(function (_ref3) {
        var props = _ref3.props;
        return MenuUtil.isEqual(props.value, value);
      });
      return index === -1 ? null : options[Math.min(index + 1, options.length - 1)].props.value;
    }

    /**
     * Finds the index of option following the active option.
     * @param {ReactNode} object - The node being flattened.
     * @param {string} value - The value of the active option.
     * @return {integer} - The value of the index of option.
     */
  }, {
    key: "getIndex",
    value: function getIndex(object, value) {
      var options = MenuUtil.flatten(object, true);
      var index = options.findIndex(function (_ref4) {
        var props = _ref4.props;
        return MenuUtil.isEqual(props.value, value);
      });
      return index + 1;
    }

    /**
     * Finds the option preceding the active option.
     * @param {ReactNode} object - The node being flattened.
     * @param {string} value - The value of the active option.
     * @return {string|null} - The value of the previous option. Returns null if not found.
     */
  }, {
    key: "findPrevious",
    value: function findPrevious(object, value) {
      var options = MenuUtil.flatten(object, true);
      var index = options.findIndex(function (_ref5) {
        var props = _ref5.props;
        return MenuUtil.isEqual(props.value, value);
      });
      return index === -1 ? null : options[Math.max(index - 1, 0)].props.value;
    }

    /**
     * Determines the appropriate active option.
     * @param {Object} props - The menu props.
     * @param {array} children - The menu children.
     * @param {Object} state - The menu state.
     * @return {string|null} - The active option value. Null if not found.
     */
  }, {
    key: "getActiveOptionFromProps",
    value: function getActiveOptionFromProps(props, children, state) {
      var active = state.active;
      var searchValue = props.searchValue,
        value = props.value;
      var options = MenuUtil.flatten(children, true);
      if (options.length === 0) {
        return null;
      }
      if (active !== null && MenuUtil.findByValue(options, active)) {
        return active;
      }
      if (state.searchValue === undefined) {
        var selected = options.find(function (option) {
          return Array.isArray(value) ? MenuUtil.includes(value, option.props.value) : MenuUtil.isEqual(value, option.props.value);
        });
        return selected === undefined ? options[0].props.value : selected.props.value;
      }
      if (searchValue !== state.searchValue) {
        return options[0].props.value;
      }
      return options[0].props.value;
    }

    /**
     * Determines if the menu should allow a free text entry.
     * @param {Object} props - The menu props.
     * @param {array} children - The menu children.
     * @return {boolean} - True if a free text entry is allowed.
     */
  }, {
    key: "shouldAllowFreeText",
    value: function shouldAllowFreeText(props, children) {
      var searchValue = props.searchValue,
        value = props.value,
        variant = props.variant;
      if (variant === _variants.default.TAG || variant === _variants.default.COMBOBOX) {
        var option = MenuUtil.findByDisplay(children, searchValue);
        var included = Array.isArray(value) ? MenuUtil.includes(value, searchValue) : MenuUtil.isEqual(value, searchValue);
        return !option && !included && (searchValue || '').trim().length > 0;
      }
      return false;
    }

    /**
     * Determines if the menu should show the no results content.
     * @param {Object} props - The menu props.
     * @param {array} children - The menu children.
     * @return {boolean} - True if the no results content should show.
     */
  }, {
    key: "shouldShowNoResults",
    value: function shouldShowNoResults(props, children) {
      var variant = props.variant;
      if (variant !== _variants.default.TAG && variant !== _variants.default.COMBOBOX) {
        return children.length === 0;
      }
      return false;
    }

    /**
     * Determines if the number of selected items has reached the maximum.
     * @param {Object} props - The menu props.
     * @return {boolean} - True if the maximum selection count has reached.
     */
  }, {
    key: "isMaxSelectionReached",
    value: function isMaxSelectionReached(props) {
      var maxSelectionCount = props.maxSelectionCount,
        value = props.value,
        variant = props.variant;
      if (maxSelectionCount !== undefined && MenuUtil.allowsMultiSelections(variant) && Array.isArray(value) && value.length >= maxSelectionCount) {
        return true;
      }
      return false;
    }

    /**
     * Updates the selection state of the all the options in the menu.
     * @param {ReactNode} object - The node being updated.
     * @param {Object} props - The menu props.
     * @return {array} - A cloned copy of the object with the selection state updated.
     */
  }, {
    key: "updateSelectionState",
    value: function updateSelectionState(object, props) {
      var maxSelectionCountReached = MenuUtil.isMaxSelectionReached(props);
      return _react.default.Children.map(object, function (child) {
        if (child.type.isOption) {
          return /*#__PURE__*/_react.default.cloneElement(child, {
            disabled: child.props.disabled || maxSelectionCountReached && !MenuUtil.isSelected(props.value, child.props.value)
          });
        }
        if (child.type.isOptGroup) {
          return /*#__PURE__*/_react.default.cloneElement(child, {}, MenuUtil.updateSelectionState(child.props.children, props));
        }
        return child;
      });
    }

    /**
     * Determines if the menu should show an option to clear the selected result.
     * @param {Object} props - The menu props.
     * @param {boolean} hasAddOption - Indicates if the Add Option is shown in the menu.
     * @param {boolean} hasNoResults - Indicates if the No Results content is shown in the menu.
     * @return {boolean} - True if the clear option should show.
     */
  }, {
    key: "shouldShowClearOption",
    value: function shouldShowClearOption(_ref6) {
      var clearOptionDisplay = _ref6.clearOptionDisplay,
        searchValue = _ref6.searchValue,
        hasAddOption = _ref6.hasAddOption,
        hasNoResults = _ref6.hasNoResults;
      if (clearOptionDisplay && !hasNoResults && !hasAddOption && (searchValue === undefined || searchValue.length === 0)) {
        return true;
      }
      return false;
    }
  }]);
  return MenuUtil;
}();
var _default = MenuUtil;
exports.default = _default;