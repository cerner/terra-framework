var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// libs/core/src/lib/collect-uncommitted.ts
function collectUncommitted({ cwd, log: log36 = import_npmlog.default }) {
  log36.silly("collect-uncommitted", "git status --porcelain (async)");
  return childProcess.exec("git", ["status", "--porcelain"], { cwd }).then(({ stdout }) => transformOutput(stdout));
}
var import_chalk, import_npmlog, childProcess, maybeColorize, cRed, cGreen, replaceStatus, colorizeStats, splitOnNewLine, filterEmpty, o, transformOutput;
var init_collect_uncommitted = __esm({
  "libs/core/src/lib/collect-uncommitted.ts"() {
    import_chalk = __toESM(require("chalk"));
    import_npmlog = __toESM(require("npmlog"));
    childProcess = require("@lerna/child-process");
    maybeColorize = (colorize) => (s) => s !== " " ? colorize(s) : s;
    cRed = maybeColorize(import_chalk.default.red);
    cGreen = maybeColorize(import_chalk.default.green);
    replaceStatus = (_, maybeGreen, maybeRed) => `${cGreen(maybeGreen)}${cRed(maybeRed)}`;
    colorizeStats = (stats) => stats.replace(/^([^U]| )([A-Z]| )/gm, replaceStatus).replace(/^\?{2}|U{2}/gm, cRed("$&"));
    splitOnNewLine = (str) => str.split("\n");
    filterEmpty = (lines) => lines.filter((line) => line.length);
    o = (l, r) => (x) => l(r(x));
    transformOutput = o(filterEmpty, o(splitOnNewLine, colorizeStats));
  }
});

// libs/core/src/lib/describe-ref.ts
var import_npmlog2, childProcess2;
var init_describe_ref = __esm({
  "libs/core/src/lib/describe-ref.ts"() {
    import_npmlog2 = __toESM(require("npmlog"));
    childProcess2 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/validation-error.ts
var import_npmlog3, ValidationError;
var init_validation_error = __esm({
  "libs/core/src/lib/validation-error.ts"() {
    import_npmlog3 = __toESM(require("npmlog"));
    ValidationError = class extends Error {
      prefix;
      constructor(prefix, message, ...rest) {
        super(message);
        this.name = "ValidationError";
        this.prefix = prefix;
        import_npmlog3.default.resume();
        import_npmlog3.default.error(prefix, message, ...rest);
      }
    };
  }
});

// libs/core/src/lib/check-working-tree.ts
function mkThrowIfUncommitted(options = {}) {
  return function throwIfUncommitted2({ isDirty }) {
    if (isDirty) {
      return collectUncommitted(options).then((uncommitted) => {
        throw new ValidationError("EUNCOMMIT", `${EUNCOMMIT_MSG}${uncommitted.join("\n")}`);
      });
    }
  };
}
var EUNCOMMIT_MSG, throwIfUncommitted;
var init_check_working_tree = __esm({
  "libs/core/src/lib/check-working-tree.ts"() {
    init_collect_uncommitted();
    init_describe_ref();
    init_validation_error();
    EUNCOMMIT_MSG = "Working tree has uncommitted changes, please commit or remove the following changes before continuing:\n";
    throwIfUncommitted = mkThrowIfUncommitted();
  }
});

// libs/core/src/lib/cli.ts
var import_dedent, import_npmlog4, import_yargs;
var init_cli = __esm({
  "libs/core/src/lib/cli.ts"() {
    import_dedent = __toESM(require("dedent"));
    import_npmlog4 = __toESM(require("npmlog"));
    import_yargs = __toESM(require("yargs/yargs"));
  }
});

// libs/core/src/lib/collect-updates/collect-dependents.ts
var init_collect_dependents = __esm({
  "libs/core/src/lib/collect-updates/collect-dependents.ts"() {
  }
});

// libs/core/src/lib/collect-updates/collect-packages.ts
var init_collect_packages = __esm({
  "libs/core/src/lib/collect-updates/collect-packages.ts"() {
    init_collect_dependents();
  }
});

// libs/core/src/lib/collect-updates/get-packages-for-option.ts
var init_get_packages_for_option = __esm({
  "libs/core/src/lib/collect-updates/get-packages-for-option.ts"() {
  }
});

// libs/core/src/lib/collect-updates/has-tags.ts
var import_npmlog5, childProcess3;
var init_has_tags = __esm({
  "libs/core/src/lib/collect-updates/has-tags.ts"() {
    import_npmlog5 = __toESM(require("npmlog"));
    childProcess3 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/collect-updates/make-diff-predicate.ts
var import_npmlog6, import_minimatch, import_slash, childProcess4;
var init_make_diff_predicate = __esm({
  "libs/core/src/lib/collect-updates/make-diff-predicate.ts"() {
    import_npmlog6 = __toESM(require("npmlog"));
    import_minimatch = __toESM(require("minimatch"));
    import_slash = __toESM(require("slash"));
    childProcess4 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/collect-updates/index.ts
var import_npmlog7;
var init_collect_updates = __esm({
  "libs/core/src/lib/collect-updates/index.ts"() {
    import_npmlog7 = __toESM(require("npmlog"));
    init_describe_ref();
    init_collect_packages();
    init_get_packages_for_option();
    init_has_tags();
    init_make_diff_predicate();
  }
});

// libs/core/src/lib/package-graph/cyclic-package-graph-node.ts
var lastCollapsedNodeId, CyclicPackageGraphNode;
var init_cyclic_package_graph_node = __esm({
  "libs/core/src/lib/package-graph/cyclic-package-graph-node.ts"() {
    lastCollapsedNodeId = 0;
    CyclicPackageGraphNode = class extends Map {
      name;
      localDependencies;
      localDependents;
      constructor() {
        super();
        this.name = `(cycle) ${lastCollapsedNodeId += 1}`;
        this.localDependencies = /* @__PURE__ */ new Map();
        this.localDependents = /* @__PURE__ */ new Map();
      }
      get isCycle() {
        return true;
      }
      toString() {
        const parts = Array.from(
          this,
          ([key, node]) => node.isCycle ? `(nested cycle: ${node.toString()})` : key
        );
        parts.push(parts[0]);
        return parts.reverse().join(" -> ");
      }
      flatten() {
        const result = [];
        for (const node of this.values()) {
          if (node.isCycle) {
            result.push(...node.flatten());
          } else {
            result.push(node);
          }
        }
        return result;
      }
      contains(name) {
        for (const [currentName, currentNode] of this) {
          if (currentNode.isCycle) {
            if (currentNode.contains(name)) {
              return true;
            }
          } else if (currentName === name) {
            return true;
          }
        }
        return false;
      }
      insert(node) {
        this.set(node.name, node);
        this.unlink(node);
        for (const [dependencyName, dependencyNode] of node.localDependencies) {
          if (!this.contains(dependencyName)) {
            this.localDependencies.set(dependencyName, dependencyNode);
          }
        }
        for (const [dependentName, dependentNode] of node.localDependents) {
          if (!this.contains(dependentName)) {
            this.localDependents.set(dependentName, dependentNode);
          }
        }
      }
      unlink(candidateNode) {
        this.localDependencies.delete(candidateNode.name);
        this.localDependents.delete(candidateNode.name);
      }
    };
  }
});

// libs/core/src/lib/prerelease-id-from-version.ts
function prereleaseIdFromVersion(version) {
  return (import_semver.default.prerelease(version) || []).shift();
}
var import_semver;
var init_prerelease_id_from_version = __esm({
  "libs/core/src/lib/prerelease-id-from-version.ts"() {
    import_semver = __toESM(require("semver"));
  }
});

// libs/core/src/lib/package-graph/package-graph-node.ts
var import_semver2, PKG, PackageGraphNode;
var init_package_graph_node = __esm({
  "libs/core/src/lib/package-graph/package-graph-node.ts"() {
    import_semver2 = __toESM(require("semver"));
    init_prerelease_id_from_version();
    PKG = Symbol("pkg");
    PackageGraphNode = class {
      name;
      externalDependencies;
      localDependencies;
      localDependents;
      [PKG];
      constructor(pkg) {
        this.name = pkg.name;
        this[PKG] = pkg;
        Object.defineProperty(this, PKG, { enumerable: false });
        this.externalDependencies = /* @__PURE__ */ new Map();
        this.localDependencies = /* @__PURE__ */ new Map();
        this.localDependents = /* @__PURE__ */ new Map();
      }
      get location() {
        return this[PKG].location;
      }
      get pkg() {
        return this[PKG];
      }
      get prereleaseId() {
        return prereleaseIdFromVersion(this.version);
      }
      get version() {
        return this[PKG].version;
      }
      satisfies({ gitCommittish, gitRange, fetchSpec }) {
        return import_semver2.default.satisfies(this.version, gitCommittish || gitRange || fetchSpec);
      }
      toString() {
        return this.name;
      }
    };
  }
});

// libs/core/src/lib/package-graph/report-cycles.ts
function reportCycles(paths, rejectCycles) {
  if (!paths.length) {
    return;
  }
  const cycleMessage = ["Dependency cycles detected, you should fix these!"].concat(paths).join("\n");
  if (rejectCycles) {
    throw new ValidationError("ECYCLE", cycleMessage);
  }
  import_npmlog8.default.warn("ECYCLE", cycleMessage);
}
var import_npmlog8;
var init_report_cycles = __esm({
  "libs/core/src/lib/package-graph/report-cycles.ts"() {
    import_npmlog8 = __toESM(require("npmlog"));
    init_validation_error();
  }
});

// libs/core/src/lib/package-graph/index.ts
var import_npm_package_arg, PackageGraph;
var init_package_graph = __esm({
  "libs/core/src/lib/package-graph/index.ts"() {
    import_npm_package_arg = __toESM(require("npm-package-arg"));
    init_validation_error();
    init_cyclic_package_graph_node();
    init_package_graph_node();
    init_report_cycles();
    PackageGraph = class extends Map {
      constructor(packages, graphType = "allDependencies", forceLocal) {
        super(packages.map((pkg) => [pkg.name, new PackageGraphNode(pkg)]));
        if (packages.length !== this.size) {
          const seen = /* @__PURE__ */ new Map();
          for (const { name, location } of packages) {
            if (seen.has(name)) {
              seen.get(name).push(location);
            } else {
              seen.set(name, [location]);
            }
          }
          for (const [name, locations] of seen) {
            if (locations.length > 1) {
              throw new ValidationError(
                "ENAME",
                [`Package name "${name}" used in multiple packages:`, ...locations].join("\n	")
              );
            }
          }
        }
        this.forEach((currentNode, currentName) => {
          const graphDependencies = graphType === "dependencies" ? Object.assign({}, currentNode.pkg.optionalDependencies, currentNode.pkg.dependencies) : Object.assign(
            {},
            currentNode.pkg.devDependencies,
            currentNode.pkg.optionalDependencies,
            currentNode.pkg.dependencies
          );
          Object.keys(graphDependencies).forEach((depName) => {
            const depNode = this.get(depName);
            let spec = graphDependencies[depName].replace(/^link:/, "file:");
            const isWorkspaceSpec = /^workspace:/.test(spec);
            let fullWorkspaceSpec;
            let workspaceAlias;
            if (isWorkspaceSpec) {
              fullWorkspaceSpec = spec;
              spec = spec.replace(/^workspace:/, "");
              if (spec === "*" || spec === "^" || spec === "~") {
                workspaceAlias = spec;
                if (depNode?.version) {
                  const prefix = spec === "*" ? "" : spec;
                  const version = depNode.version;
                  spec = `${prefix}${version}`;
                } else {
                  spec = "*";
                }
              }
            }
            const resolved = import_npm_package_arg.default.resolve(depName, spec, currentNode.location);
            resolved.workspaceSpec = fullWorkspaceSpec;
            resolved.workspaceAlias = workspaceAlias;
            if (!depNode) {
              return currentNode.externalDependencies.set(depName, resolved);
            }
            if (forceLocal || resolved.fetchSpec === depNode.location || depNode.satisfies(resolved)) {
              currentNode.localDependencies.set(depName, resolved);
              depNode.localDependents.set(currentName, currentNode);
            } else {
              if (isWorkspaceSpec) {
                throw new ValidationError(
                  "EWORKSPACE",
                  `Package specification "${depName}@${spec}" could not be resolved within the workspace. To reference a non-matching, remote version of a local dependency, remove the 'workspace:' prefix.`
                );
              }
              currentNode.externalDependencies.set(depName, resolved);
            }
          });
        });
      }
      get rawPackageList() {
        return Array.from(this.values()).map((node) => node.pkg);
      }
      addDependencies(filteredPackages) {
        return this.extendList(filteredPackages, "localDependencies");
      }
      addDependents(filteredPackages) {
        return this.extendList(filteredPackages, "localDependents");
      }
      extendList(packageList, nodeProp) {
        const search = new Set(packageList.map(({ name }) => this.get(name)));
        const result = [];
        search.forEach((currentNode) => {
          result.push(currentNode);
          currentNode[nodeProp].forEach((meta, depName) => {
            const depNode = this.get(depName);
            if (depNode !== currentNode && !search.has(depNode)) {
              search.add(depNode);
            }
          });
        });
        return result.map((node) => node.pkg);
      }
      partitionCycles(rejectCycles) {
        const cyclePaths = /* @__PURE__ */ new Set();
        const cycleNodes = /* @__PURE__ */ new Set();
        this.forEach((currentNode, currentName) => {
          const seen = /* @__PURE__ */ new Set();
          const visits = (walk) => (dependentNode, dependentName, siblingDependents) => {
            const step = walk.concat(dependentName);
            if (seen.has(dependentNode)) {
              return;
            }
            seen.add(dependentNode);
            if (dependentNode === currentNode) {
              cycleNodes.add(currentNode);
              cyclePaths.add(step);
              return;
            }
            if (siblingDependents.has(currentName)) {
              const cycleDependentName = Array.from(dependentNode.localDependencies.keys()).find(
                (key) => currentNode.localDependents.has(key)
              );
              const pathToCycle = step.slice().reverse().concat(cycleDependentName);
              cycleNodes.add(dependentNode);
              cyclePaths.add(pathToCycle);
            }
            dependentNode.localDependents.forEach(visits(step));
          };
          currentNode.localDependents.forEach(visits([currentName]));
        });
        reportCycles(
          Array.from(cyclePaths, (cycle) => cycle.join(" -> ")),
          rejectCycles
        );
        return [cyclePaths, cycleNodes];
      }
      collapseCycles(rejectCycles) {
        const cyclePaths = [];
        const nodeToCycle = /* @__PURE__ */ new Map();
        const cycles = /* @__PURE__ */ new Set();
        const walkStack = [];
        const alreadyVisited = /* @__PURE__ */ new Set();
        function visits(baseNode, dependentNode) {
          if (nodeToCycle.has(baseNode)) {
            return;
          }
          let topLevelDependent = dependentNode;
          while (nodeToCycle.has(topLevelDependent)) {
            topLevelDependent = nodeToCycle.get(topLevelDependent);
          }
          const identifier = `${baseNode.name}:${topLevelDependent.name}`;
          if (alreadyVisited.has(identifier)) {
            return;
          }
          alreadyVisited.add(identifier);
          if (topLevelDependent === baseNode || topLevelDependent.isCycle && topLevelDependent.has(baseNode.name)) {
            const cycle = new CyclicPackageGraphNode();
            walkStack.forEach((nodeInCycle) => {
              nodeToCycle.set(nodeInCycle, cycle);
              cycle.insert(nodeInCycle);
              cycles.delete(nodeInCycle);
            });
            cycles.add(cycle);
            cyclePaths.push(cycle.toString());
            return;
          }
          if (walkStack.indexOf(topLevelDependent) === -1) {
            visitWithStack(baseNode, topLevelDependent);
          }
        }
        function visitWithStack(baseNode, currentNode = baseNode) {
          walkStack.push(currentNode);
          currentNode.localDependents.forEach(visits.bind(null, baseNode));
          walkStack.pop();
        }
        this.forEach((currentNode) => visitWithStack(currentNode));
        cycles.forEach((collapsedNode) => visitWithStack(collapsedNode));
        reportCycles(cyclePaths, rejectCycles);
        return cycles;
      }
      pruneCycleNodes(cycleNodes) {
        return this.prune(...cycleNodes);
      }
      prune(...candidates) {
        if (candidates.length === this.size) {
          return this.clear();
        }
        candidates.forEach((node) => this.remove(node));
      }
      remove(candidateNode) {
        this.delete(candidateNode.name);
        this.forEach((node) => {
          node.localDependencies.delete(candidateNode.name);
          node.localDependents.delete(candidateNode.name);
        });
      }
    };
  }
});

// libs/core/src/lib/package.ts
function binSafeName({ name, scope }) {
  return scope ? name.substring(scope.length + 1) : name;
}
function shallowCopy(json) {
  return Object.keys(json).reduce((obj, key) => {
    const val = json[key];
    if (Array.isArray(val)) {
      obj[key] = val.slice();
    } else if (val && typeof val === "object") {
      obj[key] = Object.assign({}, val);
    } else {
      obj[key] = val;
    }
    return obj;
  }, {});
}
var import_load_json_file, import_npm_package_arg2, import_path, import_write_pkg, PKG2, _location, _resolved, _rootPath, _scripts, _contents, Package;
var init_package = __esm({
  "libs/core/src/lib/package.ts"() {
    import_load_json_file = __toESM(require("load-json-file"));
    import_npm_package_arg2 = __toESM(require("npm-package-arg"));
    import_path = __toESM(require("path"));
    import_write_pkg = __toESM(require("write-pkg"));
    PKG2 = Symbol("pkg");
    _location = Symbol("location");
    _resolved = Symbol("resolved");
    _rootPath = Symbol("rootPath");
    _scripts = Symbol("scripts");
    _contents = Symbol("contents");
    Package = class {
      name;
      [PKG2];
      [_location];
      [_resolved];
      [_rootPath];
      [_scripts];
      [_contents];
      static lazy(ref, dir = ".") {
        if (typeof ref === "string") {
          const location = import_path.default.resolve(import_path.default.basename(ref) === "package.json" ? import_path.default.dirname(ref) : ref);
          const manifest = import_load_json_file.default.sync(import_path.default.join(location, "package.json"));
          return new Package(manifest, location);
        }
        if ("__isLernaPackage" in ref) {
          return ref;
        }
        return new Package(ref, dir);
      }
      constructor(pkg, location, rootPath = location) {
        const resolved = import_npm_package_arg2.default.resolve(pkg.name, `file:${import_path.default.relative(rootPath, location)}`, rootPath);
        this.name = pkg.name;
        this[PKG2] = pkg;
        Object.defineProperty(this, PKG2, { enumerable: false, writable: true });
        this[_location] = location;
        this[_resolved] = resolved;
        this[_rootPath] = rootPath;
        this[_scripts] = { ...pkg.scripts };
      }
      get location() {
        return this[_location];
      }
      get private() {
        return Boolean(this[PKG2].private);
      }
      set private(isPrivate) {
        this[PKG2].private = isPrivate;
      }
      get resolved() {
        return this[_resolved];
      }
      get rootPath() {
        return this[_rootPath];
      }
      get scripts() {
        return this[_scripts];
      }
      get bin() {
        const pkg = this[PKG2];
        return typeof pkg.bin === "string" ? {
          [binSafeName(this.resolved)]: pkg.bin
        } : Object.assign({}, pkg.bin);
      }
      get binLocation() {
        return import_path.default.join(this.location, "node_modules", ".bin");
      }
      get manifestLocation() {
        return import_path.default.join(this.location, "package.json");
      }
      get nodeModulesLocation() {
        return import_path.default.join(this.location, "node_modules");
      }
      get __isLernaPackage() {
        return true;
      }
      get version() {
        return this[PKG2].version;
      }
      set version(version) {
        this[PKG2].version = version;
      }
      get contents() {
        if (this[_contents]) {
          return this[_contents];
        }
        if (this[PKG2].publishConfig && this[PKG2].publishConfig.directory) {
          return import_path.default.join(this.location, this[PKG2].publishConfig.directory);
        }
        return this.location;
      }
      set contents(subDirectory) {
        this[_contents] = import_path.default.join(this.location, subDirectory);
      }
      get dependencies() {
        return this[PKG2].dependencies;
      }
      get devDependencies() {
        return this[PKG2].devDependencies;
      }
      get optionalDependencies() {
        return this[PKG2].optionalDependencies;
      }
      get peerDependencies() {
        return this[PKG2].peerDependencies;
      }
      get(key) {
        return this[PKG2][key];
      }
      set(key, val) {
        this[PKG2][key] = val;
        return this;
      }
      toJSON() {
        return shallowCopy(this[PKG2]);
      }
      refresh() {
        return (0, import_load_json_file.default)(this.manifestLocation).then((pkg) => {
          this[PKG2] = pkg;
          return this;
        });
      }
      serialize() {
        return (0, import_write_pkg.default)(this.manifestLocation, this[PKG2]).then(() => this);
      }
      updateLocalDependency(resolved, depVersion, savePrefix, options = { retainWorkspacePrefix: true }) {
        const depName = resolved.name;
        let depCollection = this.dependencies;
        if (!depCollection || !depCollection[depName]) {
          depCollection = this.optionalDependencies;
        }
        if (!depCollection || !depCollection[depName]) {
          depCollection = this.devDependencies;
        }
        if (resolved.workspaceSpec && options.retainWorkspacePrefix) {
          if (!resolved.workspaceAlias) {
            const workspacePrefix = resolved.workspaceSpec.match(/^(workspace:[*~^]?)/)[0];
            depCollection[depName] = `${workspacePrefix}${depVersion}`;
          }
        } else if (resolved.registry || resolved.type === "directory") {
          depCollection[depName] = `${savePrefix}${depVersion}`;
        } else if (resolved.gitCommittish) {
          const [tagPrefix] = /^\D*/.exec(resolved.gitCommittish);
          const { hosted } = resolved;
          hosted.committish = `${tagPrefix}${depVersion}`;
          depCollection[depName] = hosted.toString({ noGitPlus: false, noCommittish: false });
        } else if (resolved.gitRange) {
          const { hosted } = resolved;
          hosted.committish = `semver:${savePrefix}${depVersion}`;
          depCollection[depName] = hosted.toString({ noGitPlus: false, noCommittish: false });
        }
      }
      removePrivate() {
        delete this[PKG2].private;
      }
    };
  }
});

// libs/core/src/lib/project/deprecate-config.ts
function remap(search, target, { alsoRoot, toValue } = {}) {
  const pathsToSearch = [search];
  if (alsoRoot) {
    pathsToSearch.unshift(search.split(".").pop());
  }
  return (obj) => {
    for (const searchPath of pathsToSearch) {
      if (import_dot_prop.default.has(obj.config, searchPath)) {
        const fromVal = import_dot_prop.default.get(obj.config, searchPath);
        const toVal = toValue ? toValue(fromVal) : fromVal;
        import_npmlog9.default.warn("project", deprecationMessage(obj, target, searchPath, fromVal, toVal));
        import_dot_prop.default.set(obj.config, target, toVal);
        import_dot_prop.default.delete(obj.config, searchPath);
      }
    }
    return obj;
  };
}
function deprecationMessage(obj, target, searchPath, fromVal, toVal) {
  const localPath = import_path2.default.relative(".", obj.filepath);
  let from;
  let to;
  if (toVal === fromVal) {
    from = `"${searchPath}"`;
    to = `"${target}"`;
  } else {
    from = stringify({ [searchPath]: fromVal });
    to = stringify({ [target]: toVal });
  }
  return `Deprecated key "${searchPath}" found in ${localPath}
Please update ${from} => ${to}`;
}
function stringify(obj) {
  return JSON.stringify(obj).slice(1, -1);
}
function compose(...funcs) {
  return funcs.reduce(
    (a, b) => (...args) => a(b(...args))
  );
}
var import_dot_prop, import_npmlog9, import_path2, deprecateConfig;
var init_deprecate_config = __esm({
  "libs/core/src/lib/project/deprecate-config.ts"() {
    import_dot_prop = __toESM(require("dot-prop"));
    import_npmlog9 = __toESM(require("npmlog"));
    import_path2 = __toESM(require("path"));
    deprecateConfig = compose(
      remap("command.add.includeFilteredDependencies", "command.add.includeDependencies", { alsoRoot: true }),
      remap("command.add.includeFilteredDependents", "command.add.includeDependents", { alsoRoot: true }),
      remap("command.bootstrap.includeFilteredDependencies", "command.bootstrap.includeDependencies"),
      remap("command.bootstrap.includeFilteredDependents", "command.bootstrap.includeDependents"),
      remap("command.clean.includeFilteredDependencies", "command.clean.includeDependencies"),
      remap("command.clean.includeFilteredDependents", "command.clean.includeDependents"),
      remap("command.exec.includeFilteredDependencies", "command.exec.includeDependencies"),
      remap("command.exec.includeFilteredDependents", "command.exec.includeDependents"),
      remap("command.list.includeFilteredDependencies", "command.list.includeDependencies"),
      remap("command.list.includeFilteredDependents", "command.list.includeDependents"),
      remap("command.run.includeFilteredDependencies", "command.run.includeDependencies"),
      remap("command.run.includeFilteredDependents", "command.run.includeDependents"),
      remap("command.version.githubRelease", "command.version.createRelease", {
        toValue: (value) => value && "github"
      }),
      remap("command.publish.githubRelease", "command.version.createRelease", {
        alsoRoot: true,
        toValue: (value) => value && "github"
      }),
      remap("command.publish.npmTag", "command.publish.distTag", { alsoRoot: true }),
      remap("command.publish.cdVersion", "command.publish.bump", { alsoRoot: true }),
      remap("command.publish.ignore", "command.publish.ignoreChanges"),
      remap("commands", "command"),
      (config, filepath) => ({ config, filepath })
    );
  }
});

// libs/core/src/lib/project/shallow-extend.ts
function shallowExtend(json, defaults = {}) {
  return Object.keys(json).reduce((obj, key) => {
    const val = json[key];
    if (Array.isArray(val)) {
      obj[key] = val.slice();
    } else if (val && typeof val === "object") {
      obj[key] = shallowExtend(val, obj[key]);
    } else {
      obj[key] = val;
    }
    return obj;
  }, defaults);
}
var init_shallow_extend = __esm({
  "libs/core/src/lib/project/shallow-extend.ts"() {
  }
});

// libs/core/src/lib/project/apply-extends.ts
function applyExtends(config, cwd, seen = /* @__PURE__ */ new Set()) {
  let defaultConfig = {};
  if ("extends" in config) {
    let pathToDefault;
    try {
      pathToDefault = (0, import_resolve_from.default)(cwd, config.extends);
    } catch (err) {
      throw new ValidationError("ERESOLVED", "Config .extends must be locally-resolvable", err);
    }
    if (seen.has(pathToDefault)) {
      throw new ValidationError("ECIRCULAR", "Config .extends cannot be circular", seen);
    }
    seen.add(pathToDefault);
    defaultConfig = require(pathToDefault);
    delete config.extends;
    deprecateConfig(defaultConfig, pathToDefault);
    defaultConfig = applyExtends(defaultConfig, import_path3.default.dirname(pathToDefault), seen);
  }
  return shallowExtend(config, defaultConfig);
}
var import_path3, import_resolve_from;
var init_apply_extends = __esm({
  "libs/core/src/lib/project/apply-extends.ts"() {
    import_path3 = __toESM(require("path"));
    import_resolve_from = __toESM(require("resolve-from"));
    init_validation_error();
    init_deprecate_config();
    init_shallow_extend();
  }
});

// libs/core/src/lib/project/make-file-finder.ts
function normalize(results) {
  return results.map((fp) => import_path4.default.normalize(fp));
}
function getGlobOpts(rootPath, packageConfigs) {
  const globOpts = {
    cwd: rootPath,
    absolute: true,
    expandDirectories: false,
    followSymbolicLinks: false
  };
  if (packageConfigs.some((cfg) => cfg.indexOf("**") > -1)) {
    if (packageConfigs.some((cfg) => cfg.indexOf("node_modules") > -1)) {
      throw new ValidationError(
        "EPKGCONFIG",
        "An explicit node_modules package path does not allow globstars (**)"
      );
    }
    globOpts.ignore = [
      "**/node_modules/**"
    ];
  }
  return globOpts;
}
function makeFileFinder(rootPath, packageConfigs) {
  const globOpts = getGlobOpts(rootPath, packageConfigs);
  return (fileName, fileMapper, customGlobOpts) => {
    const options = Object.assign({}, customGlobOpts, globOpts);
    const promise = (0, import_p_map.default)(
      Array.from(packageConfigs).sort(),
      (globPath) => {
        let chain = (0, import_globby.default)(import_path4.default.posix.join(globPath, fileName), options);
        chain = chain.then((results) => results.sort());
        chain = chain.then(normalize);
        if (fileMapper) {
          chain = chain.then(fileMapper);
        }
        return chain;
      },
      { concurrency: 4 }
    );
    return promise.then((results) => results.reduce((acc, result) => acc.concat(result), []));
  };
}
function makeSyncFileFinder(rootPath, packageConfigs) {
  const globOpts = getGlobOpts(rootPath, packageConfigs);
  return (fileName, fileMapper, customGlobOpts) => {
    const options = Object.assign({}, customGlobOpts, globOpts);
    const patterns = packageConfigs.map((globPath) => import_path4.default.posix.join(globPath, fileName)).sort();
    let results = import_globby.default.sync(patterns, options);
    results = normalize(results);
    if (fileMapper) {
      results = results.map(fileMapper);
    }
    return results;
  };
}
var import_globby, import_p_map, import_path4;
var init_make_file_finder = __esm({
  "libs/core/src/lib/project/make-file-finder.ts"() {
    import_globby = __toESM(require("globby"));
    import_p_map = __toESM(require("p-map"));
    import_path4 = __toESM(require("path"));
    init_validation_error();
  }
});

// libs/core/src/lib/project/index.ts
var import_devkit, import_cosmiconfig, import_dedent2, import_fs, import_glob_parent, import_globby2, import_js_yaml, import_load_json_file2, import_npmlog10, import_p_map2, import_path5, _Project, Project, getPackages, getPackagesSync;
var init_project = __esm({
  "libs/core/src/lib/project/index.ts"() {
    import_devkit = require("@nrwl/devkit");
    import_cosmiconfig = require("cosmiconfig");
    import_dedent2 = __toESM(require("dedent"));
    import_fs = __toESM(require("fs"));
    import_glob_parent = __toESM(require("glob-parent"));
    import_globby2 = __toESM(require("globby"));
    import_js_yaml = require("js-yaml");
    import_load_json_file2 = __toESM(require("load-json-file"));
    import_npmlog10 = __toESM(require("npmlog"));
    import_p_map2 = __toESM(require("p-map"));
    import_path5 = __toESM(require("path"));
    init_package();
    init_validation_error();
    init_apply_extends();
    init_deprecate_config();
    init_make_file_finder();
    _Project = class {
      static getPackages(cwd) {
        return new _Project(cwd).getPackages();
      }
      static getPackagesSync(cwd) {
        return new _Project(cwd).getPackagesSync();
      }
      config;
      configNotFound;
      rootConfigLocation;
      rootPath;
      constructor(cwd) {
        const explorer = (0, import_cosmiconfig.cosmiconfigSync)("lerna", {
          searchPlaces: ["lerna.json", "package.json"],
          transform(obj) {
            if (!obj) {
              return {
                config: {},
                configNotFound: true,
                filepath: import_path5.default.resolve(cwd || ".", "lerna.json")
              };
            }
            deprecateConfig(obj.config, obj.filepath);
            obj.config = applyExtends(obj.config, import_path5.default.dirname(obj.filepath));
            return obj;
          }
        });
        let loaded;
        try {
          loaded = explorer.search(cwd);
        } catch (err) {
          if (err.name === "JSONError") {
            throw new ValidationError(err.name, err.message);
          }
          throw err;
        }
        this.config = loaded.config;
        this.configNotFound = loaded.configNotFound;
        this.rootConfigLocation = loaded.filepath;
        this.rootPath = import_path5.default.dirname(loaded.filepath);
        import_npmlog10.default.verbose("rootPath", this.rootPath);
      }
      get version() {
        return this.config.version;
      }
      set version(val) {
        this.config.version = val;
      }
      get packageConfigs() {
        if (this.config.npmClient === "pnpm") {
          import_npmlog10.default.verbose(
            "packageConfigs",
            "Package manager 'pnpm' detected. Resolving packages using 'pnpm-workspace.yaml'."
          );
          const workspaces = this.pnpmWorkspaceConfig.packages;
          if (!workspaces) {
            throw new ValidationError(
              "EWORKSPACES",
              "No 'packages' property found in pnpm-workspace.yaml. See https://pnpm.io/workspaces for help configuring workspaces in pnpm."
            );
          }
          return workspaces;
        }
        if (this.config.useWorkspaces) {
          const workspaces = this.manifest.get("workspaces");
          if (!workspaces) {
            throw new ValidationError(
              "EWORKSPACES",
              import_dedent2.default`
            Workspaces need to be defined in the root package.json.
            See: https://github.com/lerna/lerna/blob/master/commands/bootstrap/README.md#--use-workspaces
          `
            );
          }
          return workspaces.packages || workspaces;
        }
        if (this.manifest.get("workspaces")) {
          import_npmlog10.default.warn(
            "EWORKSPACES",
            import_dedent2.default`
          Workspaces exist in the root package.json, but Lerna is not configured to use them.
          To fix this and have Lerna use workspaces to resolve packages, set \`useWorkspaces: true\` in lerna.json.
        `
          );
        }
        if (this.config.packages) {
          return this.config.packages;
        }
        import_npmlog10.default.warn(
          "EPACKAGES",
          `No packages defined in lerna.json. Defaulting to packages in ${_Project.PACKAGE_GLOB}`
        );
        return [_Project.PACKAGE_GLOB];
      }
      get packageParentDirs() {
        return this.packageConfigs.map(import_glob_parent.default).map((parentDir) => import_path5.default.resolve(this.rootPath, parentDir));
      }
      get manifest() {
        let manifest;
        try {
          const manifestLocation = import_path5.default.join(this.rootPath, "package.json");
          const packageJson = import_load_json_file2.default.sync(manifestLocation);
          if (!packageJson.name) {
            packageJson.name = import_path5.default.basename(import_path5.default.dirname(manifestLocation));
          }
          manifest = new Package(packageJson, this.rootPath);
          Object.defineProperty(this, "manifest", {
            value: manifest
          });
        } catch (err) {
          if (err.name === "JSONError") {
            throw new ValidationError(err.name, err.message);
          }
        }
        return manifest;
      }
      get pnpmWorkspaceConfig() {
        let config;
        try {
          const configLocation = import_path5.default.join(this.rootPath, "pnpm-workspace.yaml");
          const configContent = import_fs.default.readFileSync(configLocation);
          config = (0, import_js_yaml.load)(configContent);
          Object.defineProperty(this, "pnpmWorkspaceConfig", {
            value: config
          });
        } catch (err) {
          if (err.message.includes("ENOENT: no such file or directory")) {
            throw new ValidationError(
              "ENOENT",
              "No pnpm-workspace.yaml found. See https://pnpm.io/workspaces for help configuring workspaces in pnpm."
            );
          }
          throw new ValidationError(err.name, err.message);
        }
        return config;
      }
      get licensePath() {
        let licensePath;
        try {
          const search = import_globby2.default.sync(_Project.LICENSE_GLOB, {
            cwd: this.rootPath,
            absolute: true,
            caseSensitiveMatch: false,
            deep: 0
          });
          licensePath = search.shift();
          if (licensePath) {
            licensePath = import_path5.default.normalize(licensePath);
            Object.defineProperty(this, "licensePath", {
              value: licensePath
            });
          }
        } catch (err) {
          throw new ValidationError(err.name, err.message);
        }
        return licensePath;
      }
      get fileFinder() {
        const finder = makeFileFinder(this.rootPath, this.packageConfigs);
        Object.defineProperty(this, "fileFinder", {
          value: finder
        });
        return finder;
      }
      getPackages() {
        const mapper = (packageConfigPath) => (0, import_load_json_file2.default)(packageConfigPath).then(
          (packageJson) => new Package(packageJson, import_path5.default.dirname(packageConfigPath), this.rootPath)
        );
        return this.fileFinder("package.json", (filePaths) => (0, import_p_map2.default)(filePaths, mapper, { concurrency: 50 }));
      }
      getPackagesSync() {
        return makeSyncFileFinder(this.rootPath, this.packageConfigs)("package.json", (packageConfigPath) => {
          return new Package(
            import_load_json_file2.default.sync(packageConfigPath),
            import_path5.default.dirname(packageConfigPath),
            this.rootPath
          );
        });
      }
      getPackageLicensePaths() {
        return this.fileFinder(_Project.LICENSE_GLOB, null, { caseSensitiveMatch: false });
      }
      isIndependent() {
        return this.version === "independent";
      }
      serializeConfig() {
        (0, import_devkit.writeJsonFile)(this.rootConfigLocation, this.config, { spaces: 2 });
        return this.rootConfigLocation;
      }
    };
    Project = _Project;
    __publicField(Project, "PACKAGE_GLOB", "packages/*");
    __publicField(Project, "LICENSE_GLOB", "LICEN{S,C}E{,.*}");
    getPackages = Project.getPackages;
    getPackagesSync = Project.getPackagesSync;
  }
});

// libs/core/src/lib/write-log-file.ts
function writeLogFile(cwd) {
  let logOutput = "";
  import_npmlog11.default.record.forEach((m) => {
    let pref = [m.id, m.level];
    if (m.prefix) {
      pref.push(m.prefix);
    }
    pref = pref.join(" ");
    m.message.trim().split(/\r?\n/).map((line) => `${pref} ${line}`.trim()).forEach((line) => {
      logOutput += line + import_os.default.EOL;
    });
  });
  import_write_file_atomic.default.sync(import_path6.default.join(cwd, "lerna-debug.log"), logOutput);
  import_npmlog11.default.record.length = 0;
}
var import_npmlog11, import_os, import_path6, import_write_file_atomic;
var init_write_log_file = __esm({
  "libs/core/src/lib/write-log-file.ts"() {
    import_npmlog11 = __toESM(require("npmlog"));
    import_os = __toESM(require("os"));
    import_path6 = __toESM(require("path"));
    import_write_file_atomic = __toESM(require("write-file-atomic"));
  }
});

// libs/core/src/lib/command/clean-stack.ts
function cleanStack(err, className) {
  const lines = err.stack ? err.stack.split("\n") : String(err).split("\n");
  const cutoff = new RegExp(`^    at ${className}.runCommand .*$`);
  const relevantIndex = lines.findIndex((line) => cutoff.test(line));
  if (relevantIndex) {
    return lines.slice(0, relevantIndex).join("\n");
  }
  return err;
}
var init_clean_stack = __esm({
  "libs/core/src/lib/command/clean-stack.ts"() {
  }
});

// libs/core/src/lib/command/default-options.ts
function defaultOptions(...sources) {
  const options = {};
  for (const source of sources) {
    if (source != null) {
      for (const key of Object.keys(source)) {
        if (options[key] === void 0) {
          options[key] = source[key];
        }
      }
    }
  }
  return options;
}
var init_default_options = __esm({
  "libs/core/src/lib/command/default-options.ts"() {
  }
});

// libs/core/src/lib/command/log-package-error.ts
function logPackageError(err, stream = false) {
  import_npmlog12.default.error(err.command, `exited ${err.exitCode} in '${err.pkg.name}'`);
  if (stream) {
    return;
  }
  if (err.stdout) {
    import_npmlog12.default.error(err.command, "stdout:");
    directLog(err.stdout);
  }
  if (err.stderr) {
    import_npmlog12.default.error(err.command, "stderr:");
    directLog(err.stderr);
  }
  import_npmlog12.default.error(err.command, `exited ${err.exitCode} in '${err.pkg.name}'`);
}
function directLog(message) {
  import_npmlog12.default.pause();
  console.error(message);
  import_npmlog12.default.resume();
}
var import_npmlog12;
var init_log_package_error = __esm({
  "libs/core/src/lib/command/log-package-error.ts"() {
    import_npmlog12 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/command/warn-if-hanging.ts
function warnIfHanging() {
  const childProcessCount = childProcess5.getChildProcessCount();
  if (childProcessCount > 0) {
    import_npmlog13.default.warn(
      "complete",
      `Waiting for ${childProcessCount} child process${childProcessCount === 1 ? "" : "es"} to exit. CTRL-C to exit immediately.`
    );
  }
}
var import_npmlog13, childProcess5;
var init_warn_if_hanging = __esm({
  "libs/core/src/lib/command/warn-if-hanging.ts"() {
    import_npmlog13 = __toESM(require("npmlog"));
    childProcess5 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/command/index.ts
var import_clone_deep, import_dedent3, import_execa, import_npmlog14, import_os2, DEFAULT_CONCURRENCY, Command;
var init_command = __esm({
  "libs/core/src/lib/command/index.ts"() {
    import_clone_deep = __toESM(require("clone-deep"));
    import_dedent3 = __toESM(require("dedent"));
    import_execa = __toESM(require("execa"));
    import_npmlog14 = __toESM(require("npmlog"));
    import_os2 = __toESM(require("os"));
    init_package_graph();
    init_project();
    init_validation_error();
    init_write_log_file();
    init_clean_stack();
    init_default_options();
    init_log_package_error();
    init_warn_if_hanging();
    DEFAULT_CONCURRENCY = import_os2.default.cpus().length;
    Command = class {
      name;
      composed;
      project;
      options;
      runner;
      concurrency;
      toposort;
      execOpts;
      packageGraph;
      logger;
      constructor(_argv, { skipValidations } = { skipValidations: false }) {
        import_npmlog14.default.pause();
        import_npmlog14.default.heading = "lerna";
        const argv = (0, import_clone_deep.default)(_argv);
        import_npmlog14.default.silly("argv", argv);
        this.name = this.constructor.name.replace(/Command$/, "").toLowerCase();
        this.composed = typeof argv.composed === "string" && argv.composed !== this.name;
        if (!this.composed) {
          import_npmlog14.default.notice("cli", `v${argv.lernaVersion}`);
        }
        let runner = new Promise((resolve, reject) => {
          let chain = Promise.resolve();
          chain = chain.then(() => {
            this.project = new Project(argv.cwd);
          });
          chain = chain.then(() => this.configureEnvironment());
          chain = chain.then(() => this.configureOptions());
          chain = chain.then(() => this.configureProperties());
          chain = chain.then(() => this.configureLogging());
          if (!skipValidations) {
            chain = chain.then(() => this.runValidations());
          }
          chain = chain.then(() => this.runPreparations());
          chain = chain.then(() => this.runCommand());
          chain.then(
            (result) => {
              warnIfHanging();
              resolve(result);
            },
            (err) => {
              if (err.pkg) {
                logPackageError(err, this.options.stream);
              } else if (err.name !== "ValidationError") {
                import_npmlog14.default.error("", cleanStack(err, this.constructor.name));
              }
              if (err.name !== "ValidationError" && !err.pkg) {
                writeLogFile(this.project.rootPath);
              }
              warnIfHanging();
              reject(err);
            }
          );
        });
        if (argv.onResolved || argv.onRejected) {
          runner = runner.then(argv.onResolved, argv.onRejected);
          delete argv.onResolved;
          delete argv.onRejected;
        }
        for (const key of ["cwd", "$0"]) {
          Object.defineProperty(argv, key, { enumerable: false });
        }
        Object.defineProperty(this, "argv", {
          value: Object.freeze(argv)
        });
        Object.defineProperty(this, "runner", {
          value: runner
        });
      }
      then(onResolved, onRejected) {
        return this.runner.then(onResolved, onRejected);
      }
      catch(onRejected) {
        return this.runner.catch(onRejected);
      }
      get requiresGit() {
        return true;
      }
      get otherCommandConfigs() {
        return [];
      }
      configureEnvironment() {
        const ci = require("is-ci");
        let loglevel;
        let progress;
        if (ci || !process.stderr.isTTY) {
          import_npmlog14.default.disableColor();
          progress = false;
        } else if (!process.stdout.isTTY) {
          progress = false;
          loglevel = "error";
        } else if (process.stderr.isTTY) {
          import_npmlog14.default.enableColor();
          import_npmlog14.default.enableUnicode();
        }
        Object.defineProperty(this, "envDefaults", {
          value: {
            ci,
            progress,
            loglevel
          }
        });
      }
      configureOptions() {
        const commandConfig = this.project.config.command || {};
        const overrides = [this.name, ...this.otherCommandConfigs].map((key) => commandConfig[key]);
        this.options = defaultOptions(
          this.argv,
          ...overrides,
          this.project.config,
          this.envDefaults
        );
        if (this.options.verbose && this.options.loglevel !== "silly") {
          this.options.loglevel = "verbose";
        }
      }
      argv(argv, arg1, config, envDefaults) {
        throw new Error("Method not implemented.");
      }
      envDefaults(argv, arg1, config, envDefaults) {
        throw new Error("Method not implemented.");
      }
      configureProperties() {
        const { concurrency, sort, maxBuffer } = this.options;
        this.concurrency = Math.max(1, +concurrency || DEFAULT_CONCURRENCY);
        this.toposort = sort === void 0 || sort;
        this.execOpts = {
          cwd: this.project.rootPath,
          maxBuffer
        };
      }
      configureLogging() {
        const { loglevel } = this.options;
        if (loglevel) {
          import_npmlog14.default.level = loglevel;
        }
        import_npmlog14.default.addLevel("success", 3001, { fg: "green", bold: true });
        Object.defineProperty(this, "logger", {
          value: import_npmlog14.default["newGroup"](this.name)
        });
        import_npmlog14.default.resume();
      }
      enableProgressBar() {
        if (this.options.progress !== false) {
          import_npmlog14.default.enableProgress();
        }
      }
      gitInitialized() {
        const opts = {
          cwd: this.project.rootPath,
          reject: false,
          stdio: "ignore"
        };
        return import_execa.default.sync("git", ["rev-parse"], opts).exitCode === 0;
      }
      runValidations() {
        if ((this.options.since !== void 0 || this.requiresGit) && !this.gitInitialized()) {
          throw new ValidationError("ENOGIT", "The git binary was not found, or this is not a git repository.");
        }
        if (!this.project.manifest) {
          throw new ValidationError("ENOPKG", "`package.json` does not exist, have you run `lerna init`?");
        }
        if (this.project.configNotFound) {
          throw new ValidationError("ENOLERNA", "`lerna.json` does not exist, have you run `lerna init`?");
        }
        if (!this.project.version) {
          throw new ValidationError("ENOVERSION", "Required property version does not exist in `lerna.json`");
        }
        if (this.options.independent && !this.project.isIndependent()) {
          throw new ValidationError(
            "EVERSIONMODE",
            import_dedent3.default`
          You ran lerna with --independent or -i, but the repository is not set to independent mode.
          To use independent mode you need to set lerna.json's "version" property to "independent".
          Then you won't need to pass the --independent or -i flags.
        `
          );
        }
        if (this.options.npmClient === "pnpm" && !this.options.useWorkspaces) {
          throw new ValidationError(
            "ENOWORKSPACES",
            "Usage of pnpm without workspaces is not supported. To use pnpm with lerna, set useWorkspaces to true in lerna.json and configure pnpm to use workspaces: https://pnpm.io/workspaces."
          );
        }
      }
      runPreparations() {
        if (!this.composed && this.project.isIndependent()) {
          import_npmlog14.default.info("versioning", "independent");
        }
        if (!this.composed && this.options.ci) {
          import_npmlog14.default.info("ci", "enabled");
        }
        let chain = Promise.resolve();
        chain = chain.then(() => this.project.getPackages());
        chain = chain.then((packages) => {
          this.packageGraph = new PackageGraph(packages);
        });
        return chain;
      }
      runCommand() {
        return Promise.resolve().then(() => this.initialize()).then((proceed) => {
          if (proceed !== false) {
            return this.execute();
          }
        });
      }
      initialize() {
        throw new ValidationError(this.name, "initialize() needs to be implemented.");
      }
      execute() {
        throw new ValidationError(this.name, "execute() needs to be implemented.");
      }
    };
  }
});

// libs/core/src/lib/conventional-commits/get-changelog-config.ts
var import_npm_package_arg3, import_npmlog15, import_pify;
var init_get_changelog_config = __esm({
  "libs/core/src/lib/conventional-commits/get-changelog-config.ts"() {
    import_npm_package_arg3 = __toESM(require("npm-package-arg"));
    import_npmlog15 = __toESM(require("npmlog"));
    import_pify = __toESM(require("pify"));
    init_validation_error();
  }
});

// libs/core/src/lib/conventional-commits/recommend-version.ts
var import_conventional_recommended_bump, import_npmlog16, import_semver3;
var init_recommend_version = __esm({
  "libs/core/src/lib/conventional-commits/recommend-version.ts"() {
    import_conventional_recommended_bump = __toESM(require("conventional-recommended-bump"));
    import_npmlog16 = __toESM(require("npmlog"));
    import_semver3 = __toESM(require("semver"));
    init_get_changelog_config();
  }
});

// libs/core/src/lib/conventional-commits/constants.ts
var EOL, BLANK_LINE, COMMIT_GUIDELINE, CHANGELOG_HEADER;
var init_constants = __esm({
  "libs/core/src/lib/conventional-commits/constants.ts"() {
    EOL = "\n";
    BLANK_LINE = EOL + EOL;
    COMMIT_GUIDELINE = "See [Conventional Commits](https://conventionalcommits.org) for commit guidelines.";
    CHANGELOG_HEADER = [
      "# Change Log",
      "",
      "All notable changes to this project will be documented in this file.",
      COMMIT_GUIDELINE
    ].join(EOL);
  }
});

// libs/core/src/lib/conventional-commits/make-bump-only-filter.ts
var init_make_bump_only_filter = __esm({
  "libs/core/src/lib/conventional-commits/make-bump-only-filter.ts"() {
    init_constants();
  }
});

// libs/core/src/lib/conventional-commits/read-existing-changelog.ts
var import_fs_extra;
var init_read_existing_changelog = __esm({
  "libs/core/src/lib/conventional-commits/read-existing-changelog.ts"() {
    import_fs_extra = __toESM(require("fs-extra"));
    init_constants();
  }
});

// libs/core/src/lib/conventional-commits/update-changelog.ts
var import_conventional_changelog_core, import_fs_extra2, import_get_stream, import_npmlog17;
var init_update_changelog = __esm({
  "libs/core/src/lib/conventional-commits/update-changelog.ts"() {
    import_conventional_changelog_core = __toESM(require("conventional-changelog-core"));
    import_fs_extra2 = __toESM(require("fs-extra"));
    import_get_stream = __toESM(require("get-stream"));
    import_npmlog17 = __toESM(require("npmlog"));
    init_constants();
    init_get_changelog_config();
    init_make_bump_only_filter();
    init_read_existing_changelog();
  }
});

// libs/core/src/lib/conventional-commits/index.ts
var init_conventional_commits = __esm({
  "libs/core/src/lib/conventional-commits/index.ts"() {
    init_recommend_version();
    init_update_changelog();
  }
});

// libs/core/src/lib/create-symlink.ts
var import_cmd_shim, import_fs_extra3, import_npmlog18;
var init_create_symlink = __esm({
  "libs/core/src/lib/create-symlink.ts"() {
    import_cmd_shim = __toESM(require("cmd-shim"));
    import_fs_extra3 = __toESM(require("fs-extra"));
    import_npmlog18 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/filter-packages.ts
var import_multimatch, import_npmlog19;
var init_filter_packages = __esm({
  "libs/core/src/lib/filter-packages.ts"() {
    import_multimatch = __toESM(require("multimatch"));
    import_npmlog19 = __toESM(require("npmlog"));
    init_validation_error();
  }
});

// libs/core/src/lib/filter-options.ts
var import_dedent4, import_npmlog20;
var init_filter_options = __esm({
  "libs/core/src/lib/filter-options.ts"() {
    import_dedent4 = __toESM(require("dedent"));
    import_npmlog20 = __toESM(require("npmlog"));
    init_collect_updates();
    init_filter_packages();
  }
});

// libs/core/src/lib/has-npm-version.ts
var import_semver4, childProcess6;
var init_has_npm_version = __esm({
  "libs/core/src/lib/has-npm-version.ts"() {
    import_semver4 = __toESM(require("semver"));
    childProcess6 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/query-graph.ts
var QueryGraph, toposort;
var init_query_graph = __esm({
  "libs/core/src/lib/query-graph.ts"() {
    init_package_graph();
    QueryGraph = class {
      graph;
      cycles;
      static toposort(packages, options) {
        const graph = new QueryGraph(packages, options);
        const result = [];
        let batch = graph.getAvailablePackages();
        while (batch.length) {
          for (const node of batch) {
            result.push(node.pkg);
            graph.markAsDone(node);
          }
          batch = graph.getAvailablePackages();
        }
        return result;
      }
      constructor(packages, { graphType = "allDependencies", rejectCycles } = {}) {
        this.graph = new PackageGraph(packages, graphType);
        this.cycles = this.graph.collapseCycles(rejectCycles);
      }
      _getNextLeaf() {
        return Array.from(this.graph.values()).filter((node) => node.localDependencies.size === 0);
      }
      _getNextCycle() {
        const cycle = Array.from(this.cycles).find((cycleNode) => cycleNode.localDependencies.size === 0);
        if (!cycle) {
          return [];
        }
        this.cycles.delete(cycle);
        return cycle.flatten();
      }
      getAvailablePackages() {
        const availablePackages = this._getNextLeaf();
        if (availablePackages.length > 0) {
          return availablePackages;
        }
        return this._getNextCycle();
      }
      markAsTaken(name) {
        this.graph.delete(name);
      }
      markAsDone(candidateNode) {
        this.graph.remove(candidateNode);
        for (const cycle of this.cycles) {
          cycle.unlink(candidateNode);
        }
      }
    };
    toposort = QueryGraph.toposort;
  }
});

// libs/core/src/lib/listable/listable-format.ts
var import_chalk2, import_columnify;
var init_listable_format = __esm({
  "libs/core/src/lib/listable/listable-format.ts"() {
    "use strict";
    import_chalk2 = __toESM(require("chalk"));
    import_columnify = __toESM(require("columnify"));
    init_query_graph();
  }
});

// libs/core/src/lib/listable/listable-options.ts
var init_listable_options = __esm({
  "libs/core/src/lib/listable/listable-options.ts"() {
  }
});

// libs/core/src/lib/log-packed.ts
var import_byte_size, import_columnify2, import_npmlog21, import_has_unicode, hasUnicode;
var init_log_packed = __esm({
  "libs/core/src/lib/log-packed.ts"() {
    import_byte_size = __toESM(require("byte-size"));
    import_columnify2 = __toESM(require("columnify"));
    import_npmlog21 = __toESM(require("npmlog"));
    import_has_unicode = __toESM(require("has-unicode"));
    hasUnicode = (0, import_has_unicode.default)();
  }
});

// libs/core/src/lib/get-npm-exec-opts.ts
function getNpmExecOpts(pkg, registry) {
  const env = {
    LERNA_PACKAGE_NAME: pkg.name
  };
  if (registry) {
    env.npm_config_registry = registry;
  }
  import_npmlog22.default.silly("getNpmExecOpts", pkg.location, registry);
  return {
    cwd: pkg.location,
    env,
    pkg
  };
}
var import_npmlog22;
var init_get_npm_exec_opts = __esm({
  "libs/core/src/lib/get-npm-exec-opts.ts"() {
    import_npmlog22 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/npm-install.ts
function npmInstall(pkg, { registry, npmClient, npmClientArgs, npmGlobalStyle, mutex, stdio = "pipe", subCommand = "install" }) {
  const opts = getNpmExecOpts(pkg, registry);
  const args = [subCommand];
  let cmd = npmClient || "npm";
  if (npmGlobalStyle) {
    cmd = "npm";
    args.push("--global-style");
  }
  if (cmd === "yarn" && mutex) {
    args.push("--mutex", mutex);
  }
  if (cmd === "yarn") {
    args.push("--non-interactive");
  }
  if (npmClientArgs && npmClientArgs.length) {
    args.push(...npmClientArgs);
  }
  opts.stdio = stdio;
  opts.env.LERNA_EXEC_PATH = pkg.location;
  opts.env.LERNA_ROOT_PATH = pkg.rootPath;
  import_npmlog23.default.silly("npmInstall", [cmd, args]);
  return childProcess7.exec(cmd, args, opts);
}
function npmInstallDependencies(pkg, dependencies, config) {
  import_npmlog23.default.silly("npmInstallDependencies", pkg.name, dependencies);
  if (!(dependencies && dependencies.length)) {
    import_npmlog23.default.verbose("npmInstallDependencies", "no dependencies to install");
    return Promise.resolve();
  }
  const packageJsonBkp = `${pkg.manifestLocation}.lerna_backup`;
  import_npmlog23.default.silly("npmInstallDependencies", "backup", pkg.manifestLocation);
  return import_fs_extra4.default.copy(pkg.manifestLocation, packageJsonBkp).then(() => {
    const cleanup = () => {
      import_npmlog23.default.silly("npmInstallDependencies", "cleanup", pkg.manifestLocation);
      import_fs_extra4.default.renameSync(packageJsonBkp, pkg.manifestLocation);
    };
    const unregister = (0, import_signal_exit.default)(cleanup);
    const done = (finalError) => {
      cleanup();
      unregister();
      if (finalError) {
        throw finalError;
      }
    };
    const tempJson = transformManifest(pkg, dependencies);
    import_npmlog23.default.silly("npmInstallDependencies", "writing tempJson", tempJson);
    return (0, import_write_pkg2.default)(pkg.manifestLocation, tempJson).then(() => npmInstall(pkg, config)).then(() => done(), done);
  });
}
function transformManifest(pkg, dependencies) {
  const json = pkg.toJSON();
  const depMap = new Map(
    dependencies.map((dep) => {
      const { name, rawSpec } = (0, import_npm_package_arg4.default)(dep, pkg.location);
      return [name, rawSpec || "*"];
    })
  );
  delete json.scripts;
  ["dependencies", "devDependencies", "optionalDependencies"].forEach((depType) => {
    const collection = json[depType];
    if (collection) {
      Object.keys(collection).forEach((depName) => {
        if (depMap.has(depName)) {
          collection[depName] = depMap.get(depName);
          depMap.delete(depName);
        } else {
          delete collection[depName];
        }
      });
    }
  });
  ["bundledDependencies", "bundleDependencies"].forEach((depType) => {
    const collection = json[depType];
    if (Array.isArray(collection)) {
      const newCollection = [];
      for (const depName of collection) {
        if (depMap.has(depName)) {
          newCollection.push(depName);
          depMap.delete(depName);
        }
      }
      json[depType] = newCollection;
    }
  });
  if (depMap.size) {
    if (!json.dependencies) {
      json.dependencies = {};
    }
    depMap.forEach((depVersion, depName) => {
      json.dependencies[depName] = depVersion;
    });
  }
  return json;
}
var import_fs_extra4, import_npm_package_arg4, import_npmlog23, import_signal_exit, import_write_pkg2, childProcess7;
var init_npm_install = __esm({
  "libs/core/src/lib/npm-install.ts"() {
    import_fs_extra4 = __toESM(require("fs-extra"));
    import_npm_package_arg4 = __toESM(require("npm-package-arg"));
    import_npmlog23 = __toESM(require("npmlog"));
    import_signal_exit = __toESM(require("signal-exit"));
    import_write_pkg2 = __toESM(require("write-pkg"));
    init_get_npm_exec_opts();
    childProcess7 = require("@lerna/child-process");
    module.exports.npmInstallDependencies = npmInstallDependencies;
  }
});

// libs/core/src/lib/prompt.ts
function promptTextInput(message, { filter, validate } = {}) {
  import_npmlog24.default.pause();
  return import_inquirer.default.prompt([
    {
      type: "input",
      name: "input",
      message,
      filter,
      validate
    }
  ]).then((answers) => {
    import_npmlog24.default.resume();
    return answers.input;
  });
}
var import_inquirer, import_npmlog24;
var init_prompt = __esm({
  "libs/core/src/lib/prompt.ts"() {
    import_inquirer = __toESM(require("inquirer"));
    import_npmlog24 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/otplease.ts
function otplease(fn, _opts, otpCache) {
  const opts = { ...otpCache, ..._opts };
  return attempt(fn, opts, otpCache);
}
function attempt(fn, opts, otpCache) {
  return new Promise((resolve) => {
    resolve(fn(opts));
  }).catch((err) => {
    if (err.code !== "EOTP" && !(err.code === "E401" && /one-time pass/.test(err.body))) {
      throw err;
    } else if (!process.stdin.isTTY || !process.stdout.isTTY) {
      throw err;
    } else {
      if (otpCache != null && otpCache.otp != null && otpCache.otp !== opts["otp"]) {
        return attempt(fn, { ...opts, ...otpCache }, otpCache);
      }
      return semaphore.wait().then(() => {
        if (otpCache != null && otpCache.otp != null && otpCache.otp !== opts["otp"]) {
          semaphore.release();
          return attempt(fn, { ...opts, ...otpCache }, otpCache);
        }
        return getOneTimePassword().then(
          (otp) => {
            if (otpCache != null) {
              otpCache.otp = otp;
            }
            semaphore.release();
            return otp;
          },
          (promptError) => {
            semaphore.release();
            return Promise.reject(promptError);
          }
        ).then((otp) => {
          return fn({ ...opts, otp });
        });
      });
    }
  });
}
function getOneTimePassword(message = "This operation requires a one-time password:") {
  return promptTextInput(message, {
    filter: (otp) => otp.replace(/\s+/g, ""),
    validate: (otp) => otp && /^[\d ]+$|^[A-Fa-f0-9]{64,64}$/.test(otp) || "Must be a valid one-time-password. See https://docs.npmjs.com/getting-started/using-two-factor-authentication"
  });
}
var semaphore;
var init_otplease = __esm({
  "libs/core/src/lib/otplease.ts"() {
    init_prompt();
    semaphore = {
      _promise: void 0,
      _resolve: void 0,
      wait() {
        return new Promise((resolve) => {
          if (!this._promise) {
            this._promise = new Promise((release) => {
              this._resolve = release;
            });
            resolve(void 0);
          } else {
            resolve(this._promise.then(() => this.wait()));
          }
        });
      },
      release() {
        const resolve = this._resolve;
        if (resolve) {
          this._resolve = void 0;
          this._promise = void 0;
          resolve();
        }
      }
    };
  }
});

// libs/core/src/lib/npm-conf/env-replace.ts
function envReplace(str) {
  if (typeof str !== "string" || !str) {
    return str;
  }
  const regex = /(\\*)\$\{([^}]+)\}/g;
  return str.replace(regex, (orig, esc, name) => {
    esc = esc.length > 0 && esc.length % 2;
    if (esc) {
      return orig;
    }
    if (process.env[name] === void 0) {
      throw new Error(`Failed to replace env in config: ${orig}`);
    }
    return process.env[name];
  });
}
var init_env_replace = __esm({
  "libs/core/src/lib/npm-conf/env-replace.ts"() {
  }
});

// libs/core/src/lib/npm-conf/find-prefix.ts
function findPrefix(start) {
  let dir = import_path7.default.resolve(start);
  let walkedUp = false;
  while (import_path7.default.basename(dir) === "node_modules") {
    dir = import_path7.default.dirname(dir);
    walkedUp = true;
  }
  if (walkedUp) {
    return dir;
  }
  return find(dir, dir);
}
function find(name, original) {
  if (name === "/" || process.platform === "win32" && /^[a-zA-Z]:(\\|\/)?$/.test(name)) {
    return original;
  }
  try {
    const files = import_fs2.default.readdirSync(name);
    if (files.indexOf("node_modules") !== -1 || files.indexOf("package.json") !== -1) {
      return name;
    }
    const dirname = import_path7.default.dirname(name);
    if (dirname === name) {
      return original;
    }
    return find(dirname, original);
  } catch (err) {
    if (name === original) {
      if (err.code === "ENOENT") {
        return original;
      }
      throw err;
    }
    return original;
  }
}
var import_fs2, import_path7;
var init_find_prefix = __esm({
  "libs/core/src/lib/npm-conf/find-prefix.ts"() {
    import_fs2 = __toESM(require("fs"));
    import_path7 = __toESM(require("path"));
  }
});

// libs/core/src/lib/npm-conf/types.ts
var require_types = __commonJS({
  "libs/core/src/lib/npm-conf/types.ts"(exports2) {
    var import_path11 = __toESM(require("path"));
    var import_stream = require("stream");
    var import_url2 = __toESM(require("url"));
    var Umask = () => {
    };
    var getLocalAddresses = () => [];
    var semver5 = () => {
    };
    exports2.types = {
      access: [null, "restricted", "public"],
      "allow-same-version": Boolean,
      "always-auth": Boolean,
      also: [null, "dev", "development"],
      audit: Boolean,
      "audit-level": ["low", "moderate", "high", "critical"],
      "auth-type": ["legacy", "sso", "saml", "oauth"],
      "bin-links": Boolean,
      browser: [null, String],
      ca: [null, String, Array],
      cafile: import_path11.default,
      cache: import_path11.default,
      "cache-lock-stale": Number,
      "cache-lock-retries": Number,
      "cache-lock-wait": Number,
      "cache-max": Number,
      "cache-min": Number,
      cert: [null, String],
      cidr: [null, String, Array],
      color: ["always", Boolean],
      depth: Number,
      description: Boolean,
      dev: Boolean,
      "dry-run": Boolean,
      editor: String,
      "engine-strict": Boolean,
      force: Boolean,
      "fetch-retries": Number,
      "fetch-retry-factor": Number,
      "fetch-retry-mintimeout": Number,
      "fetch-retry-maxtimeout": Number,
      git: String,
      "git-tag-version": Boolean,
      "commit-hooks": Boolean,
      global: Boolean,
      globalconfig: import_path11.default,
      "global-style": Boolean,
      group: [Number, String],
      "https-proxy": [null, import_url2.default],
      "user-agent": String,
      "ham-it-up": Boolean,
      heading: String,
      "if-present": Boolean,
      "ignore-prepublish": Boolean,
      "ignore-scripts": Boolean,
      "init-module": import_path11.default,
      "init-author-name": String,
      "init-author-email": String,
      "init-author-url": ["", import_url2.default],
      "init-license": String,
      "init-version": semver5,
      json: Boolean,
      key: [null, String],
      "legacy-bundling": Boolean,
      link: Boolean,
      "local-address": getLocalAddresses(),
      loglevel: ["silent", "error", "warn", "notice", "http", "timing", "info", "verbose", "silly"],
      logstream: import_stream.Stream,
      "logs-max": Number,
      long: Boolean,
      maxsockets: Number,
      message: String,
      "metrics-registry": [null, String],
      "node-options": [null, String],
      "node-version": [null, semver5],
      noproxy: [null, String, Array],
      offline: Boolean,
      "onload-script": [null, String],
      only: [null, "dev", "development", "prod", "production"],
      optional: Boolean,
      "package-lock": Boolean,
      otp: [null, String],
      "package-lock-only": Boolean,
      parseable: Boolean,
      "prefer-offline": Boolean,
      "prefer-online": Boolean,
      prefix: import_path11.default,
      preid: String,
      production: Boolean,
      progress: Boolean,
      proxy: [null, false, import_url2.default],
      "read-only": Boolean,
      "rebuild-bundle": Boolean,
      registry: [null, import_url2.default],
      rollback: Boolean,
      save: Boolean,
      "save-bundle": Boolean,
      "save-dev": Boolean,
      "save-exact": Boolean,
      "save-optional": Boolean,
      "save-prefix": String,
      "save-prod": Boolean,
      scope: String,
      "script-shell": [null, String],
      "scripts-prepend-node-path": [false, true, "auto", "warn-only"],
      searchopts: String,
      searchexclude: [null, String],
      searchlimit: Number,
      searchstaleness: Number,
      "send-metrics": Boolean,
      shell: String,
      shrinkwrap: Boolean,
      "sign-git-commit": Boolean,
      "sign-git-tag": Boolean,
      "sso-poll-frequency": Number,
      "sso-type": [null, "oauth", "saml"],
      "strict-ssl": Boolean,
      tag: String,
      timing: Boolean,
      tmp: import_path11.default,
      unicode: Boolean,
      "unsafe-perm": Boolean,
      "update-notifier": Boolean,
      usage: Boolean,
      user: [Number, String],
      userconfig: import_path11.default,
      umask: Umask,
      version: Boolean,
      "tag-version-prefix": String,
      versions: Boolean,
      viewer: String,
      _exit: Boolean
    };
  }
});

// libs/core/src/lib/npm-conf/parse-field.ts
function parseField(input, key) {
  if (typeof input !== "string") {
    return input;
  }
  const typeList = [].concat(types[key]);
  const isPath = typeList.indexOf(import_path8.default) !== -1;
  const isBool = typeList.indexOf(Boolean) !== -1;
  const isString = typeList.indexOf(String) !== -1;
  const isNumber = typeList.indexOf(Number) !== -1;
  let field = `${input}`.trim();
  if (/^".*"$/.test(field)) {
    try {
      field = JSON.parse(field);
    } catch (err) {
      throw new Error(`Failed parsing JSON config key ${key}: ${field}`);
    }
  }
  if (isBool && !isString && field === "") {
    return true;
  }
  switch (field) {
    case "true": {
      return true;
    }
    case "false": {
      return false;
    }
    case "null": {
      return null;
    }
    case "undefined": {
      return void 0;
    }
  }
  field = envReplace(field);
  if (isPath) {
    const regex = process.platform === "win32" ? /^~(\/|\\)/ : /^~\//;
    if (regex.test(field) && process.env["HOME"]) {
      field = import_path8.default.resolve(process.env["HOME"], field.substr(2));
    }
    field = import_path8.default.resolve(field);
  }
  if (isNumber && !Number.isNaN(field)) {
    field = Number(field);
  }
  return field;
}
var import_path8, types;
var init_parse_field = __esm({
  "libs/core/src/lib/npm-conf/parse-field.ts"() {
    import_path8 = __toESM(require("path"));
    init_env_replace();
    ({ types } = require_types());
  }
});

// libs/core/src/lib/npm-conf/nerf-dart.ts
function toNerfDart(uri) {
  const parsed = import_url.default.parse(uri);
  delete parsed.protocol;
  delete parsed.auth;
  delete parsed.query;
  delete parsed.search;
  delete parsed.hash;
  return import_url.default.resolve(import_url.default.format(parsed), ".");
}
var import_url;
var init_nerf_dart = __esm({
  "libs/core/src/lib/npm-conf/nerf-dart.ts"() {
    import_url = __toESM(require("url"));
  }
});

// libs/core/src/lib/npm-conf/conf.ts
var import_assert, import_fs3, import_path9, ConfigChain, Conf;
var init_conf = __esm({
  "libs/core/src/lib/npm-conf/conf.ts"() {
    import_assert = __toESM(require("assert"));
    import_fs3 = __toESM(require("fs"));
    import_path9 = __toESM(require("path"));
    init_env_replace();
    init_find_prefix();
    init_parse_field();
    init_nerf_dart();
    ({ ConfigChain } = require("config-chain"));
    Conf = class extends ConfigChain {
      root;
      constructor(base) {
        super(base);
        this.root = base;
      }
      add(data, marker) {
        try {
          for (const x of Object.keys(data)) {
            const newKey = envReplace(x);
            const newField = parseField(data[x], newKey);
            delete data[x];
            data[newKey] = newField;
          }
        } catch (err) {
          throw err;
        }
        return super.add(data, marker);
      }
      addFile(file, name = file) {
        const marker = { __source__: name };
        this["sources"][name] = { path: file, type: "ini" };
        this["push"](marker);
        this["_await"]();
        try {
          const contents = import_fs3.default.readFileSync(file, "utf8");
          this["addString"](contents, file, "ini", marker);
        } catch (err) {
          this["add"]({}, marker);
        }
        return this;
      }
      addEnv(env = process.env) {
        const conf = {};
        Object.keys(env).filter((x) => /^npm_config_/i.test(x)).forEach((x) => {
          if (!env[x]) {
            return;
          }
          const p = x.toLowerCase().replace(/^npm_config_/, "").replace(/(?!^)_/g, "-");
          conf[p] = env[x];
        });
        return super.addEnv("", conf, "env");
      }
      loadPrefix() {
        const cli = this["list"][0];
        Object.defineProperty(this, "prefix", {
          enumerable: true,
          set: (prefix) => {
            const g = this["get"]("global");
            this[g ? "globalPrefix" : "localPrefix"] = prefix;
          },
          get: () => {
            const g = this["get"]("global");
            return g ? this["globalPrefix"] : this["localPrefix"];
          }
        });
        Object.defineProperty(this, "globalPrefix", {
          enumerable: true,
          set: (prefix) => {
            this["set"]("prefix", prefix);
          },
          get: () => import_path9.default.resolve(this["get"]("prefix"))
        });
        let p;
        Object.defineProperty(this, "localPrefix", {
          enumerable: true,
          set: (prefix) => {
            p = prefix;
          },
          get: () => p
        });
        if (Object.prototype.hasOwnProperty.call(cli, "prefix")) {
          p = import_path9.default.resolve(cli.prefix);
        } else {
          try {
            p = findPrefix(process.cwd());
          } catch (err) {
            throw err;
          }
        }
        return p;
      }
      loadCAFile(file) {
        if (!file) {
          return;
        }
        try {
          const contents = import_fs3.default.readFileSync(file, "utf8");
          const delim = "-----END CERTIFICATE-----";
          const output2 = contents.split(delim).filter((x) => Boolean(x.trim())).map((x) => x.trimLeft() + delim);
          this["set"]("ca", output2);
        } catch (err) {
          if (err.code === "ENOENT") {
            return;
          }
          throw err;
        }
      }
      loadUser() {
        const defConf = this.root;
        if (this["get"]("global")) {
          return;
        }
        if (process.env["SUDO_UID"]) {
          defConf.user = Number(process.env["SUDO_UID"]);
          return;
        }
        const prefix = import_path9.default.resolve(this["get"]("prefix"));
        try {
          const stats = import_fs3.default.statSync(prefix);
          defConf.user = stats.uid;
        } catch (err) {
          if (err.code === "ENOENT") {
            return;
          }
          throw err;
        }
      }
      getCredentialsByURI(uri) {
        (0, import_assert.default)(uri && typeof uri === "string", "registry URL is required");
        const nerfed = toNerfDart(uri);
        const defnerf = toNerfDart(this["get"]("registry"));
        const c = {
          scope: nerfed,
          token: void 0,
          password: void 0,
          username: void 0,
          email: void 0,
          auth: void 0,
          alwaysAuth: void 0
        };
        if (this["get"](`${nerfed}:always-auth`) !== void 0) {
          const val = this["get"](`${nerfed}:always-auth`);
          c.alwaysAuth = val === "false" ? false : !!val;
        } else if (this["get"]("always-auth") !== void 0) {
          c.alwaysAuth = this["get"]("always-auth");
        }
        if (this["get"](`${nerfed}:_authToken`)) {
          c.token = this["get"](`${nerfed}:_authToken`);
          return c;
        }
        let authDef = this["get"]("_auth");
        let userDef = this["get"]("username");
        let passDef = this["get"]("_password");
        if (authDef && !(userDef && passDef)) {
          authDef = Buffer.from(authDef, "base64").toString();
          authDef = authDef.split(":");
          userDef = authDef.shift();
          passDef = authDef.join(":");
        }
        if (this["get"](`${nerfed}:_password`)) {
          c.password = Buffer.from(this["get"](`${nerfed}:_password`), "base64").toString("utf8");
        } else if (nerfed === defnerf && passDef) {
          c.password = passDef;
        }
        if (this["get"](`${nerfed}:username`)) {
          c.username = this["get"](`${nerfed}:username`);
        } else if (nerfed === defnerf && userDef) {
          c.username = userDef;
        }
        if (this["get"](`${nerfed}:email`)) {
          c.email = this["get"](`${nerfed}:email`);
        } else if (this["get"]("email")) {
          c.email = this["get"]("email");
        }
        if (c.username && c.password) {
          c.auth = Buffer.from(`${c.username}:${c.password}`).toString("base64");
        }
        return c;
      }
      setCredentialsByURI(uri, c) {
        (0, import_assert.default)(uri && typeof uri === "string", "registry URL is required");
        (0, import_assert.default)(c && typeof c === "object", "credentials are required");
        const nerfed = toNerfDart(uri);
        if (c.token) {
          this["set"](`${nerfed}:_authToken`, c.token, "user");
          this["del"](`${nerfed}:_password`, "user");
          this["del"](`${nerfed}:username`, "user");
          this["del"](`${nerfed}:email`, "user");
          this["del"](`${nerfed}:always-auth`, "user");
        } else if (c.username || c.password || c.email) {
          (0, import_assert.default)(c.username, "must include username");
          (0, import_assert.default)(c.password, "must include password");
          (0, import_assert.default)(c.email, "must include email address");
          this["del"](`${nerfed}:_authToken`, "user");
          const encoded = Buffer.from(c.password, "utf8").toString("base64");
          this["set"](`${nerfed}:_password`, encoded, "user");
          this["set"](`${nerfed}:username`, c.username, "user");
          this["set"](`${nerfed}:email`, c.email, "user");
          if (c.alwaysAuth !== void 0) {
            this["set"](`${nerfed}:always-auth`, c.alwaysAuth, "user");
          } else {
            this["del"](`${nerfed}:always-auth`, "user");
          }
        } else {
          throw new Error("No credentials to set.");
        }
      }
    };
  }
});

// libs/core/src/lib/npm-conf/defaults.ts
var require_defaults = __commonJS({
  "libs/core/src/lib/npm-conf/defaults.ts"(exports2) {
    var import_os3 = __toESM(require("os"));
    var import_path11 = __toESM(require("path"));
    var temp = import_os3.default.tmpdir();
    var uidOrPid = process.getuid ? process.getuid() : process.pid;
    var hasUnicode2 = () => true;
    var isWindows = process.platform === "win32";
    var osenv = {
      editor: () => process.env["EDITOR"] || process.env["VISUAL"] || (isWindows ? "notepad.exe" : "vi"),
      shell: () => isWindows ? process.env["COMSPEC"] || "cmd.exe" : process.env["SHELL"] || "/bin/bash"
    };
    var umask = {
      fromString: () => process.umask()
    };
    var home = import_os3.default.homedir();
    if (home) {
      process.env["HOME"] = home;
    } else {
      home = import_path11.default.resolve(temp, `npm-${uidOrPid}`);
    }
    var cacheExtra = process.platform === "win32" ? "npm-cache" : ".npm";
    var cacheRoot = process.platform === "win32" && process.env["APPDATA"] || home;
    var cache = import_path11.default.resolve(cacheRoot, cacheExtra);
    var defaults;
    var globalPrefix;
    Object.defineProperty(exports2, "defaults", {
      get() {
        if (defaults) {
          return defaults;
        }
        if (process.env["PREFIX"]) {
          globalPrefix = process.env["PREFIX"];
        } else if (process.platform === "win32") {
          globalPrefix = import_path11.default.dirname(process.execPath);
        } else {
          globalPrefix = import_path11.default.dirname(import_path11.default.dirname(process.execPath));
          if (process.env["DESTDIR"]) {
            globalPrefix = import_path11.default.join(process.env["DESTDIR"], globalPrefix);
          }
        }
        defaults = {
          access: null,
          "allow-same-version": false,
          "always-auth": false,
          also: null,
          audit: true,
          "audit-level": "low",
          "auth-type": "legacy",
          "bin-links": true,
          browser: null,
          ca: null,
          cafile: null,
          cache,
          "cache-lock-stale": 6e4,
          "cache-lock-retries": 10,
          "cache-lock-wait": 1e4,
          "cache-max": Infinity,
          "cache-min": 10,
          cert: null,
          cidr: null,
          color: process.env["NO_COLOR"] == null,
          depth: Infinity,
          description: true,
          dev: false,
          "dry-run": false,
          editor: osenv.editor(),
          "engine-strict": false,
          force: false,
          "fetch-retries": 2,
          "fetch-retry-factor": 10,
          "fetch-retry-mintimeout": 1e4,
          "fetch-retry-maxtimeout": 6e4,
          git: "git",
          "git-tag-version": true,
          "commit-hooks": true,
          global: false,
          globalconfig: import_path11.default.resolve(globalPrefix, "etc", "npmrc"),
          "global-style": false,
          group: process.platform === "win32" ? 0 : process.env["SUDO_GID"] || process.getgid && process.getgid(),
          "ham-it-up": false,
          heading: "npm",
          "if-present": false,
          "ignore-prepublish": false,
          "ignore-scripts": false,
          "init-module": import_path11.default.resolve(home, ".npm-init.js"),
          "init-author-name": "",
          "init-author-email": "",
          "init-author-url": "",
          "init-version": "1.0.0",
          "init-license": "ISC",
          json: false,
          key: null,
          "legacy-bundling": false,
          link: false,
          "local-address": void 0,
          loglevel: "notice",
          logstream: process.stderr,
          "logs-max": 10,
          long: false,
          maxsockets: 50,
          message: "%s",
          "metrics-registry": null,
          "node-options": null,
          "node-version": process.version,
          offline: false,
          "onload-script": false,
          only: null,
          optional: true,
          otp: void 0,
          "package-lock": true,
          "package-lock-only": false,
          parseable: false,
          "prefer-offline": false,
          "prefer-online": false,
          prefix: globalPrefix,
          preid: "",
          production: process.env["NODE_ENV"] === "production",
          progress: !process.env["TRAVIS"] && !process.env["CI"],
          proxy: null,
          "https-proxy": null,
          noproxy: null,
          "user-agent": "npm/{npm-version} node/{node-version} {platform} {arch}",
          "read-only": false,
          "rebuild-bundle": true,
          registry: "https://registry.npmjs.org/",
          rollback: true,
          save: true,
          "save-bundle": false,
          "save-dev": false,
          "save-exact": false,
          "save-optional": false,
          "save-prefix": "^",
          "save-prod": false,
          scope: "",
          "script-shell": void 0,
          "scripts-prepend-node-path": "warn-only",
          searchopts: "",
          searchexclude: null,
          searchlimit: 20,
          searchstaleness: 15 * 60,
          "send-metrics": false,
          shell: osenv.shell(),
          shrinkwrap: true,
          "sign-git-commit": false,
          "sign-git-tag": false,
          "sso-poll-frequency": 500,
          "sso-type": "oauth",
          "strict-ssl": true,
          tag: "latest",
          "tag-version-prefix": "v",
          timing: false,
          tmp: temp,
          unicode: hasUnicode2(),
          "unsafe-perm": process.platform === "win32" || process.platform === "cygwin" || !(process.getuid && process.setuid && process.getgid && process.setgid) || process.getuid() !== 0,
          "update-notifier": true,
          usage: false,
          user: process.platform === "win32" || import_os3.default.type() === "OS400" ? 0 : "nobody",
          userconfig: import_path11.default.resolve(home, ".npmrc"),
          umask: process.umask ? process.umask() : umask.fromString("022"),
          version: false,
          versions: false,
          viewer: process.platform === "win32" ? "browser" : "man",
          _exit: true
        };
        return defaults;
      }
    });
  }
});

// libs/core/src/lib/npm-conf/index.ts
var require_npm_conf = __commonJS({
  "libs/core/src/lib/npm-conf/index.ts"(exports2, module2) {
    "use strict";
    var import_path11 = __toESM(require("path"));
    init_conf();
    init_nerf_dart();
    var { defaults } = require_defaults();
    module2.exports = npmConf3;
    module2.exports.Conf = Conf;
    module2.exports.defaults = Object.assign({}, defaults);
    module2.exports.toNerfDart = toNerfDart;
    function npmConf3(opts) {
      const conf = new Conf(Object.assign({}, defaults));
      const cleanOpts = opts ? Object.keys(opts).reduce((acc, key) => {
        if (opts[key] !== void 0) {
          acc[key] = opts[key];
        }
        return acc;
      }, {}) : {};
      conf.add(cleanOpts, "cli");
      conf.addEnv();
      conf.loadPrefix();
      const projectConf = import_path11.default.resolve(conf["localPrefix"], ".npmrc");
      const userConf = conf["get"]("userconfig");
      if (!conf["get"]("global") && projectConf !== userConf) {
        conf.addFile(projectConf, "project");
      } else {
        conf.add({}, "project");
      }
      conf.addFile(conf["get"]("userconfig"), "user");
      if (conf["get"]("prefix")) {
        const etc = import_path11.default.resolve(conf["get"]("prefix"), "etc");
        conf.root.globalconfig = import_path11.default.resolve(etc, "npmrc");
        conf.root.globalignorefile = import_path11.default.resolve(etc, "npmignore");
      }
      conf.addFile(conf["get"]("globalconfig"), "global");
      conf.loadUser();
      const caFile = conf["get"]("cafile");
      if (caFile) {
        conf.loadCAFile(caFile);
      }
      return conf;
    }
  }
});

// libs/core/src/lib/run-lifecycle.ts
var import_npmlog25, import_p_queue, runScript, npmConf, queue;
var init_run_lifecycle = __esm({
  "libs/core/src/lib/run-lifecycle.ts"() {
    import_npmlog25 = __toESM(require("npmlog"));
    import_p_queue = __toESM(require("p-queue"));
    runScript = require("@npmcli/run-script");
    npmConf = require_npm_conf();
    queue = new import_p_queue.default({ concurrency: 1 });
  }
});

// libs/core/src/lib/npm-publish.ts
var import_fs_extra5, import_libnpmpublish, import_npm_package_arg5, import_npmlog26, import_pify2, readJSON, readJSONAsync;
var init_npm_publish = __esm({
  "libs/core/src/lib/npm-publish.ts"() {
    import_fs_extra5 = __toESM(require("fs-extra"));
    import_libnpmpublish = require("libnpmpublish");
    import_npm_package_arg5 = __toESM(require("npm-package-arg"));
    import_npmlog26 = __toESM(require("npmlog"));
    import_pify2 = __toESM(require("pify"));
    init_otplease();
    init_run_lifecycle();
    readJSON = require("read-package-json");
    readJSONAsync = (0, import_pify2.default)(readJSON);
  }
});

// libs/core/src/lib/npm-run-script.ts
var import_npmlog27, childProcess8;
var init_npm_run_script = __esm({
  "libs/core/src/lib/npm-run-script.ts"() {
    import_npmlog27 = __toESM(require("npmlog"));
    init_get_npm_exec_opts();
    childProcess8 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/output.ts
var import_npmlog28;
var init_output = __esm({
  "libs/core/src/lib/output.ts"() {
    import_npmlog28 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/temp-write.ts
async function tempWrite(fileContent, filePath) {
  const tempPath = tempfile(filePath);
  const write = (0, import_is_stream.default)(fileContent) ? writeStream : writeFileP;
  await (0, import_make_dir.default)(import_path10.default.dirname(tempPath));
  await write(tempPath, fileContent);
  return tempPath;
}
var import_graceful_fs, import_is_stream, import_make_dir, import_path10, import_temp_dir, import_util, uuid, writeFileP, tempfile, writeStream;
var init_temp_write = __esm({
  "libs/core/src/lib/temp-write.ts"() {
    import_graceful_fs = __toESM(require("graceful-fs"));
    import_is_stream = __toESM(require("is-stream"));
    import_make_dir = __toESM(require("make-dir"));
    import_path10 = __toESM(require("path"));
    import_temp_dir = __toESM(require("temp-dir"));
    import_util = require("util");
    uuid = __toESM(require("uuid"));
    writeFileP = (0, import_util.promisify)(import_graceful_fs.default.writeFile);
    tempfile = (filePath) => import_path10.default.join(import_temp_dir.default, uuid.v4(), filePath || "");
    writeStream = async (filePath, fileContent) => new Promise((resolve, reject) => {
      const writable = import_graceful_fs.default.createWriteStream(filePath);
      fileContent.on("error", (error) => {
        reject(error);
        fileContent.unpipe(writable);
        writable.end();
      }).pipe(writable).on("error", reject).on("finish", resolve);
    });
    tempWrite.sync = (fileContent, filePath) => {
      const tempPath = tempfile(filePath);
      import_make_dir.default.sync(import_path10.default.dirname(tempPath));
      import_graceful_fs.default.writeFileSync(tempPath, fileContent);
      return tempPath;
    };
  }
});

// libs/core/src/lib/get-packed.ts
var import_fs_extra6, import_ssri, import_tar;
var init_get_packed = __esm({
  "libs/core/src/lib/get-packed.ts"() {
    import_fs_extra6 = __toESM(require("fs-extra"));
    import_ssri = __toESM(require("ssri"));
    import_tar = __toESM(require("tar"));
  }
});

// libs/core/src/lib/pack-directory.ts
var import_npm_packlist, import_npmlog29, import_tar2;
var init_pack_directory = __esm({
  "libs/core/src/lib/pack-directory.ts"() {
    import_npm_packlist = __toESM(require("npm-packlist"));
    import_npmlog29 = __toESM(require("npmlog"));
    import_tar2 = __toESM(require("tar"));
    init_temp_write();
    init_get_packed();
    init_package();
    init_run_lifecycle();
  }
});

// libs/core/src/lib/profiler.ts
var import_fs_extra7, import_npmlog30, import_upath;
var init_profiler = __esm({
  "libs/core/src/lib/profiler.ts"() {
    import_fs_extra7 = __toESM(require("fs-extra"));
    import_npmlog30 = __toESM(require("npmlog"));
    import_upath = __toESM(require("upath"));
  }
});

// libs/core/src/lib/pulse-till-done.ts
var import_npmlog31;
var init_pulse_till_done = __esm({
  "libs/core/src/lib/pulse-till-done.ts"() {
    import_npmlog31 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/rimraf-dir.ts
var import_npmlog32, import_path_exists, childProcess9, RIMRAF_CLI;
var init_rimraf_dir = __esm({
  "libs/core/src/lib/rimraf-dir.ts"() {
    "use strict";
    import_npmlog32 = __toESM(require("npmlog"));
    import_path_exists = __toESM(require("path-exists"));
    childProcess9 = require("@lerna/child-process");
    RIMRAF_CLI = require.resolve("rimraf/bin");
  }
});

// libs/core/src/lib/run-topologically.ts
var import_p_queue2;
var init_run_topologically = __esm({
  "libs/core/src/lib/run-topologically.ts"() {
    import_p_queue2 = __toESM(require("p-queue"));
    init_query_graph();
  }
});

// libs/core/src/lib/scm-clients/github/create-github-client.ts
var import_npmlog33, import_rest, import_git_url_parse, childProcess10;
var init_create_github_client = __esm({
  "libs/core/src/lib/scm-clients/github/create-github-client.ts"() {
    import_npmlog33 = __toESM(require("npmlog"));
    import_rest = require("@octokit/rest");
    import_git_url_parse = __toESM(require("git-url-parse"));
    childProcess10 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/scm-clients/gitlab/gitlab-client.ts
var import_node_fetch, import_npmlog34;
var init_gitlab_client = __esm({
  "libs/core/src/lib/scm-clients/gitlab/gitlab-client.ts"() {
    import_node_fetch = __toESM(require("node-fetch"));
    import_npmlog34 = __toESM(require("npmlog"));
  }
});

// libs/core/src/lib/scm-clients/gitlab/create-gitlab-client.ts
var import_npmlog35;
var init_create_gitlab_client = __esm({
  "libs/core/src/lib/scm-clients/gitlab/create-gitlab-client.ts"() {
    import_npmlog35 = __toESM(require("npmlog"));
    init_gitlab_client();
  }
});

// libs/core/src/lib/scm-clients/index.ts
var init_scm_clients = __esm({
  "libs/core/src/lib/scm-clients/index.ts"() {
    init_create_github_client();
    init_create_gitlab_client();
  }
});

// libs/core/src/lib/symlink-binary/index.ts
var import_fs_extra8, import_p_map3;
var init_symlink_binary = __esm({
  "libs/core/src/lib/symlink-binary/index.ts"() {
    import_fs_extra8 = __toESM(require("fs-extra"));
    import_p_map3 = __toESM(require("p-map"));
    init_create_symlink();
    init_package();
  }
});

// libs/core/src/lib/resolve-symlink.ts
var import_fs_extra9, import_npmlog36, readCmdShim;
var init_resolve_symlink = __esm({
  "libs/core/src/lib/resolve-symlink.ts"() {
    import_fs_extra9 = __toESM(require("fs-extra"));
    import_npmlog36 = __toESM(require("npmlog"));
    readCmdShim = require("read-cmd-shim");
  }
});

// libs/core/src/lib/symlink-dependencies.ts
var import_fs_extra10, import_p_map4, import_p_map_series;
var init_symlink_dependencies = __esm({
  "libs/core/src/lib/symlink-dependencies.ts"() {
    import_fs_extra10 = __toESM(require("fs-extra"));
    import_p_map4 = __toESM(require("p-map"));
    import_p_map_series = __toESM(require("p-map-series"));
    init_create_symlink();
    init_resolve_symlink();
    init_symlink_binary();
  }
});

// libs/core/src/lib/timer.ts
var init_timer = __esm({
  "libs/core/src/lib/timer.ts"() {
  }
});

// libs/core/src/lib/npm-dist-tag.ts
var npm_dist_tag_exports = {};
__export(npm_dist_tag_exports, {
  add: () => add,
  list: () => list,
  remove: () => remove
});
function add(spec, tag, options, otpCache) {
  const opts = {
    log: import_npmlog37.default,
    ...options,
    spec: (0, import_npm_package_arg6.default)(spec)
  };
  const cleanTag = (tag || opts.defaultTag || opts.tag).trim();
  const { name, rawSpec: version } = opts.spec;
  opts.log.verbose("dist-tag", `adding "${cleanTag}" to ${name}@${version}`);
  if (opts.dryRun) {
    opts.log.silly("dist-tag", "dry-run configured, bailing now");
    return Promise.resolve();
  }
  return fetchTags(opts).then((tags) => {
    if (tags[cleanTag] === version) {
      opts.log.warn("dist-tag", `${name}@${cleanTag} already set to ${version}`);
      return tags;
    }
    const uri = `/-/package/${opts.spec.escapedName}/dist-tags/${encodeURIComponent(cleanTag)}`;
    const payload = {
      ...opts,
      method: "PUT",
      body: JSON.stringify(version),
      headers: {
        "content-type": "application/json"
      },
      spec: opts.spec
    };
    return otplease((wrappedPayload) => (0, import_npm_registry_fetch.default)(uri, wrappedPayload), payload, otpCache).then(() => {
      opts.log.verbose("dist-tag", `added "${cleanTag}" to ${name}@${version}`);
      tags[cleanTag] = version;
      return tags;
    });
  });
}
function remove(spec, tag, options, otpCache) {
  const opts = {
    log: import_npmlog37.default,
    ...options,
    spec: (0, import_npm_package_arg6.default)(spec)
  };
  opts.log.verbose("dist-tag", `removing "${tag}" from ${opts.spec.name}`);
  if (opts.dryRun) {
    opts.log.silly("dist-tag", "dry-run configured, bailing now");
    return Promise.resolve();
  }
  return fetchTags(opts).then((tags) => {
    const version = tags[tag];
    if (!version) {
      opts.log.info("dist-tag", `"${tag}" is not a dist-tag on ${opts.spec.name}`);
      return tags;
    }
    const uri = `/-/package/${opts.spec.escapedName}/dist-tags/${encodeURIComponent(tag)}`;
    const payload = {
      ...opts,
      method: "DELETE",
      spec: opts.spec
    };
    return otplease((wrappedPayload) => (0, import_npm_registry_fetch.default)(uri, wrappedPayload), payload, otpCache).then(() => {
      opts.log.verbose("dist-tag", `removed "${tag}" from ${opts.spec.name}@${version}`);
      delete tags[tag];
      return tags;
    });
  });
}
function list(spec, options) {
  const opts = {
    log: import_npmlog37.default,
    ...options,
    spec: (0, import_npm_package_arg6.default)(spec)
  };
  if (opts.dryRun) {
    opts.log.silly("dist-tag", "dry-run configured, bailing now");
    return Promise.resolve();
  }
  return fetchTags(opts);
}
function fetchTags(opts) {
  return import_npm_registry_fetch.default.json(`/-/package/${opts.spec.escapedName}/dist-tags`, {
    ...opts,
    preferOnline: true,
    spec: opts.spec
  }).then((data) => {
    if (data && typeof data === "object") {
      delete data["_etag"];
    }
    return data || {};
  });
}
var import_npm_package_arg6, import_npm_registry_fetch, import_npmlog37;
var init_npm_dist_tag = __esm({
  "libs/core/src/lib/npm-dist-tag.ts"() {
    import_npm_package_arg6 = __toESM(require("npm-package-arg"));
    import_npm_registry_fetch = __toESM(require("npm-registry-fetch"));
    import_npmlog37 = __toESM(require("npmlog"));
    init_otplease();
  }
});

// libs/core/src/index.ts
var npmConf2, npmDistTag;
var init_src = __esm({
  "libs/core/src/index.ts"() {
    init_check_working_tree();
    init_cli();
    init_collect_updates();
    init_command();
    init_conventional_commits();
    init_create_symlink();
    init_describe_ref();
    init_filter_options();
    init_has_npm_version();
    init_listable_format();
    init_listable_options();
    init_log_packed();
    init_npm_install();
    init_npm_publish();
    init_npm_run_script();
    init_otplease();
    init_output();
    init_pack_directory();
    init_package();
    init_package_graph();
    init_prerelease_id_from_version();
    init_profiler();
    init_project();
    init_prompt();
    init_pulse_till_done();
    init_rimraf_dir();
    init_run_lifecycle();
    init_run_topologically();
    init_scm_clients();
    init_symlink_binary();
    init_symlink_dependencies();
    init_temp_write();
    init_timer();
    init_validation_error();
    npmConf2 = require_npm_conf();
    npmDistTag = (init_npm_dist_tag(), __toCommonJS(npm_dist_tag_exports));
  }
});

// libs/commands/create/src/lib/builtin-npmrc.ts
var require_builtin_npmrc = __commonJS({
  "libs/commands/create/src/lib/builtin-npmrc.ts"(exports2, module2) {
    var import_fs_extra11 = __toESM(require("fs-extra"));
    var import_path11 = __toESM(require("path"));
    module2.exports.builtinNpmrc = builtinNpmrc;
    function builtinNpmrc() {
      let resolvedPath = "";
      try {
        resolvedPath = import_path11.default.resolve(
          import_fs_extra11.default.realpathSync(import_path11.default.join(import_path11.default.dirname(process.execPath), "npm")),
          "../../npmrc"
        );
      } catch (err) {
      }
      return resolvedPath;
    }
  }
});

// libs/commands/create/src/lib/cat-file.ts
var require_cat_file = __commonJS({
  "libs/commands/create/src/lib/cat-file.ts"(exports2, module2) {
    var import_fs_extra11 = __toESM(require("fs-extra"));
    var import_path11 = __toESM(require("path"));
    module2.exports.catFile = catFile;
    function catFile(baseDir, fileName, content, opts = "utf8") {
      return import_fs_extra11.default.writeFile(import_path11.default.join(baseDir, fileName), `${content}
`, opts);
    }
  }
});

// libs/commands/create/src/index.ts
var require_src = __commonJS({
  "libs/commands/create/src/index.ts"(exports2, module2) {
    init_src();
    var import_dedent5 = __toESM(require("dedent"));
    var import_fs_extra11 = __toESM(require("fs-extra"));
    var import_npm_package_arg7 = __toESM(require("npm-package-arg"));
    var import_os3 = __toESM(require("os"));
    var import_p_reduce = __toESM(require("p-reduce"));
    var import_pacote = __toESM(require("pacote"));
    var import_path11 = __toESM(require("path"));
    var import_slash2 = __toESM(require("slash"));
    var import_url2 = require("url");
    var import_yargs_parser = require("yargs-parser");
    var childProcess11 = require("@lerna/child-process");
    var initPackageJson = require("pify")(require("init-package-json"));
    var { builtinNpmrc } = require_builtin_npmrc();
    var { catFile } = require_cat_file();
    var LERNA_MODULE_DATA = require.resolve(import_path11.default.join(__dirname, "./lib/lerna-module-data.js"));
    var DEFAULT_DESCRIPTION = [
      "Now I\u2019m the model of a modern major general",
      "The venerated Virginian veteran whose men are all",
      "Lining up, to put me up on a pedestal",
      "Writin\u2019 letters to relatives",
      "Embellishin\u2019 my elegance and eloquence",
      "But the elephant is in the room",
      "The truth is in ya face when ya hear the British cannons go",
      "BOOM"
    ].join(" / ");
    module2.exports = function factory(argv) {
      return new CreateCommand(argv);
    };
    var CreateCommand = class extends Command {
      initialize() {
        const {
          bin,
          description = DEFAULT_DESCRIPTION,
          esModule,
          keywords,
          license,
          loc: pkgLocation,
          name: pkgName,
          yes
        } = this.options;
        const { name, scope } = (0, import_npm_package_arg7.default)(pkgName);
        if (!name && pkgName.includes("/")) {
          throw new ValidationError(
            "ENOPKGNAME",
            "Invalid package name. Use the <loc> positional to specify package directory.\nSee https://github.com/lerna/lerna/tree/main/commands/create#usage for details."
          );
        }
        this.dirName = scope ? name.split("/").pop() : name;
        this.pkgName = name;
        this.pkgsDir = this._getPackagesDir(pkgLocation);
        this.camelName = (0, import_yargs_parser.camelCase)(this.dirName);
        this.outDir = esModule ? "dist" : "lib";
        this.targetDir = import_path11.default.resolve(this.pkgsDir, this.dirName);
        this.binDir = import_path11.default.join(this.targetDir, "bin");
        this.binFileName = bin === true ? this.dirName : bin;
        this.libDir = import_path11.default.join(this.targetDir, esModule ? "src" : "lib");
        this.libFileName = `${this.dirName}.js`;
        this.testDir = import_path11.default.join(this.targetDir, "__tests__");
        this.testFileName = `${this.dirName}.test.js`;
        this.conf = npmConf2({
          description,
          esModule,
          keywords,
          scope,
          yes
        });
        this.conf.addFile(builtinNpmrc(), "builtin");
        this.conf.set("init-main", `${this.outDir}/${this.libFileName}`);
        if (esModule) {
          this.conf.set("init-es-module", `${this.outDir}/${this.dirName}.module.js`);
        }
        if (!this.project.isIndependent()) {
          this.conf.set("init-version", this.project.version);
        }
        if (this.conf.get("init-author-name") === "") {
          this.conf.set("init-author-name", this.gitConfig("user.name"));
        }
        if (this.conf.get("init-author-email") === "") {
          this.conf.set("init-author-email", this.gitConfig("user.email"));
        }
        if (license) {
          this.conf.set("init-license", license);
        }
        if (this.options.private) {
          this.conf.set("private", true);
        }
        if (this.options.loglevel === "silent") {
          this.conf.set("silent", true);
        }
        if (this.binFileName) {
          this.conf.set("bin", {
            [this.binFileName]: `bin/${this.binFileName}`
          });
        }
        this.conf.set("directories", {
          lib: this.outDir,
          test: "__tests__"
        });
        this.setFiles();
        this.setHomepage();
        this.setPublishConfig();
        this.setRepository();
        return Promise.resolve(this.setDependencies());
      }
      _getPackagesDir(pkgLocation) {
        const packageParentDirs = this.project.packageParentDirs;
        if (!pkgLocation) {
          return packageParentDirs[0];
        }
        const normalizedPkgLocation = import_path11.default.resolve(this.project.rootPath, import_path11.default.normalize(pkgLocation)).toLowerCase();
        const packageParentDirsLower = packageParentDirs.map((p) => p.toLowerCase());
        const matchingPathIndex = packageParentDirsLower.findIndex((p) => p.indexOf(normalizedPkgLocation) > -1);
        if (matchingPathIndex > -1) {
          return packageParentDirs[matchingPathIndex];
        }
        throw new ValidationError(
          "ENOPKGDIR",
          `Location "${pkgLocation}" is not configured as a workspace directory.`
        );
      }
      execute() {
        let chain = Promise.resolve();
        chain = chain.then(() => import_fs_extra11.default.mkdirp(this.libDir));
        chain = chain.then(() => import_fs_extra11.default.mkdirp(this.testDir));
        chain = chain.then(() => Promise.all([this.writeReadme(), this.writeLibFile(), this.writeTestFile()]));
        if (this.binFileName) {
          chain = chain.then(() => import_fs_extra11.default.mkdirp(this.binDir));
          chain = chain.then(() => Promise.all([this.writeBinFile(), this.writeCliFile(), this.writeCliTest()]));
        }
        chain = chain.then(() => initPackageJson(this.targetDir, LERNA_MODULE_DATA, this.conf));
        return chain.then((data) => {
          if (this.options.esModule) {
            this.logger.notice(
              "\u2714",
              import_dedent5.default`
              Ensure '${import_path11.default.relative(".", this.pkgsDir)}/*/${this.outDir}' has been added to ./.gitignore
              Ensure rollup or babel build scripts are in the root
            `
            );
          }
          this.logger.success(
            "create",
            `New package ${data.name} created at ./${import_path11.default.relative(".", this.targetDir)}`
          );
        });
      }
      gitConfig(prop) {
        return childProcess11.execSync("git", ["config", "--get", prop], this.execOpts);
      }
      collectExternalVersions() {
        const extVersions = /* @__PURE__ */ new Map();
        for (const { externalDependencies } of this.packageGraph.values()) {
          for (const [name, resolved] of externalDependencies) {
            extVersions.set(name, resolved.fetchSpec);
          }
        }
        return extVersions;
      }
      hasLocalRelativeFileSpec() {
        for (const { localDependencies } of this.packageGraph.values()) {
          for (const spec of localDependencies.values()) {
            if (spec.type === "directory") {
              return true;
            }
          }
        }
      }
      resolveRelative(depNode) {
        const relPath = import_path11.default.relative(this.targetDir, depNode.location);
        const spec = import_npm_package_arg7.default.resolve(depNode.name, relPath, this.targetDir);
        return (0, import_slash2.default)(spec.saveSpec);
      }
      setDependencies() {
        const inputs = new Set((this.options.dependencies || []).sort());
        if (this.options.bin) {
          inputs.add("yargs");
        }
        if (!inputs.size) {
          return;
        }
        const exts = this.collectExternalVersions();
        const localRelative = this.hasLocalRelativeFileSpec();
        const savePrefix = this.conf.get("save-exact") ? "" : this.conf.get("save-prefix");
        const pacoteOpts = this.conf.snapshot;
        const decideVersion = (spec) => {
          if (this.packageGraph.has(spec.name)) {
            const depNode = this.packageGraph.get(spec.name);
            if (localRelative) {
              return this.resolveRelative(depNode);
            }
            return `${savePrefix}${depNode.version}`;
          }
          if (spec.type === "tag" && spec.fetchSpec === "latest") {
            if (exts.has(spec.name)) {
              return exts.get(spec.name);
            }
            return import_pacote.default.manifest(spec, pacoteOpts).then((pkg) => `${savePrefix}${pkg.version}`);
          }
          if (spec.type === "git") {
            throw new ValidationError("EGIT", "Do not use git dependencies");
          }
          return spec.rawSpec;
        };
        let chain = Promise.resolve();
        chain = chain.then(
          () => (0, import_p_reduce.default)(
            inputs,
            (obj, input) => {
              const spec = (0, import_npm_package_arg7.default)(input);
              return Promise.resolve(spec).then(decideVersion).then((version) => {
                obj[spec.name] = version;
                return obj;
              });
            },
            {}
          )
        );
        chain = chain.then((dependencies) => {
          this.conf.set("dependencies", dependencies);
        });
        return chain;
      }
      setFiles() {
        const files = [this.outDir];
        if (this.options.bin) {
          files.unshift("bin");
        }
        this.conf.set("files", files);
      }
      setHomepage() {
        let { homepage = this.project.manifest.get("homepage") } = this.options;
        if (!homepage) {
          return;
        }
        if (homepage.indexOf("http") !== 0) {
          homepage = `http://${homepage}`;
        }
        const hurl = new import_url2.URL(homepage);
        const relativeTarget = import_path11.default.relative(this.project.rootPath, this.targetDir);
        if (hurl.hostname.match("github")) {
          hurl.pathname = import_path11.default.posix.join(hurl.pathname, "tree/main", relativeTarget);
          hurl.hash = "readme";
        } else if (!this.options.homepage) {
          hurl.pathname = import_path11.default.posix.join(hurl.pathname, relativeTarget);
        }
        this.conf.set("homepage", hurl.href);
      }
      setPublishConfig() {
        const scope = this.conf.get("scope");
        const registry = this.options.registry || this.conf.get(`${scope}:registry`) || this.conf.get("registry");
        const isPublicRegistry = registry === this.conf.root.registry;
        const publishConfig = {};
        if (scope && isPublicRegistry) {
          publishConfig.access = this.options.access || "public";
        }
        if (registry && !isPublicRegistry) {
          publishConfig.registry = registry;
        }
        if (this.options.tag) {
          publishConfig.tag = this.options.tag;
        }
        if (Object.keys(publishConfig).length) {
          this.conf.set("publishConfig", publishConfig);
        }
      }
      setRepository() {
        try {
          const url2 = childProcess11.execSync("git", ["remote", "get-url", "origin"], this.execOpts);
          this.conf.set("repository", url2);
        } catch (err) {
          this.logger.warn("ENOREMOTE", "No git remote found, skipping repository property");
        }
      }
      writeReadme() {
        const readmeContent = import_dedent5.default`
      # \`${this.pkgName}\`

      > ${this.options.description || "TODO: description"}

      ## Usage

      \`\`\`
      ${this.options.bin ? import_dedent5.default`
            npm -g i ${this.pkgName}

            ${this.binFileName} --help
          ` : this.options.esModule ? `import ${this.camelName} from '${this.pkgName}';` : `const ${this.camelName} = require('${this.pkgName}');`}

      // TODO: DEMONSTRATE API
      \`\`\`
    `;
        return catFile(this.targetDir, "README.md", readmeContent);
      }
      writeLibFile() {
        const libContent = this.options.esModule ? import_dedent5.default`
        export default function ${this.camelName}() {
          return 'Hello from ${this.camelName}';
        }
      ` : import_dedent5.default`
        'use strict';

        module.exports = ${this.camelName};

        function ${this.camelName}() {
          return 'Hello from ${this.camelName}';
        }
    `;
        return catFile(this.libDir, this.libFileName, libContent);
      }
      writeTestFile() {
        const testContent = this.options.esModule ? import_dedent5.default`
        import ${this.camelName} from '../src/${this.dirName}.js';
        import { strict as assert } from 'assert';

        assert.strictEqual(${this.camelName}(), 'Hello from ${this.camelName}');
        console.info('${this.camelName} tests passed');
      ` : import_dedent5.default`
        'use strict';

        const ${this.camelName} = require('..');
        const assert = require('assert').strict;

        assert.strictEqual(${this.camelName}(), 'Hello from ${this.camelName}');
        console.info('${this.camelName} tests passed');
      `;
        return catFile(this.testDir, this.testFileName, testContent);
      }
      writeCliFile() {
        const cliFileName = "cli.js";
        const cliContent = [
          this.options.esModule ? import_dedent5.default`
          import factory from 'yargs/yargs';
          import ${this.camelName} from './${this.dirName}';

          export default cli;
        ` : import_dedent5.default`
          'use strict';

          const factory = require('yargs/yargs');
          const ${this.camelName} = require('./${this.dirName}');

          module.exports = cli;
        `,
          "",
          import_dedent5.default`
        function cli(cwd) {
          const parser = factory(null, cwd);

          parser.alias('h', 'help');
          parser.alias('v', 'version');

          parser.usage(
            "$0",
            "TODO: description",
            yargs => {
              yargs.options({
                // TODO: options
              });
            },
            argv => ${this.camelName}(argv)
          );

          return parser;
        }
      `
        ].join(import_os3.default.EOL);
        return catFile(this.libDir, cliFileName, cliContent);
      }
      writeCliTest() {
        const cliTestFileName = "cli.test.js";
        const cliTestContent = [
          this.options.esModule ? import_dedent5.default`
          import cli from '../src/cli';
        ` : import_dedent5.default`
          'use strict';

          const cli = require('../lib/cli');
        `,
          "",
          import_dedent5.default`
        describe('${this.pkgName} cli', () => {
          // const argv = cli(cwd).parse(['args']);
          it('needs tests');
        });
      `
        ].join(import_os3.default.EOL);
        return catFile(this.testDir, cliTestFileName, cliTestContent);
      }
      writeBinFile() {
        const binContent = import_dedent5.default`
      #!/usr/bin/env node

      'use strict';

      // eslint-disable-next-line no-unused-expressions
      require('../${this.outDir}/cli')${this.options.esModule ? ".default" : ""}().parse(process.argv.slice(2));`;
        return catFile(this.binDir, this.binFileName, binContent, { mode: 493 });
      }
    };
    module2.exports.CreateCommand = CreateCommand;
  }
});

// packages/legacy-structure/commands/create/src/index.ts
var index = require_src();
module.exports = index;
module.exports.CreateCommand = index.CreateCommand;
