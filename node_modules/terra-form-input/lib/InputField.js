"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireDefault(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _terraFormField = _interopRequireDefault(require("terra-form-field"));
var _IconError = _interopRequireDefault(require("terra-icon/lib/icon/IconError"));
var _Input = _interopRequireDefault(require("./Input"));
var _excluded = ["defaultValue", "disabled", "error", "errorIcon", "help", "hideRequired", "inputAttrs", "inputId", "isIncomplete", "isInline", "isInvalid", "isLabelHidden", "label", "labelAttrs", "maxWidth", "onChange", "onInput", "refCallback", "required", "showOptional", "type", "value"];
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
var propTypes = {
  /**
   * Id of the input. Populates both the input and the htmlFor prop of the wrapper Field.
   */
  inputId: _propTypes.default.string.isRequired,
  /**
   * The label of the form control children.
   */
  label: _propTypes.default.string.isRequired,
  /**
   * The defaultValue of the input field. Use this to create an uncontrolled input.
   */
  defaultValue: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
  /**
   * Whether the input is disabled.
   */
  disabled: _propTypes.default.bool,
  /**
   * Error message for when the input is invalid.
   */
  error: _propTypes.default.node,
  /**
   * Error Icon to display when the input is invalid.
   */
  errorIcon: _propTypes.default.element,
  /**
   * Help element to display with the input.
   */
  help: _propTypes.default.node,
  /**
   * @private
   * Whether or not to hide the required indicator on the label.
   */
  hideRequired: _propTypes.default.bool,
  /**
   * Attributes to attach to the input object
   */
  // eslint-disable-next-line react/forbid-prop-types
  inputAttrs: _propTypes.default.object,
  /**
   * Whether the field and input displays as Incomplete. Use when no value has been provided. _(usage note: `required` must also be set)_.
   */
  isIncomplete: _propTypes.default.bool,
  /**
   * Whether or not the field is an inline field.
   */
  isInline: _propTypes.default.bool,
  /**
   * Whether the field and input displays as Invalid. Use when value does not meet validation pattern.
   */
  isInvalid: _propTypes.default.bool,
  /**
   * @private
   * Whether or not the label is visible. Use this props to hide a label while still creating it on the DOM for accessibility.
   */
  isLabelHidden: _propTypes.default.bool,
  /**
   * Attributes to attach to the label.
   */
  // eslint-disable-next-line react/forbid-prop-types
  labelAttrs: _propTypes.default.object,
  /**
   * Set the max-width of a field using `length` or `%`.  Best practice recommendation to never exceed
   * a rendered value of 1020px. _(Note: Providing custom inline styles will take precedence.)_
   */
  maxWidth: _propTypes.default.string,
  /**
   * Function to trigger when user changes the input value. Provide a function to create a controlled input.
   */
  onChange: _propTypes.default.func,
  /**
   * Function to trigger when user inputs a value. Use when programmatically setting a value. Sends parameter {Event} event.
   */
  onInput: _propTypes.default.func,
  /**
   * Ref callback to pass into the ref attribute of the html input element.
   */
  refCallback: _propTypes.default.func,
  /**
   * Whether or not the field is required.
   */
  required: _propTypes.default.bool,
  /**
   * Whether or not to append the 'optional' label to a non-required field label.
   */
  showOptional: _propTypes.default.bool,
  /**
   * Specifies the type of input element to display.
   */
  type: _propTypes.default.string,
  /**
   * The value of the input field. Use this to create a controlled input.
   */
  value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number])
};
var defaultProps = {
  defaultValue: undefined,
  disabled: false,
  error: null,
  errorIcon: /*#__PURE__*/_react.default.createElement(_IconError.default, null),
  help: null,
  hideRequired: false,
  inputAttrs: {},
  isIncomplete: false,
  isInline: false,
  isInvalid: false,
  isLabelHidden: false,
  labelAttrs: {},
  onChange: undefined,
  onInput: undefined,
  maxWidth: undefined,
  refCallback: undefined,
  required: false,
  showOptional: false,
  type: undefined,
  value: undefined
};
var InputField = function InputField(props) {
  var defaultValue = props.defaultValue,
    disabled = props.disabled,
    error = props.error,
    errorIcon = props.errorIcon,
    help = props.help,
    hideRequired = props.hideRequired,
    inputAttrs = props.inputAttrs,
    inputId = props.inputId,
    isIncomplete = props.isIncomplete,
    isInline = props.isInline,
    isInvalid = props.isInvalid,
    isLabelHidden = props.isLabelHidden,
    label = props.label,
    labelAttrs = props.labelAttrs,
    maxWidth = props.maxWidth,
    onChange = props.onChange,
    onInput = props.onInput,
    refCallback = props.refCallback,
    required = props.required,
    showOptional = props.showOptional,
    type = props.type,
    value = props.value,
    customProps = _objectWithoutProperties(props, _excluded);
  var ariaDescriptionIds;
  if (help && error && isInvalid) {
    ariaDescriptionIds = "".concat(inputId, "-error ").concat(inputId, "-help");
  } else {
    if (help) {
      ariaDescriptionIds = "".concat(inputId, "-help");
    }
    if (error && isInvalid) {
      ariaDescriptionIds = "".concat(inputId, "-error");
    }
  }
  var inputType = type || inputAttrs.type;
  if (customProps.placeholder) {
    customProps.placeholder = null;
  }
  return /*#__PURE__*/_react.default.createElement(_terraFormField.default, _extends({
    label: label,
    labelAttrs: labelAttrs,
    error: error,
    errorIcon: errorIcon,
    help: help,
    hideRequired: hideRequired,
    required: required,
    showOptional: showOptional,
    isInvalid: isInvalid,
    isInline: isInline,
    isLabelHidden: isLabelHidden,
    htmlFor: inputId,
    maxWidth: maxWidth
  }, customProps), /*#__PURE__*/_react.default.createElement(_Input.default, _extends({}, inputAttrs, {
    disabled: inputAttrs.disabled || disabled,
    id: inputId,
    isIncomplete: isIncomplete,
    type: inputType,
    onChange: onChange,
    onInput: onInput,
    value: value,
    defaultValue: defaultValue,
    refCallback: refCallback,
    "aria-describedby": ariaDescriptionIds
  })));
};
InputField.propTypes = propTypes;
InputField.defaultProps = defaultProps;
var _default = InputField;
exports.default = _default;