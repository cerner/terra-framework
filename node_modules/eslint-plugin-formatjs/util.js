"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractMessages = void 0;
var tslib_1 = require("tslib");
var FORMAT_FUNCTION_NAMES = new Set(['$formatMessage', 'formatMessage']);
var COMPONENT_NAMES = new Set(['FormattedMessage']);
var DECLARATION_FUNCTION_NAMES = new Set(['defineMessage']);
function isStringLiteral(node) {
    return node.type === 'Literal' && typeof node.value === 'string';
}
function isTemplateLiteralWithoutVar(node) {
    return node.type === 'TemplateLiteral' && node.quasis.length === 1;
}
function staticallyEvaluateStringConcat(node) {
    if (!isStringLiteral(node.right)) {
        return ['', false];
    }
    if (isStringLiteral(node.left)) {
        return [String(node.left.value) + node.right.value, true];
    }
    if (node.left.type === 'BinaryExpression') {
        var _a = staticallyEvaluateStringConcat(node.left), result = _a[0], isStaticallyEvaluatable = _a[1];
        return [result + node.right.value, isStaticallyEvaluatable];
    }
    return ['', false];
}
function isIntlFormatMessageCall(node) {
    return (node.type === 'CallExpression' &&
        node.callee.type === 'MemberExpression' &&
        node.callee.object.type === 'Identifier' &&
        node.callee.object.name === 'intl' &&
        node.callee.property.type === 'Identifier' &&
        node.callee.property.name === 'formatMessage' &&
        node.arguments.length >= 1 &&
        node.arguments[0].type === 'ObjectExpression');
}
function isSingleMessageDescriptorDeclaration(node, functionNames) {
    return (node.type === 'CallExpression' &&
        node.callee.type === 'Identifier' &&
        functionNames.has(node.callee.name));
}
function isMultipleMessageDescriptorDeclaration(node) {
    return (node.type === 'CallExpression' &&
        node.callee.type === 'Identifier' &&
        node.callee.name === 'defineMessages');
}
function extractMessageDescriptor(node) {
    if (!node || node.type !== 'ObjectExpression') {
        return;
    }
    var result = {
        message: {},
        messageNode: undefined,
        messagePropNode: undefined,
        descriptionNode: undefined,
        idValueNode: undefined,
    };
    for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
        var prop = _a[_i];
        if (prop.type !== 'Property' || prop.key.type !== 'Identifier') {
            continue;
        }
        var valueNode = prop.value;
        var value = undefined;
        if (isStringLiteral(valueNode)) {
            value = valueNode.value;
        }
        else if (isTemplateLiteralWithoutVar(valueNode)) {
            value = valueNode.quasis[0].value.cooked;
        }
        else if (valueNode.type === 'BinaryExpression') {
            var _b = staticallyEvaluateStringConcat(valueNode), result_1 = _b[0], isStatic = _b[1];
            if (isStatic) {
                value = result_1;
            }
        }
        switch (prop.key.name) {
            case 'defaultMessage':
                result.messagePropNode = prop;
                result.messageNode = valueNode;
                result.message.defaultMessage = value;
                break;
            case 'description':
                result.descriptionNode = valueNode;
                result.message.description = value;
                break;
            case 'id':
                result.message.id = value;
                result.idValueNode = valueNode;
                result.idPropNode = prop;
                break;
        }
    }
    return result;
}
function extractMessageDescriptorFromJSXElement(node) {
    if (!node || !node.attributes) {
        return;
    }
    var values;
    var result = {
        message: {},
        messageNode: undefined,
        messagePropNode: undefined,
        descriptionNode: undefined,
        idValueNode: undefined,
        idPropNode: undefined,
    };
    var hasSpreadAttribute = false;
    for (var _i = 0, _a = node.attributes; _i < _a.length; _i++) {
        var prop = _a[_i];
        // We can't analyze spread attr
        if (prop.type === 'JSXSpreadAttribute') {
            hasSpreadAttribute = true;
        }
        if (prop.type !== 'JSXAttribute' || prop.name.type !== 'JSXIdentifier') {
            continue;
        }
        var key = prop.name;
        var valueNode = prop.value;
        var value = undefined;
        if (valueNode) {
            if (isStringLiteral(valueNode)) {
                value = valueNode.value;
            }
            else if ((valueNode === null || valueNode === void 0 ? void 0 : valueNode.type) === 'JSXExpressionContainer') {
                var expression = valueNode.expression;
                if (expression.type === 'BinaryExpression') {
                    var _b = staticallyEvaluateStringConcat(expression), result_2 = _b[0], isStatic = _b[1];
                    if (isStatic) {
                        value = result_2;
                    }
                }
                else if (isTemplateLiteralWithoutVar(expression)) {
                    value = expression.quasis[0].value.cooked;
                }
            }
        }
        switch (key.name) {
            case 'defaultMessage':
                result.messagePropNode = prop;
                result.messageNode = valueNode;
                if (value) {
                    result.message.defaultMessage = value;
                }
                break;
            case 'description':
                result.descriptionNode = valueNode;
                if (value) {
                    result.message.description = value;
                }
                break;
            case 'id':
                result.idValueNode = valueNode;
                result.idPropNode = prop;
                if (value) {
                    result.message.id = value;
                }
                break;
            case 'values':
                if ((valueNode === null || valueNode === void 0 ? void 0 : valueNode.type) === 'JSXExpressionContainer' &&
                    valueNode.expression.type === 'ObjectExpression') {
                    values = valueNode.expression;
                }
                break;
        }
    }
    if (!result.messagePropNode &&
        !result.descriptionNode &&
        !result.idPropNode &&
        hasSpreadAttribute) {
        return;
    }
    return [result, values];
}
function extractMessageDescriptors(node) {
    if (!node || node.type !== 'ObjectExpression' || !node.properties.length) {
        return [];
    }
    var msgs = [];
    for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
        var prop = _a[_i];
        if (prop.type !== 'Property') {
            continue;
        }
        var msg = prop.value;
        if (msg.type !== 'ObjectExpression') {
            continue;
        }
        var nodeInfo = extractMessageDescriptor(msg);
        if (nodeInfo) {
            msgs.push(nodeInfo);
        }
    }
    return msgs;
}
function extractMessages(node, _a) {
    var _b = _a === void 0 ? {} : _a, additionalComponentNames = _b.additionalComponentNames, additionalFunctionNames = _b.additionalFunctionNames, excludeMessageDeclCalls = _b.excludeMessageDeclCalls;
    var allFormatFunctionNames = Array.isArray(additionalFunctionNames)
        ? new Set((0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], Array.from(FORMAT_FUNCTION_NAMES), true), additionalFunctionNames, true))
        : FORMAT_FUNCTION_NAMES;
    var allComponentNames = Array.isArray(additionalComponentNames)
        ? new Set((0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], Array.from(COMPONENT_NAMES), true), additionalComponentNames, true))
        : COMPONENT_NAMES;
    if (node.type === 'CallExpression') {
        var expr = node;
        var args0 = expr.arguments[0];
        var args1 = expr.arguments[1];
        // We can't really analyze spread element
        if (!args0 || args0.type === 'SpreadElement') {
            return [];
        }
        if ((!excludeMessageDeclCalls &&
            isSingleMessageDescriptorDeclaration(node, DECLARATION_FUNCTION_NAMES)) ||
            isIntlFormatMessageCall(node) ||
            isSingleMessageDescriptorDeclaration(node, allFormatFunctionNames)) {
            var msgDescriptorNodeInfo = extractMessageDescriptor(args0);
            if (msgDescriptorNodeInfo && (!args1 || args1.type !== 'SpreadElement')) {
                return [[msgDescriptorNodeInfo, args1]];
            }
        }
        else if (!excludeMessageDeclCalls &&
            isMultipleMessageDescriptorDeclaration(node)) {
            return extractMessageDescriptors(args0).map(function (msg) { return [msg, undefined]; });
        }
    }
    else if (node.type === 'JSXOpeningElement' &&
        node.name &&
        node.name.type === 'JSXIdentifier' &&
        allComponentNames.has(node.name.name)) {
        var msgDescriptorNodeInfo = extractMessageDescriptorFromJSXElement(node);
        if (msgDescriptorNodeInfo) {
            return [msgDescriptorNodeInfo];
        }
    }
    return [];
}
exports.extractMessages = extractMessages;
