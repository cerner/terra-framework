"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var util_1 = require("../util");
var icu_messageformat_parser_1 = require("@formatjs/icu-messageformat-parser");
var PlaceholderEnforcement = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(PlaceholderEnforcement, _super);
    function PlaceholderEnforcement(message) {
        var _this = _super.call(this) || this;
        _this.message = message;
        return _this;
    }
    return PlaceholderEnforcement;
}(Error));
function keyExistsInExpression(key, values) {
    if (!values) {
        return false;
    }
    if (values.type !== 'ObjectExpression') {
        return true; // True bc we cannot evaluate this
    }
    if (values.properties.find(function (prop) { return prop.type === 'SpreadElement'; })) {
        return true; // True bc there's a spread element
    }
    return !!values.properties.find(function (prop) {
        if (prop.type !== 'Property') {
            return false;
        }
        switch (prop.key.type) {
            case 'Identifier':
                return prop.key.name === key;
            case 'Literal':
                return prop.key.value === key;
        }
        return false;
    });
}
function verifyAst(ast, values, ignoreList) {
    for (var _i = 0, ast_1 = ast; _i < ast_1.length; _i++) {
        var el = ast_1[_i];
        if ((0, icu_messageformat_parser_1.isLiteralElement)(el) || (0, icu_messageformat_parser_1.isPoundElement)(el)) {
            continue;
        }
        var key = el.value;
        if (!ignoreList.has(key) && !keyExistsInExpression(key, values)) {
            throw new PlaceholderEnforcement("Missing value for placeholder \"".concat(el.value, "\""));
        }
        if ((0, icu_messageformat_parser_1.isPluralElement)(el) || (0, icu_messageformat_parser_1.isSelectElement)(el)) {
            for (var _a = 0, _b = Object.keys(el.options); _a < _b.length; _a++) {
                var selector = _b[_a];
                verifyAst(el.options[selector].value, values, ignoreList);
            }
        }
        if ((0, icu_messageformat_parser_1.isTagElement)(el)) {
            verifyAst(el.children, values, ignoreList);
        }
    }
}
function checkNode(context, node) {
    var msgs = (0, util_1.extractMessages)(node, (0, tslib_1.__assign)({ excludeMessageDeclCalls: true }, context.settings));
    var opt = context.options[0];
    var ignoreList = new Set((opt === null || opt === void 0 ? void 0 : opt.ignoreList) || []);
    for (var _i = 0, msgs_1 = msgs; _i < msgs_1.length; _i++) {
        var _a = msgs_1[_i], _b = _a[0], defaultMessage = _b.message.defaultMessage, messageNode = _b.messageNode, values = _a[1];
        if (!defaultMessage || !messageNode) {
            continue;
        }
        try {
            verifyAst((0, icu_messageformat_parser_1.parse)(defaultMessage, {
                ignoreTag: context.settings.ignoreTag,
            }), values, ignoreList);
        }
        catch (e) {
            context.report({
                node: messageNode,
                message: e instanceof Error ? e.message : String(e),
            });
        }
    }
}
var rule = {
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce that all messages with placeholders have enough passed-in values',
            category: 'Errors',
            recommended: true,
            url: 'https://formatjs.io/docs/tooling/linter#enforce-placeholders',
        },
        fixable: 'code',
        schema: [
            {
                type: 'object',
                properties: {
                    ignoreList: {
                        type: 'array',
                        items: {
                            type: 'string',
                        },
                    },
                },
                additionalProperties: false,
            },
        ],
    },
    create: function (context) {
        var callExpressionVisitor = function (node) {
            return checkNode(context, node);
        };
        if (context.parserServices.defineTemplateBodyVisitor) {
            return context.parserServices.defineTemplateBodyVisitor({
                CallExpression: callExpressionVisitor,
            }, {
                CallExpression: callExpressionVisitor,
            });
        }
        return {
            JSXOpeningElement: function (node) { return checkNode(context, node); },
            CallExpression: callExpressionVisitor,
        };
    },
};
exports.default = rule;
