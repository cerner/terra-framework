"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var ts_transformer_1 = require("@formatjs/ts-transformer");
function checkNode(context, node, _a) {
    var idInterpolationPattern = _a.idInterpolationPattern, idWhitelistRegexps = _a.idWhitelistRegexps;
    var msgs = (0, util_1.extractMessages)(node, context.settings);
    var _loop_1 = function (defaultMessage, description, id, idPropNode, descriptionNode, messagePropNode) {
        if (!idInterpolationPattern && !idPropNode) {
            context.report({
                node: node,
                message: "id must be specified",
            });
        }
        else if (idInterpolationPattern) {
            if (!defaultMessage) {
                context.report({
                    node: node,
                    message: "defaultMessage must be a string literal to calculate generated IDs",
                });
            }
            else if (!description && descriptionNode) {
                context.report({
                    node: node,
                    message: "description must be a string literal to calculate generated IDs",
                });
            }
            else {
                if (idWhitelistRegexps &&
                    id &&
                    idWhitelistRegexps.some(function (r) { return r.test(id); })) {
                    return { value: void 0 };
                }
                var correctId_1 = (0, ts_transformer_1.interpolateName)({
                    resourcePath: context.getFilename(),
                }, idInterpolationPattern, {
                    content: description
                        ? "".concat(defaultMessage, "#").concat(description)
                        : defaultMessage,
                });
                if (id !== correctId_1) {
                    var message = "\"id\" does not match with hash pattern ".concat(idInterpolationPattern);
                    if (idWhitelistRegexps) {
                        message += " or whitelisted patterns [\"".concat(idWhitelistRegexps
                            .map(function (r) { return r.toString(); })
                            .join('", "'), "\"]");
                    }
                    context.report({
                        node: node,
                        message: "".concat(message, ".\nExpected: ").concat(correctId_1, "\nActual: ").concat(id),
                        fix: function (fixer) {
                            if (idPropNode) {
                                if (idPropNode.type === 'JSXAttribute') {
                                    return fixer.replaceText(idPropNode, "id=\"".concat(correctId_1, "\""));
                                }
                                return fixer.replaceText(idPropNode, "id: '".concat(correctId_1, "'"));
                            }
                            // Insert after default message node
                            if (messagePropNode.type === 'JSXAttribute') {
                                return fixer.insertTextAfter(messagePropNode, " id=\"".concat(correctId_1, "\""));
                            }
                            return fixer.replaceText(messagePropNode, "defaultMessage: '".concat(defaultMessage, "', id: '").concat(correctId_1, "'"));
                        },
                    });
                }
            }
        }
    };
    for (var _i = 0, msgs_1 = msgs; _i < msgs_1.length; _i++) {
        var _b = msgs_1[_i][0], _c = _b.message, defaultMessage = _c.defaultMessage, description = _c.description, id = _c.id, idPropNode = _b.idPropNode, descriptionNode = _b.descriptionNode, messagePropNode = _b.messagePropNode;
        var state_1 = _loop_1(defaultMessage, description, id, idPropNode, descriptionNode, messagePropNode);
        if (typeof state_1 === "object")
            return state_1.value;
    }
}
exports.default = {
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce (generated) ID in message descriptor',
            category: 'Errors',
            recommended: false,
            url: 'https://formatjs.io/docs/tooling/linter#enforce-id',
        },
        fixable: 'code',
        schema: [
            {
                type: 'object',
                properties: {
                    idInterpolationPattern: {
                        type: 'string',
                        description: 'Pattern to verify ID against. Recommended value: [sha512:contenthash:base64:6]',
                    },
                    idWhitelist: {
                        type: 'array',
                        description: "An array of strings with regular expressions. This array allows whitelist custom ids for messages. For example '`\\\\.`' allows any id which has dot; `'^payment_.*'` - allows any custom id which has prefix `payment_`. Be aware that any backslash \\ provided via string must be escaped with an additional backslash.",
                        items: {
                            type: 'string',
                        },
                    },
                },
                required: ['idInterpolationPattern'],
                additionalProperties: false,
            },
        ],
    },
    create: function (context) {
        var _a;
        var tmp = (_a = context === null || context === void 0 ? void 0 : context.options) === null || _a === void 0 ? void 0 : _a[0];
        var opts = {
            idInterpolationPattern: tmp === null || tmp === void 0 ? void 0 : tmp.idInterpolationPattern,
        };
        if (Array.isArray(tmp === null || tmp === void 0 ? void 0 : tmp.idWhitelist)) {
            var idWhitelist = tmp.idWhitelist;
            opts.idWhitelistRegexps = idWhitelist.map(function (str) { return new RegExp(str, 'i'); });
        }
        var callExpressionVisitor = function (node) {
            return checkNode(context, node, opts);
        };
        if (context.parserServices.defineTemplateBodyVisitor) {
            return context.parserServices.defineTemplateBodyVisitor({
                CallExpression: callExpressionVisitor,
            }, {
                CallExpression: callExpressionVisitor,
            });
        }
        return {
            JSXOpeningElement: function (node) {
                return checkNode(context, node, opts);
            },
            CallExpression: callExpressionVisitor,
        };
    },
};
