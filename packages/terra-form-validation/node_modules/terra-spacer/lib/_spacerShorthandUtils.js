"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shorthandValidator = exports.mapShorthandToObject = exports.ShorthandPropErrors = void 0;
var _spacerConstants = require("./_spacerConstants");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var SHORTHAND_DELIMITER = ' ';
var shLengthBoundaries = {
  min: 1,
  max: 4
};
var conflictingPropNamesError = function conflictingPropNamesError() {
  var propName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<SUPPLY SHORTHAND PROP NAME>';
  var conflictingPropName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '<SUPPLY CONFLICTING PROP NAME>';
  var componentName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Spacer';
  return new Error("Expected only ".concat(propName, " or ").concat(conflictingPropName, " to be supplied to ").concat(componentName, " but both were provided. Validation failed."));
};
var invalidShArgsLengthError = function invalidShArgsLengthError() {
  var propName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<SUPPLY SHORTHAND PROP NAME>';
  var valuesLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '<SUPPLY RECEIVED ARGS LENGTH>';
  var minLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : shLengthBoundaries.min;
  var maxLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : shLengthBoundaries.max;
  var componentName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'Spacer';
  return new Error("Invalid number of argument substrings provided to ".concat(propName, " in ").concat(componentName, ". Expected ").concat(minLength, "-").concat(maxLength, ". Received ").concat(valuesLength, ". Validation failed."));
};
var invalidShArgValuesError = function invalidShArgValuesError() {
  var propName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<SUPPLY SHORTHAND PROP NAME>';
  var invalidShValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var expectedValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Object.values(_spacerConstants.SpacerSizes);
  var componentName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Spacer';
  return new Error("Expected ".concat(propName, " shorthand values to be one of ").concat(expectedValues, " but \"").concat(invalidShValues, "\" supplied to ").concat(componentName, ". Validation Failed."));
};
var ShorthandPropErrors = {
  conflictingPropName: conflictingPropNamesError,
  invalidShorthandLength: invalidShArgsLengthError,
  invalidShorthandArg: invalidShArgValuesError
};
exports.ShorthandPropErrors = ShorthandPropErrors;
var mapShorthandToObject = function mapShorthandToObject() {
  var propName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var propVal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var shValues = propVal.split(SHORTHAND_DELIMITER);
  var generateShObject = function generateShObject(top, right, bottom, left) {
    var _ref;
    return _ref = {}, _defineProperty(_ref, "".concat(propName, "Top"), top), _defineProperty(_ref, "".concat(propName, "Right"), right), _defineProperty(_ref, "".concat(propName, "Bottom"), bottom), _defineProperty(_ref, "".concat(propName, "Left"), left), _ref;
  };
  switch (shValues.length) {
    case 1:
      return generateShObject(shValues[0], shValues[0], shValues[0], shValues[0]);
    case 2:
      return generateShObject(shValues[0], shValues[1], shValues[0], shValues[1]);
    case 3:
      return generateShObject(shValues[0], shValues[1], shValues[2], shValues[1]);
    case 4:
      return generateShObject(shValues[0], shValues[1], shValues[2], shValues[3]);
    default:
      return {};
  }
};
exports.mapShorthandToObject = mapShorthandToObject;
var shorthandValidator = function shorthandValidator() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var propName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var propVal = props[propName];
  if (propVal === undefined || propVal === _spacerConstants.SpacerSizes.NONE) {
    return null;
  }
  var conflictingPropName = function () {
    var propertyConflicts = function propertyConflicts(dir) {
      return props["".concat(propName).concat(dir)] && props["".concat(propName).concat(dir)] !== _spacerConstants.SpacerSizes.NONE;
    };
    var conflictProp = (propertyConflicts('Top') ? "".concat(propName, "Top") : undefined) || (propertyConflicts('Right') ? "".concat(propName, "Right") : undefined) || (propertyConflicts('Bottom') ? "".concat(propName, "Bottom") : undefined) || (propertyConflicts('Left') ? "".concat(propName, "Left") : undefined);
    return conflictProp;
  }();
  if (conflictingPropName) {
    return conflictingPropNamesError(propName, conflictingPropName);
  }
  var shValuesUnfiltered = propVal.split(SHORTHAND_DELIMITER);
  var shValues = shValuesUnfiltered.filter(function (val) {
    return val;
  }); // Remove any falsey values (including empty strings)
  var shValueCountValid = shValues.length >= shLengthBoundaries.min && shValues.length <= shLengthBoundaries.max;
  if (!shValueCountValid) {
    return invalidShArgsLengthError(propName, shValues.length);
  }
  var invalidShValues = function () {
    var sizes = Object.values(_spacerConstants.SpacerSizes);
    var invalidValues = shValues.filter(function (val) {
      return sizes.indexOf(val) === -1;
    });
    return invalidValues.length > 0 ? invalidValues : null;
  }();
  if (invalidShValues) {
    return invalidShArgValuesError(propName, invalidShValues);
  }
  return null;
};
exports.shorthandValidator = shorthandValidator;